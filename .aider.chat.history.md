
# aider chat started at 2025-12-25 15:30:11

> C:\Users\gusta\.local\bin\aider --list-models openai/  
> Models which match "openai/":  
> - deepinfra/openai/gpt-oss-120b  
> - deepinfra/openai/gpt-oss-20b  
> - groq/openai/gpt-oss-120b  
> - groq/openai/gpt-oss-20b  
> - openai/chatgpt-4o-latest  
> - openai/container  
> - openai/ft:gpt-3.5-turbo  
> - openai/ft:gpt-3.5-turbo-0125  
> - openai/ft:gpt-3.5-turbo-0613  
> - openai/ft:gpt-3.5-turbo-1106  
> - openai/ft:gpt-4-0613  
> - openai/ft:gpt-4.1-2025-04-14  
> - openai/ft:gpt-4.1-mini-2025-04-14  
> - openai/ft:gpt-4.1-nano-2025-04-14  
> - openai/ft:gpt-4o-2024-08-06  
> - openai/ft:gpt-4o-2024-11-20  
> - openai/ft:gpt-4o-mini-2024-07-18  
> - openai/ft:o4-mini-2025-04-16  
> - openai/gpt-3.5-turbo  
> - openai/gpt-3.5-turbo-0125  
> - openai/gpt-3.5-turbo-0301  
> - openai/gpt-3.5-turbo-0613  
> - openai/gpt-3.5-turbo-1106  
> - openai/gpt-3.5-turbo-16k  
> - openai/gpt-3.5-turbo-16k-0613  
> - openai/gpt-4  
> - openai/gpt-4-0125-preview  
> - openai/gpt-4-0314  
> - openai/gpt-4-0613  
> - openai/gpt-4-1106-preview  
> - openai/gpt-4-1106-vision-preview  
> - openai/gpt-4-32k  
> - openai/gpt-4-32k-0314  
> - openai/gpt-4-32k-0613  
> - openai/gpt-4-turbo  
> - openai/gpt-4-turbo-2024-04-09  
> - openai/gpt-4-turbo-preview  
> - openai/gpt-4-vision-preview  
> - openai/gpt-4.1  
> - openai/gpt-4.1-2025-04-14  
> - openai/gpt-4.1-mini  
> - openai/gpt-4.1-mini-2025-04-14  
> - openai/gpt-4.1-nano  
> - openai/gpt-4.1-nano-2025-04-14  
> - openai/gpt-4.5-preview  
> - openai/gpt-4.5-preview-2025-02-27  
> - openai/gpt-4o  
> - openai/gpt-4o-2024-05-13  
> - openai/gpt-4o-2024-08-06  
> - openai/gpt-4o-2024-11-20  
> - openai/gpt-4o-audio-preview  
> - openai/gpt-4o-audio-preview-2024-10-01  
> - openai/gpt-4o-audio-preview-2024-12-17  
> - openai/gpt-4o-audio-preview-2025-06-03  
> - openai/gpt-4o-mini  
> - openai/gpt-4o-mini-2024-07-18  
> - openai/gpt-4o-mini-audio-preview  
> - openai/gpt-4o-mini-audio-preview-2024-12-17  
> - openai/gpt-4o-mini-realtime-preview  
> - openai/gpt-4o-mini-realtime-preview-2024-12-17  
> - openai/gpt-4o-mini-search-preview  
> - openai/gpt-4o-mini-search-preview-2025-03-11  
> - openai/gpt-4o-realtime-preview  
> - openai/gpt-4o-realtime-preview-2024-10-01  
> - openai/gpt-4o-realtime-preview-2024-12-17  
> - openai/gpt-4o-realtime-preview-2025-06-03  
> - openai/gpt-4o-search-preview  
> - openai/gpt-4o-search-preview-2025-03-11  
> - openai/gpt-5  
> - openai/gpt-5-2025-08-07  
> - openai/gpt-5-chat  
> - openai/gpt-5-chat-latest  
> - openai/gpt-5-mini  
> - openai/gpt-5-mini-2025-08-07  
> - openai/gpt-5-nano  
> - openai/gpt-5-nano-2025-08-07  
> - openai/gpt-5.1  
> - openai/gpt-5.1-2025-11-13  
> - openai/gpt-5.1-chat-latest  
> - openai/gpt-5.2  
> - openai/gpt-5.2-2025-12-11  
> - openai/gpt-5.2-chat-latest  
> - openai/gpt-realtime  
> - openai/gpt-realtime-2025-08-28  
> - openai/gpt-realtime-mini  
> - openai/o1  
> - openai/o1-2024-12-17  
> - openai/o1-mini  
> - openai/o1-mini-2024-09-12  
> - openai/o1-preview  
> - openai/o1-preview-2024-09-12  
> - openai/o3  
> - openai/o3-2025-04-16  
> - openai/o3-mini  
> - openai/o3-mini-2025-01-31  
> - openai/o4-mini  
> - openai/o4-mini-2025-04-16  
> - openrouter/openai/gpt-3.5-turbo  
> - openrouter/openai/gpt-3.5-turbo-16k  
> - openrouter/openai/gpt-4  
> - openrouter/openai/gpt-4-vision-preview  
> - openrouter/openai/gpt-4.1  
> - openrouter/openai/gpt-4.1-2025-04-14  
> - openrouter/openai/gpt-4.1-mini  
> - openrouter/openai/gpt-4.1-mini-2025-04-14  
> - openrouter/openai/gpt-4.1-nano  
> - openrouter/openai/gpt-4.1-nano-2025-04-14  
> - openrouter/openai/gpt-4o  
> - openrouter/openai/gpt-4o-2024-05-13  
> - openrouter/openai/gpt-4o-mini  
> - openrouter/openai/gpt-5  
> - openrouter/openai/gpt-5-chat  
> - openrouter/openai/gpt-5-codex  
> - openrouter/openai/gpt-5-mini  
> - openrouter/openai/gpt-5-nano  
> - openrouter/openai/gpt-5.2  
> - openrouter/openai/gpt-5.2-chat  
> - openrouter/openai/gpt-5.2-pro  
> - openrouter/openai/gpt-oss-120b  
> - openrouter/openai/gpt-oss-20b  
> - openrouter/openai/o1  
> - openrouter/openai/o1-mini  
> - openrouter/openai/o1-mini-2024-09-12  
> - openrouter/openai/o1-preview  
> - openrouter/openai/o1-preview-2024-09-12  
> - openrouter/openai/o3-mini  
> - openrouter/openai/o3-mini-high  
> - together_ai/openai/gpt-oss-120b  
> - together_ai/openai/gpt-oss-20b  
> - vercel_ai_gateway/openai/gpt-3.5-turbo  
> - vercel_ai_gateway/openai/gpt-3.5-turbo-instruct  
> - vercel_ai_gateway/openai/gpt-4-turbo  
> - vercel_ai_gateway/openai/gpt-4.1  
> - vercel_ai_gateway/openai/gpt-4.1-mini  
> - vercel_ai_gateway/openai/gpt-4.1-nano  
> - vercel_ai_gateway/openai/gpt-4o  
> - vercel_ai_gateway/openai/gpt-4o-mini  
> - vercel_ai_gateway/openai/o1  
> - vercel_ai_gateway/openai/o3  
> - vercel_ai_gateway/openai/o3-mini  
> - vercel_ai_gateway/openai/o4-mini  
> - vertex_ai-openai_models/vertex_ai/openai/gpt-oss-120b-maas  
> - vertex_ai-openai_models/vertex_ai/openai/gpt-oss-20b-maas  
> - vertex_ai/openai/gpt-oss-120b-maas  
> - vertex_ai/openai/gpt-oss-20b-maas  
> - wandb/openai/gpt-oss-120b  
> - wandb/openai/gpt-oss-20b  
> - watsonx/openai/gpt-oss-120b  

# aider chat started at 2025-12-25 15:31:38

> C:\Users\gusta\.local\bin\aider -model openai/gpt-5.2  
> Using gpt-4o model with API key from environment.  
> Creating empty file D:\Documents\01_MCI\WS2025\Studentproject\Software\aider\openai\gpt-5.2  
> Aider v0.86.1  
> Main model: gpt-4o with diff edit format  
> Weak model: gpt-4o-mini  
> Git repo: none  
> Repo-map: disabled  
> Added gpt-5.2 to the chat.  

#### odel  
> litellm.AuthenticationError: AuthenticationError: OpenAIException - Incorrect API key provided: "sk-proj**********************************************************************************************************************************************************mMA". You can find your API key at https://platform.openai.com/account/api-keys.  
> The API provider is not able to authenticate you. Check your API key.  
> https://platform.openai.com/account/api-keys  

# aider chat started at 2025-12-25 15:32:49

> C:\Users\gusta\.local\bin\aider -model openai/gpt-5.2  
> Using gpt-4o model with API key from environment.  
> Aider v0.86.1  
> Main model: gpt-4o with diff edit format  
> Weak model: gpt-4o-mini  
> Git repo: none  
> Repo-map: disabled  
> Added gpt-5.2 to the chat.  

#### odel  
> litellm.AuthenticationError: AuthenticationError: OpenAIException - Incorrect API key provided: "sk-proj**********************************************************************************************************************************************************mMA". You can find your API key at https://platform.openai.com/account/api-keys.  
> The API provider is not able to authenticate you. Check your API key.  
> https://platform.openai.com/account/api-keys  

# aider chat started at 2025-12-25 15:34:21

> C:\Users\gusta\.local\bin\aider -model gpt-5.2  
> Using gpt-4o model with API key from environment.  
> Creating empty file D:\Documents\01_MCI\WS2025\Studentproject\Software\aider\gpt-5.2  
> Aider v0.86.1  
> Main model: gpt-4o with diff edit format  
> Weak model: gpt-4o-mini  
> Git repo: none  
> Repo-map: disabled  
> Added gpt-5.2 to the chat.  

#### odel  
> litellm.AuthenticationError: AuthenticationError: OpenAIException - Incorrect API key provided: "sk-proj**********************************************************************************************************************************************************mMA". You can find your API key at https://platform.openai.com/account/api-keys.  
> The API provider is not able to authenticate you. Check your API key.  
> https://platform.openai.com/account/api-keys  

# aider chat started at 2025-12-25 15:35:37

> C:\Users\gusta\.local\bin\aider -model gpt-5.2  
> Using gpt-4o model with API key from environment.  
> Aider v0.86.1  
> Main model: gpt-4o with diff edit format  
> Weak model: gpt-4o-mini  
> Git repo: none  
> Repo-map: disabled  
> Added gpt-5.2 to the chat.  

#### odel  

Es scheint, dass du eine Datei namens `odel` bearbeiten möchtest. Bitte füge die Datei `odel` zum Chat hinzu, damit ich die notwendigen Änderungen vornehmen kann.

> Tokens: 2.4k sent, 48 received. Cost: $0.0066 message, $0.0066 session.  

# aider chat started at 2025-12-25 15:36:19

> C:\Users\gusta\.local\bin\aider --model gpt-5.2  
> Aider v0.86.1  
> Model: gpt-5.2 with whole edit format  
> Git repo: none  
> Repo-map: disabled  

#### /exi  

# aider chat started at 2025-12-25 15:42:27

> You can skip this check with --no-gitignore  
> Add .aider* to .gitignore (recommended)? (Y)es/(N)o [Yes]: y  
> Added .aider* to .gitignore  
> C:\Users\gusta\.local\bin\aider --map-tokens 2048  
> Using gpt-4o model with API key from environment.  
> Aider v0.86.1  
> Main model: gpt-4o with diff edit format  
> Weak model: gpt-4o-mini  
> Git repo: .git with 17 files  
> Repo-map: using 2048 tokens, auto refresh  

#### /ex  

# aider chat started at 2025-12-25 15:43:31

> C:\Users\gusta\.local\bin\aider --model gpt-5.2  
> Aider v0.86.1  
> Model: gpt-5.2 with whole edit format  
> Git repo: .git with 17 files  
> Repo-map: using 4096 tokens, auto refresh  

#### /architect  
> Aider v0.86.1  
> Model: gpt-5.2 with architect edit format  
> Editor model: gpt-5.2 with editor-whole edit format  
> Git repo: .git with 17 files  
> Repo-map: using 4096 tokens, auto refresh  

#### bitte behebe diese fehlermeldung:(cETT) D:\Documents\01_MCI\WS2025\Studentproject\Software\aider>python main.py  
#### Traceback (most recent call last):  
####   File "D:\Documents\01_MCI\WS2025\Studentproject\Software\aider\main.py", line 14, in <module>  
####     from PyQt6.QtWidgets import QApplication  
#### ImportError: DLL load failed while importing QtWidgets: Die angegebene Prozedur wurde nicht gefunden.  
####                                                                 aider --list-models openai/  
#### (cETT) D:\Documents\01_MCI\WS2025\Studentproject\Software\aider>  
> main.py  
> Add file to the chat? (Y)es/(N)o/(D)on't ask again [Yes]: y  

Die Meldung ist **kein Code-Fehler in `main.py`**, sondern ein **Umgebungs-/Binary-Problem**: Windows kann eine benötigte Qt‑DLL/Abhängigkeit nicht laden („Prozedur wurde nicht gefunden“). Das passiert typischerweise bei **inkompatiblen PyQt6/Qt6 Wheels**, **falscher Python-Architektur**, oder **fehlenden MSVC Runtime DLLs**.

Da du „bitte behebe“ sagst: Ich gebe dir **konkrete, unmissverständliche Schritte**, die dein Editor/Setup ausführen soll. **Am Code müssen wir dafür nichts ändern** (optional kann man nur eine bessere Fehlermeldung ausgeben, aber das löst die DLL nicht).

## 1) Prüfen: Python/venv Architektur & Version
Im aktiven venv `(cETT)` ausführen:
```bat
python -c "import platform,sys; print(sys.version); print(platform.architecture()); print(platform.platform())"
```
Erwartung: **64-bit** Python auf 64-bit Windows. Wenn hier 32-bit steht: venv neu mit 64-bit Python erstellen.

## 2) PyQt6 sauber neu installieren (häufigste Lösung)
Im venv:
```bat
pip uninstall -y PyQt6 PyQt6-Qt6 PyQt6-sip
pip cache purge
pip install --upgrade pip
pip install PyQt6
```

Wenn es danach immer noch knallt, pinne auf eine stabile Kombination (oft hilft das):
```bat
pip uninstall -y PyQt6 PyQt6-Qt6 PyQt6-sip
pip install "PyQt6==6.7.1"
```

## 3) Microsoft Visual C++ Runtime installieren/repair
Qt6 benötigt die MSVC Runtime. Installiere/repair:
- **Microsoft Visual C++ Redistributable 2015–2022 (x64)**

Danach Windows/Terminal neu starten und erneut testen:
```bat
python -c "from PyQt6.QtWidgets import QApplication; print('OK')"
```

## 4) Konflikte durch PATH/alte Qt DLLs ausschließen
Wenn du andere Qt-Installationen hast (Anaconda, QGIS, alte Qt/bin im PATH), kann Windows die falschen DLLs ziehen.

Test: In einem frischen Terminal **nur venv aktivieren**, dann:
```bat
where Qt6Core.dll
where qwindows.dll
```
Wenn `where` Treffer außerhalb deines venv/Python zeigt, ist das verdächtig. Dann:
- Entferne/verschiebe entsprechende PATH-Einträge (temporär) oder starte in einer „sauberen“ Shell.

## 5) Minimaler Diagnose-Check (falls weiterhin Fehler)
Bitte führe aus und poste die Ausgabe hier:
```bat
python -c "import PyQt6; import PyQt6.QtCore as qc; print(PyQt6.__file__); print(qc.QLibraryInfo.path(qc.QLibraryInfo.LibraryPath.PluginsPath))"
```

---

### Optional (nur UX): bessere Fehlermeldung im Code
Wenn du willst, können wir `main.py` so anpassen, dass bei ImportError eine klare Anleitung ausgegeben wird. **Das behebt die DLL nicht**, macht aber die Fehlersuche für Nutzer einfacher.

Wenn du das möchtest, sag kurz Bescheid, dann gebe ich dir die **minimalen Code-Änderungen** (nur ein try/except um den PyQt6-Import).

> Tokens: 3.5k sent, 788 received. Cost: $0.02 message, $0.02 session.  

#### Die Meldung ist **kein Code-Fehler in `main.py`**, sondern ein **Umgebungs-/Binary-Problem**: Windows kann eine benötigte Qt‑DLL/Abhängigkeit nicht laden („Prozedur wurde nicht gefunden“). Das passiert typischerweise bei **inkompatiblen PyQt6/Qt6 Wheels**, **falscher Python-Architektur**, oder **fehlenden MSVC Runtime DLLs**.  
####   
#### Da du „bitte behebe“ sagst: Ich gebe dir **konkrete, unmissverständliche Schritte**, die dein Editor/Setup ausführen soll. **Am Code müssen wir dafür nichts ändern** (optional kann man nur eine bessere Fehlermeldung ausgeben, aber das löst die DLL nicht).  
####   
#### ## 1) Prüfen: Python/venv Architektur & Version  
#### Im aktiven venv `(cETT)` ausführen:  
#### ```bat  
#### python -c "import platform,sys; print(sys.version); print(platform.architecture()); print(platform.platform())"  
#### ```  
#### Erwartung: **64-bit** Python auf 64-bit Windows. Wenn hier 32-bit steht: venv neu mit 64-bit Python erstellen.  
####   
#### ## 2) PyQt6 sauber neu installieren (häufigste Lösung)  
#### Im venv:  
#### ```bat  
#### pip uninstall -y PyQt6 PyQt6-Qt6 PyQt6-sip  
#### pip cache purge  
#### pip install --upgrade pip  
#### pip install PyQt6  
#### ```  
####   
#### Wenn es danach immer noch knallt, pinne auf eine stabile Kombination (oft hilft das):  
#### ```bat  
#### pip uninstall -y PyQt6 PyQt6-Qt6 PyQt6-sip  
#### pip install "PyQt6==6.7.1"  
#### ```  
####   
#### ## 3) Microsoft Visual C++ Runtime installieren/repair  
#### Qt6 benötigt die MSVC Runtime. Installiere/repair:  
#### - **Microsoft Visual C++ Redistributable 2015–2022 (x64)**  
####   
#### Danach Windows/Terminal neu starten und erneut testen:  
#### ```bat  
#### python -c "from PyQt6.QtWidgets import QApplication; print('OK')"  
#### ```  
####   
#### ## 4) Konflikte durch PATH/alte Qt DLLs ausschließen  
#### Wenn du andere Qt-Installationen hast (Anaconda, QGIS, alte Qt/bin im PATH), kann Windows die falschen DLLs ziehen.  
####   
#### Test: In einem frischen Terminal **nur venv aktivieren**, dann:  
#### ```bat  
#### where Qt6Core.dll  
#### where qwindows.dll  
#### ```  
#### Wenn `where` Treffer außerhalb deines venv/Python zeigt, ist das verdächtig. Dann:  
#### - Entferne/verschiebe entsprechende PATH-Einträge (temporär) oder starte in einer „sauberen“ Shell.  
####   
#### ## 5) Minimaler Diagnose-Check (falls weiterhin Fehler)  
#### Bitte führe aus und poste die Ausgabe hier:  
#### ```bat  
#### python -c "import PyQt6; import PyQt6.QtCore as qc; print(PyQt6.__file__); print(qc.QLibraryInfo.path(qc.QLibraryInfo.LibraryPath.PluginsPath))"  
#### ```  
####   
#### ---  
####   
#### ### Optional (nur UX): bessere Fehlermeldung im Code  
#### Wenn du willst, können wir `main.py` so anpassen, dass bei ImportError eine klare Anleitung ausgegeben wird. **Das behebt die DLL nicht**, macht aber die Fehlersuche für Nutzer einfacher.  
####   
#### Wenn du das möchtest, sag kurz Bescheid, dann gebe ich dir die **minimalen Code-Änderungen** (nur ein try/except um den PyQt6-Import).  

main.py
```
#!/usr/bin/env python3
"""
Eye Tracking Analysis Tool

A software tool to analyze eye tracking data to compare different tasks
with each other in regards to their cognitive load.

Main entry point.
"""
from __future__ import annotations

import sys


def _print_pyqt6_env_help(exc: BaseException) -> None:
    msg = f"""
Fehler beim Laden von PyQt6/Qt6 (häufig ein DLL-/Umgebungsproblem unter Windows).

Ursache (typisch):
- Inkompatible PyQt6/Qt6 Wheels
- 32-bit Python auf 64-bit Windows (oder umgekehrt)
- Fehlende Microsoft Visual C++ Runtime (2015–2022, x64)
- Konflikte durch andere Qt-DLLs im PATH (Anaconda/QGIS/alte Qt-Installationen)

Original-Fehler:
{exc!r}

Konkrete Schritte (im aktiven venv ausführen):

1) Architektur prüfen:
   python -c "import platform,sys; print(sys.version); print(platform.architecture()); print(platform.platform())"

2) PyQt6 sauber neu installieren:
   pip uninstall -y PyQt6 PyQt6-Qt6 PyQt6-sip
   pip cache purge
   pip install --upgrade pip
   pip install PyQt6

   Falls weiterhin Fehler:
   pip uninstall -y PyQt6 PyQt6-Qt6 PyQt6-sip
   pip install "PyQt6==6.7.1"

3) MSVC Runtime installieren/repair:
   Microsoft Visual C++ Redistributable 2015–2022 (x64)

4) PATH-Konflikte prüfen:
   where Qt6Core.dll
   where qwindows.dll

5) Diagnose-Ausgabe:
   python -c "import PyQt6; import PyQt6.QtCore as qc; print(PyQt6.__file__); print(qc.QLibraryInfo.path(qc.QLibraryInfo.LibraryPath.PluginsPath))"
"""
    print(msg.strip(), file=sys.stderr)


try:
    from PyQt6.QtWidgets import QApplication
except Exception as exc:  # noqa: BLE001
    _print_pyqt6_env_help(exc)
    raise

from main_window import MainWindow


def main() -> int:
    """Main entry point for the application."""
    app = QApplication(sys.argv)
    app.setApplicationName("Eye Tracking Analysis Tool")

    window = MainWindow()
    window.show()

    return app.exec()


if __name__ == "__main__":
    sys.exit(main())
```

> Tokens: 1.5k sent, 540 received. Cost: $0.01 message, $0.03 session.  
> Applied edit to main.py  
> Commit 5e9ed5e fix: Gebe Hilfetext bei PyQt6-Importfehlern unter Windows aus  
> You can use /undo to undo and discard each aider commit.  

#### In the pop up window group tasks: i dont like the layout. when it first spawn the labels group name and participants are to far away from chatbox and drop/down menu. Please make the distance between them smaller and orient the from the top.  

Änderung betrifft das Layout im **„Group Tasks“-Popup** (Klasse `GroupTasksDialog`), konkret die Abstände/Alignment der Label („Group name“, „Participants“/Task-Auswahl) zu den Eingabefeldern (Textbox/Dropdown). Dafür müssen wir in `dialogs.py` (und ggf. `eye_tracking_tool/dialogs.py`, falls beide Varianten genutzt werden) die Layout-Margins/Spacings und das vertikale Alignment anpassen.

Damit ich dir **exakt** sagen kann, welche Zeilen du ändern musst (ohne das ganze File zu zeigen), brauche ich den aktuellen Code der betroffenen Dialog-Klasse.

Bitte füge diese Dateien vollständig in den Chat ein (mindestens die `GroupTasksDialog`-Klasse inkl. `__init__` und Layout-Aufbau):

1) `dialogs.py`  
2) falls die App aus dem Unterordner läuft: `eye_tracking_tool/dialogs.py`

Zusatz: Sag kurz, **welche Labels genau** zu weit weg sind:
- das Label neben dem **Gruppennamen-Textfeld**?
- das Label neben dem **Task-Dropdown**?
- oder die Zeilen in der Tabelle/Rows (pro Gruppe)?

Sobald ich den Code sehe, gebe ich dir präzise Anweisungen wie:
- `main_layout.setContentsMargins(...)` reduzieren
- `main_layout.setSpacing(...)` reduzieren
- bei `QFormLayout`: `setVerticalSpacing`, `setLabelAlignment(Qt.AlignTop)`, `setFormAlignment(Qt.AlignTop)`
- bei `QGridLayout`: `setRowMinimumHeight`, `setVerticalSpacing`, `setAlignment(Qt.AlignTop)`
- ggf. `QSizePolicy`/`addStretch` entfernen oder nach unten verschieben, damit alles oben „anklebt“.

> Tokens: 4.7k sent, 414 received. Cost: $0.01 message, $0.04 session.  
> dialogs.py  
> Add file to the chat? (Y)es/(N)o/(A)ll/(S)kip all/(D)on't ask again [Yes]: y  
> eye_tracking_tool\dialogs.py  
> Add file to the chat? (Y)es/(N)o/(A)ll/(S)kip all/(D)on't ask again [Yes]: y  

Ändere das Layout in **beiden** Dateien, weil sie aktuell dupliziert sind und du sonst je nach Entry-Point nur eine Version fixst:

- `dialogs.py`
- `eye_tracking_tool/dialogs.py`

Ziel: **Header („Group name“, „Tasks“) näher an die Group-Row-Widgets bringen** und **alles oben ausrichten** (nicht „in der Mitte schweben“).

## 1) In `GroupTasksDialog.__init__`: Spacing/Margins der Container-Layouts reduzieren

Suche in `GroupTasksDialog.__init__` den Block:

```py
container = QWidget()
self.container_layout = QVBoxLayout(container)

# Header
header = QHBoxLayout()
header.addWidget(QLabel("Group name"), stretch=1)
header.addWidget(QLabel("Tasks"), stretch=2)
self.container_layout.addLayout(header)
```

### Änderungen (genau so einfügen/ersetzen)

**Direkt nach** `self.container_layout = QVBoxLayout(container)` diese Zeilen hinzufügen:

```py
self.container_layout.setContentsMargins(0, 0, 0, 0)
self.container_layout.setSpacing(4)
```

**Direkt nach** `header = QHBoxLayout()` diese Zeilen hinzufügen:

```py
header.setContentsMargins(0, 0, 0, 0)
header.setSpacing(8)
```

Damit wird der Abstand zwischen Header und den folgenden Zeilen deutlich kleiner und die Header-Zeile sitzt „näher“ an den Controls.

## 2) Header-Labels oben ausrichten (Top-Alignment)

Ersetze im Header-Block die beiden `addWidget(...)` Zeilen durch Varianten mit Alignment:

```py
header.addWidget(QLabel("Group name"), stretch=1, alignment=Qt.AlignmentFlag.AlignTop)
header.addWidget(QLabel("Tasks"), stretch=2, alignment=Qt.AlignmentFlag.AlignTop)
```

(Die `Qt`-Importe sind bereits vorhanden.)

## 3) Row-Layouts ebenfalls „kompakt“ machen

Im selben `GroupTasksDialog.__init__` gibt es in der Schleife pro Gruppe:

```py
row_layout = QHBoxLayout(row_widget)
row_layout.setContentsMargins(0, 4, 0, 4)
```

Ändere die Margins auf kleiner, z.B.:

```py
row_layout.setContentsMargins(0, 2, 0, 2)
row_layout.setSpacing(8)
```

`setSpacing(8)` neu hinzufügen (falls nicht vorhanden). Das reduziert vertikale Luft und hält die Elemente oben/kompakt.

## 4) Scroll-Container oben „ankleben“

Direkt nachdem du `scroll.setWidget(container)` setzt (oder direkt nach `scroll = QScrollArea()`), setze das Alignment des ScrollArea-Inhalts auf oben. PyQt6: am zuverlässigsten über das Container-Layout:

Füge **nach** `self.container_layout = QVBoxLayout(container)` zusätzlich hinzu (falls du es nicht schon in Schritt 1 eingefügt hast; dann nur ergänzen):

```py
self.container_layout.setAlignment(Qt.AlignmentFlag.AlignTop)
```

Das sorgt dafür, dass die Inhalte im Scrollbereich oben beginnen und nicht „verteilt“ wirken.

## 5) Optional: Abstand zwischen „Task labels“-Box und Header verkleinern

Wenn der Abstand zwischen dem oberen `naming_group` und dem Scrollbereich zu groß ist, reduziere das Spacing des `main_layout`:

In `GroupTasksDialog.__init__` nach `main_layout = QVBoxLayout(self)` hinzufügen:

```py
main_layout.setContentsMargins(8, 8, 8, 8)
main_layout.setSpacing(6)
```

(Wenn du sehr kompakt willst: `setSpacing(4)`.)

---

### Wichtig
Mache diese Änderungen **identisch** in:
- `dialogs.py` → `class GroupTasksDialog`
- `eye_tracking_tool/dialogs.py` → `class GroupTasksDialog`

---

Wenn du danach immer noch „zu weit weg“ meinst, brauche ich ein Screenshot: Meinst du den Abstand **zwischen Header und erster Gruppenzeile**, oder den Abstand **zwischen den zwei Spalten (Group name vs Tasks)**? Dann passe ich gezielt `stretch`/FixedWidth/Spacing an.

> Tokens: 11k sent, 968 received. Cost: $0.03 message, $0.07 session.  

#### Ändere das Layout in **beiden** Dateien, weil sie aktuell dupliziert sind und du sonst je nach Entry-Point nur eine Version fixst:  
####   
#### - `dialogs.py`  
#### - `eye_tracking_tool/dialogs.py`  
####   
#### Ziel: **Header („Group name“, „Tasks“) näher an die Group-Row-Widgets bringen** und **alles oben ausrichten** (nicht „in der Mitte schweben“).  
####   
#### ## 1) In `GroupTasksDialog.__init__`: Spacing/Margins der Container-Layouts reduzieren  
####   
#### Suche in `GroupTasksDialog.__init__` den Block:  
####   
#### ```py  
#### container = QWidget()  
#### self.container_layout = QVBoxLayout(container)  
####   
#### # Header  
#### header = QHBoxLayout()  
#### header.addWidget(QLabel("Group name"), stretch=1)  
#### header.addWidget(QLabel("Tasks"), stretch=2)  
#### self.container_layout.addLayout(header)  
#### ```  
####   
#### ### Änderungen (genau so einfügen/ersetzen)  
####   
#### **Direkt nach** `self.container_layout = QVBoxLayout(container)` diese Zeilen hinzufügen:  
####   
#### ```py  
#### self.container_layout.setContentsMargins(0, 0, 0, 0)  
#### self.container_layout.setSpacing(4)  
#### ```  
####   
#### **Direkt nach** `header = QHBoxLayout()` diese Zeilen hinzufügen:  
####   
#### ```py  
#### header.setContentsMargins(0, 0, 0, 0)  
#### header.setSpacing(8)  
#### ```  
####   
#### Damit wird der Abstand zwischen Header und den folgenden Zeilen deutlich kleiner und die Header-Zeile sitzt „näher“ an den Controls.  
####   
#### ## 2) Header-Labels oben ausrichten (Top-Alignment)  
####   
#### Ersetze im Header-Block die beiden `addWidget(...)` Zeilen durch Varianten mit Alignment:  
####   
#### ```py  
#### header.addWidget(QLabel("Group name"), stretch=1, alignment=Qt.AlignmentFlag.AlignTop)  
#### header.addWidget(QLabel("Tasks"), stretch=2, alignment=Qt.AlignmentFlag.AlignTop)  
#### ```  
####   
#### (Die `Qt`-Importe sind bereits vorhanden.)  
####   
#### ## 3) Row-Layouts ebenfalls „kompakt“ machen  
####   
#### Im selben `GroupTasksDialog.__init__` gibt es in der Schleife pro Gruppe:  
####   
#### ```py  
#### row_layout = QHBoxLayout(row_widget)  
#### row_layout.setContentsMargins(0, 4, 0, 4)  
#### ```  
####   
#### Ändere die Margins auf kleiner, z.B.:  
####   
#### ```py  
#### row_layout.setContentsMargins(0, 2, 0, 2)  
#### row_layout.setSpacing(8)  
#### ```  
####   
#### `setSpacing(8)` neu hinzufügen (falls nicht vorhanden). Das reduziert vertikale Luft und hält die Elemente oben/kompakt.  
####   
#### ## 4) Scroll-Container oben „ankleben“  
####   
#### Direkt nachdem du `scroll.setWidget(container)` setzt (oder direkt nach `scroll = QScrollArea()`), setze das Alignment des ScrollArea-Inhalts auf oben. PyQt6: am zuverlässigsten über das Container-Layout:  
####   
#### Füge **nach** `self.container_layout = QVBoxLayout(container)` zusätzlich hinzu (falls du es nicht schon in Schritt 1 eingefügt hast; dann nur ergänzen):  
####   
#### ```py  
#### self.container_layout.setAlignment(Qt.AlignmentFlag.AlignTop)  
#### ```  
####   
#### Das sorgt dafür, dass die Inhalte im Scrollbereich oben beginnen und nicht „verteilt“ wirken.  
####   
#### ## 5) Optional: Abstand zwischen „Task labels“-Box und Header verkleinern  
####   
#### Wenn der Abstand zwischen dem oberen `naming_group` und dem Scrollbereich zu groß ist, reduziere das Spacing des `main_layout`:  
####   
#### In `GroupTasksDialog.__init__` nach `main_layout = QVBoxLayout(self)` hinzufügen:  
####   
#### ```py  
#### main_layout.setContentsMargins(8, 8, 8, 8)  
#### main_layout.setSpacing(6)  
#### ```  
####   
#### (Wenn du sehr kompakt willst: `setSpacing(4)`.)  
####   
#### ---  
####   
#### ### Wichtig  
#### Mache diese Änderungen **identisch** in:  
#### - `dialogs.py` → `class GroupTasksDialog`  
#### - `eye_tracking_tool/dialogs.py` → `class GroupTasksDialog`  
####   
#### ---  
####   
#### Wenn du danach immer noch „zu weit weg“ meinst, brauche ich ein Screenshot: Meinst du den Abstand **zwischen Header und erster Gruppenzeile**, oder den Abstand **zwischen den zwei Spalten (Group name vs Tasks)**? Dann passe ich gezielt `stretch`/FixedWidth/Spacing an.  

eye_tracking_tool\dialogs.py
```
"""
Dialog windows and custom widgets using PyQt6.
"""
from __future__ import annotations

from typing import Optional, List, Callable, Set

from PyQt6.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QWidget, QLabel, QPushButton,
    QListWidget, QListWidgetItem, QCheckBox, QLineEdit, QComboBox,
    QFrame, QScrollArea, QGroupBox, QGridLayout, QAbstractItemView,
    QMessageBox
)
from PyQt6.QtCore import Qt

from state import state


class MultiSelectDialog(QDialog):
    """
    Modal dialog for multi-selection:
    - Select all checkbox
    - Multi-select list
    - OK / Cancel
    """

    def __init__(
        self,
        parent: QWidget,
        title: str,
        items: List[str],
        selected: Optional[List[str]] = None,
        gray_hint_items: Optional[List[str]] = None,
        display_func: Optional[Callable[[str], str]] = None,
    ) -> None:
        super().__init__(parent)
        self.items = items
        self._selected_set = set(selected or [])
        self._gray_hint = set(gray_hint_items or [])
        self._display_func = display_func or (lambda x: x)
        self.result: Optional[List[str]] = None

        self.setWindowTitle(title)
        self.setMinimumSize(420, 460)
        self.setModal(True)

        layout = QVBoxLayout(self)

        # Select all checkbox
        self.select_all_cb = QCheckBox("Select all")
        self.select_all_cb.stateChanged.connect(self._toggle_select_all)
        layout.addWidget(self.select_all_cb)

        # List widget
        self.list_widget = QListWidget()
        self.list_widget.setSelectionMode(QAbstractItemView.SelectionMode.MultiSelection)

        for item in self.items:
            list_item = QListWidgetItem(self._display_func(item))
            list_item.setData(Qt.ItemDataRole.UserRole, item)
            if item in self._gray_hint:
                list_item.setForeground(Qt.GlobalColor.gray)
            if item in self._selected_set:
                list_item.setSelected(True)
            self.list_widget.addItem(list_item)

        layout.addWidget(self.list_widget)

        # Buttons
        btn_layout = QHBoxLayout()
        btn_layout.addStretch()

        ok_btn = QPushButton("OK")
        ok_btn.clicked.connect(self._on_ok)
        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self._on_cancel)

        btn_layout.addWidget(ok_btn)
        btn_layout.addWidget(cancel_btn)
        layout.addLayout(btn_layout)

    def _toggle_select_all(self, state: int) -> None:
        for i in range(self.list_widget.count()):
            self.list_widget.item(i).setSelected(state == Qt.CheckState.Checked.value)

    def _on_ok(self) -> None:
        self.result = [
            self.list_widget.item(i).data(Qt.ItemDataRole.UserRole)
            for i in range(self.list_widget.count())
            if self.list_widget.item(i).isSelected()
        ]
        self.accept()

    def _on_cancel(self) -> None:
        self.result = None
        self.reject()


class MultiSelectPicker(QWidget):
    """
    A button that opens a multi-select popup dialog.
    """

    def __init__(
        self,
        parent: QWidget,
        options: List[str],
        get_global_selected: Callable[[], Set[str]],
        on_change: Optional[Callable[[], None]] = None,
        placeholder: str = "Select items...",
        popup_title: str = "Select items",
        display_func: Optional[Callable[[str], str]] = None,
    ) -> None:
        super().__init__(parent)
        self._options = options
        self._get_global_selected = get_global_selected
        self._on_change = on_change
        self._placeholder = placeholder
        self._popup_title = popup_title
        self._display_func = display_func or (lambda x: x)

        self._selected: Set[str] = set()

        layout = QHBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)

        self._btn = QPushButton(placeholder)
        self._btn.clicked.connect(self._open_popup)
        layout.addWidget(self._btn)

        self._refresh_summary()

    def get_selected(self) -> List[str]:
        return [o for o in self._options if o in self._selected]

    def set_selected(self, selected: List[str]) -> None:
        self._selected = set(selected)
        self._refresh_summary()

    def refresh_ui(self) -> None:
        self._refresh_summary()

    def _refresh_summary(self) -> None:
        selected = self.get_selected()
        if not selected:
            self._btn.setText(self._placeholder)
        elif len(selected) <= 3:
            self._btn.setText(", ".join(self._display_func(s) for s in selected))
        else:
            self._btn.setText(f"{len(selected)} selected")

    def _open_popup(self) -> None:
        global_selected = self._get_global_selected()
        gray_hint = [o for o in self._options if o in global_selected and o not in self._selected]

        dialog = MultiSelectDialog(
            self,
            title=self._popup_title,
            items=self._options,
            selected=list(self._selected),
            gray_hint_items=gray_hint,
            display_func=self._display_func,
        )

        if dialog.exec() == QDialog.DialogCode.Accepted and dialog.result is not None:
            self._selected = set(dialog.result)
            self._refresh_summary()
            if self._on_change is not None:
                self._on_change()


class GroupParticipantsDialog(QDialog):
    """Dialog for grouping participants."""

    def __init__(self, parent: QWidget) -> None:
        super().__init__(parent)
        self.setWindowTitle("Group Participants")
        self.setMinimumSize(900, 600)
        self.setModal(True)

        self.max_groups = 15

        main_layout = QVBoxLayout(self)

        # Scrollable area
        scroll = QScrollArea()
        scroll.setWidgetResizable(True)
        container = QWidget()
        self.container_layout = QVBoxLayout(container)

        # Header
        header = QHBoxLayout()
        header.addWidget(QLabel("Group name"), stretch=1)
        header.addWidget(QLabel("Participants"), stretch=2)
        self.container_layout.addLayout(header)

        # Group rows
        self.group_name_edits: List[QLineEdit] = []
        self.group_members: List[List[str]] = []
        self.select_btns: List[QPushButton] = []
        self.row_widgets: List[QWidget] = []

        existing_ids = sorted(state.participant_groups.keys())

        for i in range(self.max_groups):
            gid = existing_ids[i] if i < len(existing_ids) else f"G{i+1}"

            row_widget = QWidget()
            row_layout = QHBoxLayout(row_widget)
            row_layout.setContentsMargins(0, 4, 0, 4)

            name_edit = QLineEdit(state.group_names.get(gid, f"Group {i+1}"))
            name_edit.setFixedWidth(200)
            row_layout.addWidget(name_edit)

            members = state.participant_groups.get(gid, []).copy()

            btn = QPushButton("Select participants...")
            btn.clicked.connect(lambda checked, idx=i: self._select_participants(idx))
            row_layout.addWidget(btn, stretch=1)

            self.group_name_edits.append(name_edit)
            self.group_members.append(members)
            self.select_btns.append(btn)
            self.row_widgets.append(row_widget)

            self.container_layout.addWidget(row_widget)
            self._update_btn_text(i)

        scroll.setWidget(container)
        main_layout.addWidget(scroll)

        # Buttons
        btn_layout = QHBoxLayout()
        btn_layout.addStretch()

        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        save_btn = QPushButton("Save & Apply")
        save_btn.clicked.connect(self._save_apply)

        btn_layout.addWidget(save_btn)
        btn_layout.addWidget(cancel_btn)
        main_layout.addLayout(btn_layout)

        self._update_row_visibility()

    def _already_selected_elsewhere(self, current_row: int) -> List[str]:
        s: Set[str] = set()
        for r, members in enumerate(self.group_members):
            if r != current_row:
                s.update(members)
        return sorted(s)

    def _update_btn_text(self, row_idx: int) -> None:
        sel = self.group_members[row_idx]
        if not sel:
            self.select_btns[row_idx].setText("Select participants...")
        elif len(sel) <= 4:
            self.select_btns[row_idx].setText(", ".join(sel))
        else:
            self.select_btns[row_idx].setText(f"{len(sel)} selected")

    def _update_row_visibility(self) -> None:
        for i in range(self.max_groups):
            if i == 0:
                self.row_widgets[i].show()
            elif self.group_members[i - 1]:
                self.row_widgets[i].show()
            else:
                self.row_widgets[i].hide()

    def _select_participants(self, row_idx: int) -> None:
        dialog = MultiSelectDialog(
            self,
            title=f"Select participants for {self.group_name_edits[row_idx].text() or f'Group {row_idx+1}'}",
            items=state.participants_cache,
            selected=self.group_members[row_idx],
            gray_hint_items=self._already_selected_elsewhere(row_idx),
        )

        if dialog.exec() == QDialog.DialogCode.Accepted and dialog.result is not None:
            self.group_members[row_idx] = dialog.result
            self._update_btn_text(row_idx)
            self._update_row_visibility()

    def _save_apply(self) -> None:
        new_groups: dict = {}
        new_names: dict = {}

        for i in range(self.max_groups):
            gid = f"G{i+1}"
            name = self.group_name_edits[i].text().strip() or f"Group {i+1}"
            members = self.group_members[i]

            if not members and i > 0:
                continue

            new_groups[gid] = members
            new_names[gid] = name

        if all(len(v) == 0 for v in new_groups.values()):
            state.participant_groups.clear()
            state.group_names.clear()
        else:
            state.participant_groups.clear()
            state.participant_groups.update(new_groups)
            state.group_names.clear()
            state.group_names.update(new_names)

        self.accept()


class GroupTasksDialog(QDialog):
    """Dialog for grouping tasks with task labeling."""

    def __init__(self, parent: QWidget) -> None:
        super().__init__(parent)
        self.setWindowTitle("Group Tasks")
        self.setMinimumSize(980, 640)
        self.setModal(True)

        self.max_groups = 15

        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(8, 8, 8, 8)
        main_layout.setSpacing(6)

        # Task naming section
        naming_group = QGroupBox("Task labels")
        naming_layout = QHBoxLayout(naming_group)

        naming_layout.addWidget(QLabel("Task:"))
        self.task_combo = QComboBox()
        self.task_combo.addItems([state.format_task(t) for t in state.tasks_cache])
        self.task_combo.currentIndexChanged.connect(self._on_task_changed)
        naming_layout.addWidget(self.task_combo)

        naming_layout.addWidget(QLabel("Label:"))
        self.label_edit = QLineEdit()
        self.label_edit.returnPressed.connect(self._apply_label)
        self.label_edit.textChanged.connect(self._update_preview)
        naming_layout.addWidget(self.label_edit)

        self.preview_label = QLabel("Preview: ")
        naming_layout.addWidget(self.preview_label)

        naming_layout.addWidget(QLabel("Press Enter to apply."))
        naming_layout.addStretch()

        main_layout.addWidget(naming_group)

        # Scrollable groups area
        scroll = QScrollArea()
        scroll.setWidgetResizable(True)
        container = QWidget()
        self.container_layout = QVBoxLayout(container)
        self.container_layout.setContentsMargins(0, 0, 0, 0)
        self.container_layout.setSpacing(4)
        self.container_layout.setAlignment(Qt.AlignmentFlag.AlignTop)

        # Header
        header = QHBoxLayout()
        header.setContentsMargins(0, 0, 0, 0)
        header.setSpacing(8)
        header.addWidget(QLabel("Group name"), stretch=1, alignment=Qt.AlignmentFlag.AlignTop)
        header.addWidget(QLabel("Tasks"), stretch=2, alignment=Qt.AlignmentFlag.AlignTop)
        self.container_layout.addLayout(header)

        # Group rows
        self.group_name_edits: List[QLineEdit] = []
        self.group_items: List[List[str]] = []
        self.select_btns: List[QPushButton] = []
        self.row_widgets: List[QWidget] = []

        existing_ids = sorted(state.task_groups.keys())

        for i in range(self.max_groups):
            gid = existing_ids[i] if i < len(existing_ids) else f"T{i+1}"

            row_widget = QWidget()
            row_layout = QHBoxLayout(row_widget)
            row_layout.setContentsMargins(0, 2, 0, 2)
            row_layout.setSpacing(8)

            name_edit = QLineEdit(state.task_group_names.get(gid, f"Group {i+1}"))
            name_edit.setFixedWidth(200)
            row_layout.addWidget(name_edit)

            items = state.task_groups.get(gid, []).copy()

            btn = QPushButton("Select tasks...")
            btn.clicked.connect(lambda checked, idx=i: self._select_tasks(idx))
            row_layout.addWidget(btn, stretch=1)

            self.group_name_edits.append(name_edit)
            self.group_items.append(items)
            self.select_btns.append(btn)
            self.row_widgets.append(row_widget)

            self.container_layout.addWidget(row_widget)
            self._update_btn_text(i)

        scroll.setWidget(container)
        main_layout.addWidget(scroll)

        # Buttons
        btn_layout = QHBoxLayout()
        btn_layout.addStretch()

        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        save_btn = QPushButton("Save & Apply")
        save_btn.clicked.connect(self._save_apply)

        btn_layout.addWidget(save_btn)
        btn_layout.addWidget(cancel_btn)
        main_layout.addLayout(btn_layout)

        self._update_row_visibility()
        self._on_task_changed()

    def _on_task_changed(self) -> None:
        idx = self.task_combo.currentIndex()
        if idx < 0 or idx >= len(state.tasks_cache):
            return
        task_id = state.tasks_cache[idx]
        self.label_edit.setText(state.task_labels.get(task_id, ""))
        self._update_preview()

    def _update_preview(self) -> None:
        idx = self.task_combo.currentIndex()
        if idx < 0 or idx >= len(state.tasks_cache):
            return
        task_id = state.tasks_cache[idx]
        label = self.label_edit.text().strip()
        preview = f"{task_id} {label}".strip() if label else task_id
        self.preview_label.setText(f"Preview: {preview}")

    def _apply_label(self) -> None:
        idx = self.task_combo.currentIndex()
        if idx < 0 or idx >= len(state.tasks_cache):
            return
        task_id = state.tasks_cache[idx]
        label = self.label_edit.text().strip()

        if label:
            state.task_labels[task_id] = label
        else:
            state.task_labels.pop(task_id, None)

        # Refresh combobox
        current_idx = self.task_combo.currentIndex()
        self.task_combo.clear()
        self.task_combo.addItems([state.format_task(t) for t in state.tasks_cache])
        self.task_combo.setCurrentIndex(current_idx)

        # Refresh button texts
        for i in range(self.max_groups):
            self._update_btn_text(i)

        self._update_preview()

    def _already_selected_elsewhere(self, current_row: int) -> List[str]:
        s: Set[str] = set()
        for r, items in enumerate(self.group_items):
            if r != current_row:
                s.update(items)
        return sorted(s)

    def _update_btn_text(self, row_idx: int) -> None:
        sel = self.group_items[row_idx]
        if not sel:
            self.select_btns[row_idx].setText("Select tasks...")
        elif len(sel) <= 6:
            self.select_btns[row_idx].setText(", ".join(state.format_task(t) for t in sel))
        else:
            self.select_btns[row_idx].setText(f"{len(sel)} selected")

    def _update_row_visibility(self) -> None:
        for i in range(self.max_groups):
            if i == 0:
                self.row_widgets[i].show()
            elif self.group_items[i - 1]:
                self.row_widgets[i].show()
            else:
                self.row_widgets[i].hide()

    def _select_tasks(self, row_idx: int) -> None:
        dialog = MultiSelectDialog(
            self,
            title=f"Select tasks for {self.group_name_edits[row_idx].text() or f'Group {row_idx+1}'}",
            items=state.tasks_cache,
            selected=self.group_items[row_idx],
            gray_hint_items=self._already_selected_elsewhere(row_idx),
            display_func=state.format_task,
        )

        if dialog.exec() == QDialog.DialogCode.Accepted and dialog.result is not None:
            self.group_items[row_idx] = dialog.result
            self._update_btn_text(row_idx)
            self._update_row_visibility()

    def _save_apply(self) -> None:
        new_groups: dict = {}
        new_names: dict = {}

        for i in range(self.max_groups):
            gid = f"T{i+1}"
            name = self.group_name_edits[i].text().strip() or f"Group {i+1}"
            items = self.group_items[i]

            if not items and i > 0:
                continue

            new_groups[gid] = items
            new_names[gid] = name

        if all(len(v) == 0 for v in new_groups.values()):
            state.task_groups.clear()
            state.task_group_names.clear()
        else:
            state.task_groups.clear()
            state.task_groups.update(new_groups)
            state.task_group_names.clear()
            state.task_group_names.update(new_names)

        self.accept()
```

dialogs.py
```
"""
Dialog windows and custom widgets using PyQt6.
"""
from __future__ import annotations

from typing import Optional, List, Callable, Set

from PyQt6.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QWidget, QLabel, QPushButton,
    QListWidget, QListWidgetItem, QCheckBox, QLineEdit, QComboBox,
    QFrame, QScrollArea, QGroupBox, QGridLayout, QAbstractItemView,
    QMessageBox
)
from PyQt6.QtCore import Qt

from state import state


class MultiSelectDialog(QDialog):
    """
    Modal dialog for multi-selection:
    - Select all checkbox
    - Multi-select list
    - OK / Cancel
    """

    def __init__(
        self,
        parent: QWidget,
        title: str,
        items: List[str],
        selected: Optional[List[str]] = None,
        gray_hint_items: Optional[List[str]] = None,
        display_func: Optional[Callable[[str], str]] = None,
    ) -> None:
        super().__init__(parent)
        self.items = items
        self._selected_set = set(selected or [])
        self._gray_hint = set(gray_hint_items or [])
        self._display_func = display_func or (lambda x: x)
        self.result: Optional[List[str]] = None

        self.setWindowTitle(title)
        self.setMinimumSize(420, 460)
        self.setModal(True)

        layout = QVBoxLayout(self)

        # Select all checkbox
        self.select_all_cb = QCheckBox("Select all")
        self.select_all_cb.stateChanged.connect(self._toggle_select_all)
        layout.addWidget(self.select_all_cb)

        # List widget
        self.list_widget = QListWidget()
        self.list_widget.setSelectionMode(QAbstractItemView.SelectionMode.MultiSelection)

        for item in self.items:
            list_item = QListWidgetItem(self._display_func(item))
            list_item.setData(Qt.ItemDataRole.UserRole, item)
            if item in self._gray_hint:
                list_item.setForeground(Qt.GlobalColor.gray)
            if item in self._selected_set:
                list_item.setSelected(True)
            self.list_widget.addItem(list_item)

        layout.addWidget(self.list_widget)

        # Buttons
        btn_layout = QHBoxLayout()
        btn_layout.addStretch()

        ok_btn = QPushButton("OK")
        ok_btn.clicked.connect(self._on_ok)
        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self._on_cancel)

        btn_layout.addWidget(ok_btn)
        btn_layout.addWidget(cancel_btn)
        layout.addLayout(btn_layout)

    def _toggle_select_all(self, state: int) -> None:
        for i in range(self.list_widget.count()):
            self.list_widget.item(i).setSelected(state == Qt.CheckState.Checked.value)

    def _on_ok(self) -> None:
        self.result = [
            self.list_widget.item(i).data(Qt.ItemDataRole.UserRole)
            for i in range(self.list_widget.count())
            if self.list_widget.item(i).isSelected()
        ]
        self.accept()

    def _on_cancel(self) -> None:
        self.result = None
        self.reject()


class MultiSelectPicker(QWidget):
    """
    A button that opens a multi-select popup dialog.
    """

    def __init__(
        self,
        parent: QWidget,
        options: List[str],
        get_global_selected: Callable[[], Set[str]],
        on_change: Optional[Callable[[], None]] = None,
        placeholder: str = "Select items...",
        popup_title: str = "Select items",
        display_func: Optional[Callable[[str], str]] = None,
    ) -> None:
        super().__init__(parent)
        self._options = options
        self._get_global_selected = get_global_selected
        self._on_change = on_change
        self._placeholder = placeholder
        self._popup_title = popup_title
        self._display_func = display_func or (lambda x: x)

        self._selected: Set[str] = set()

        layout = QHBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)

        self._btn = QPushButton(placeholder)
        self._btn.clicked.connect(self._open_popup)
        layout.addWidget(self._btn)

        self._refresh_summary()

    def get_selected(self) -> List[str]:
        return [o for o in self._options if o in self._selected]

    def set_selected(self, selected: List[str]) -> None:
        self._selected = set(selected)
        self._refresh_summary()

    def refresh_ui(self) -> None:
        self._refresh_summary()

    def _refresh_summary(self) -> None:
        selected = self.get_selected()
        if not selected:
            self._btn.setText(self._placeholder)
        elif len(selected) <= 3:
            self._btn.setText(", ".join(self._display_func(s) for s in selected))
        else:
            self._btn.setText(f"{len(selected)} selected")

    def _open_popup(self) -> None:
        global_selected = self._get_global_selected()
        gray_hint = [o for o in self._options if o in global_selected and o not in self._selected]

        dialog = MultiSelectDialog(
            self,
            title=self._popup_title,
            items=self._options,
            selected=list(self._selected),
            gray_hint_items=gray_hint,
            display_func=self._display_func,
        )

        if dialog.exec() == QDialog.DialogCode.Accepted and dialog.result is not None:
            self._selected = set(dialog.result)
            self._refresh_summary()
            if self._on_change is not None:
                self._on_change()


class GroupParticipantsDialog(QDialog):
    """Dialog for grouping participants."""

    def __init__(self, parent: QWidget) -> None:
        super().__init__(parent)
        self.setWindowTitle("Group Participants")
        self.setMinimumSize(900, 600)
        self.setModal(True)

        self.max_groups = 15

        main_layout = QVBoxLayout(self)

        # Scrollable area
        scroll = QScrollArea()
        scroll.setWidgetResizable(True)
        container = QWidget()
        self.container_layout = QVBoxLayout(container)

        # Header
        header = QHBoxLayout()
        header.addWidget(QLabel("Group name"), stretch=1)
        header.addWidget(QLabel("Participants"), stretch=2)
        self.container_layout.addLayout(header)

        # Group rows
        self.group_name_edits: List[QLineEdit] = []
        self.group_members: List[List[str]] = []
        self.select_btns: List[QPushButton] = []
        self.row_widgets: List[QWidget] = []

        existing_ids = sorted(state.participant_groups.keys())

        for i in range(self.max_groups):
            gid = existing_ids[i] if i < len(existing_ids) else f"G{i+1}"

            row_widget = QWidget()
            row_layout = QHBoxLayout(row_widget)
            row_layout.setContentsMargins(0, 4, 0, 4)

            name_edit = QLineEdit(state.group_names.get(gid, f"Group {i+1}"))
            name_edit.setFixedWidth(200)
            row_layout.addWidget(name_edit)

            members = state.participant_groups.get(gid, []).copy()

            btn = QPushButton("Select participants...")
            btn.clicked.connect(lambda checked, idx=i: self._select_participants(idx))
            row_layout.addWidget(btn, stretch=1)

            self.group_name_edits.append(name_edit)
            self.group_members.append(members)
            self.select_btns.append(btn)
            self.row_widgets.append(row_widget)

            self.container_layout.addWidget(row_widget)
            self._update_btn_text(i)

        scroll.setWidget(container)
        main_layout.addWidget(scroll)

        # Buttons
        btn_layout = QHBoxLayout()
        btn_layout.addStretch()

        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        save_btn = QPushButton("Save & Apply")
        save_btn.clicked.connect(self._save_apply)

        btn_layout.addWidget(save_btn)
        btn_layout.addWidget(cancel_btn)
        main_layout.addLayout(btn_layout)

        self._update_row_visibility()

    def _already_selected_elsewhere(self, current_row: int) -> List[str]:
        s: Set[str] = set()
        for r, members in enumerate(self.group_members):
            if r != current_row:
                s.update(members)
        return sorted(s)

    def _update_btn_text(self, row_idx: int) -> None:
        sel = self.group_members[row_idx]
        if not sel:
            self.select_btns[row_idx].setText("Select participants...")
        elif len(sel) <= 4:
            self.select_btns[row_idx].setText(", ".join(sel))
        else:
            self.select_btns[row_idx].setText(f"{len(sel)} selected")

    def _update_row_visibility(self) -> None:
        for i in range(self.max_groups):
            if i == 0:
                self.row_widgets[i].show()
            elif self.group_members[i - 1]:
                self.row_widgets[i].show()
            else:
                self.row_widgets[i].hide()

    def _select_participants(self, row_idx: int) -> None:
        dialog = MultiSelectDialog(
            self,
            title=f"Select participants for {self.group_name_edits[row_idx].text() or f'Group {row_idx+1}'}",
            items=state.participants_cache,
            selected=self.group_members[row_idx],
            gray_hint_items=self._already_selected_elsewhere(row_idx),
        )

        if dialog.exec() == QDialog.DialogCode.Accepted and dialog.result is not None:
            self.group_members[row_idx] = dialog.result
            self._update_btn_text(row_idx)
            self._update_row_visibility()

    def _save_apply(self) -> None:
        new_groups: dict = {}
        new_names: dict = {}

        for i in range(self.max_groups):
            gid = f"G{i+1}"
            name = self.group_name_edits[i].text().strip() or f"Group {i+1}"
            members = self.group_members[i]

            if not members and i > 0:
                continue

            new_groups[gid] = members
            new_names[gid] = name

        if all(len(v) == 0 for v in new_groups.values()):
            state.participant_groups.clear()
            state.group_names.clear()
        else:
            state.participant_groups.clear()
            state.participant_groups.update(new_groups)
            state.group_names.clear()
            state.group_names.update(new_names)

        self.accept()


class GroupTasksDialog(QDialog):
    """Dialog for grouping tasks with task labeling."""

    def __init__(self, parent: QWidget) -> None:
        super().__init__(parent)
        self.setWindowTitle("Group Tasks")
        self.setMinimumSize(980, 640)
        self.setModal(True)

        self.max_groups = 15

        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(8, 8, 8, 8)
        main_layout.setSpacing(6)

        # Task naming section
        naming_group = QGroupBox("Task labels")
        naming_layout = QHBoxLayout(naming_group)

        naming_layout.addWidget(QLabel("Task:"))
        self.task_combo = QComboBox()
        self.task_combo.addItems([state.format_task(t) for t in state.tasks_cache])
        self.task_combo.currentIndexChanged.connect(self._on_task_changed)
        naming_layout.addWidget(self.task_combo)

        naming_layout.addWidget(QLabel("Label:"))
        self.label_edit = QLineEdit()
        self.label_edit.returnPressed.connect(self._apply_label)
        self.label_edit.textChanged.connect(self._update_preview)
        naming_layout.addWidget(self.label_edit)

        self.preview_label = QLabel("Preview: ")
        naming_layout.addWidget(self.preview_label)

        naming_layout.addWidget(QLabel("Press Enter to apply."))
        naming_layout.addStretch()

        main_layout.addWidget(naming_group)

        # Scrollable groups area
        scroll = QScrollArea()
        scroll.setWidgetResizable(True)
        container = QWidget()
        self.container_layout = QVBoxLayout(container)
        self.container_layout.setContentsMargins(0, 0, 0, 0)
        self.container_layout.setSpacing(4)
        self.container_layout.setAlignment(Qt.AlignmentFlag.AlignTop)

        # Header
        header = QHBoxLayout()
        header.setContentsMargins(0, 0, 0, 0)
        header.setSpacing(8)
        header.addWidget(QLabel("Group name"), stretch=1, alignment=Qt.AlignmentFlag.AlignTop)
        header.addWidget(QLabel("Tasks"), stretch=2, alignment=Qt.AlignmentFlag.AlignTop)
        self.container_layout.addLayout(header)

        # Group rows
        self.group_name_edits: List[QLineEdit] = []
        self.group_items: List[List[str]] = []
        self.select_btns: List[QPushButton] = []
        self.row_widgets: List[QWidget] = []

        existing_ids = sorted(state.task_groups.keys())

        for i in range(self.max_groups):
            gid = existing_ids[i] if i < len(existing_ids) else f"T{i+1}"

            row_widget = QWidget()
            row_layout = QHBoxLayout(row_widget)
            row_layout.setContentsMargins(0, 2, 0, 2)
            row_layout.setSpacing(8)

            name_edit = QLineEdit(state.task_group_names.get(gid, f"Group {i+1}"))
            name_edit.setFixedWidth(200)
            row_layout.addWidget(name_edit)

            items = state.task_groups.get(gid, []).copy()

            btn = QPushButton("Select tasks...")
            btn.clicked.connect(lambda checked, idx=i: self._select_tasks(idx))
            row_layout.addWidget(btn, stretch=1)

            self.group_name_edits.append(name_edit)
            self.group_items.append(items)
            self.select_btns.append(btn)
            self.row_widgets.append(row_widget)

            self.container_layout.addWidget(row_widget)
            self._update_btn_text(i)

        scroll.setWidget(container)
        main_layout.addWidget(scroll)

        # Buttons
        btn_layout = QHBoxLayout()
        btn_layout.addStretch()

        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        save_btn = QPushButton("Save & Apply")
        save_btn.clicked.connect(self._save_apply)

        btn_layout.addWidget(save_btn)
        btn_layout.addWidget(cancel_btn)
        main_layout.addLayout(btn_layout)

        self._update_row_visibility()
        self._on_task_changed()

    def _on_task_changed(self) -> None:
        idx = self.task_combo.currentIndex()
        if idx < 0 or idx >= len(state.tasks_cache):
            return
        task_id = state.tasks_cache[idx]
        self.label_edit.setText(state.task_labels.get(task_id, ""))
        self._update_preview()

    def _update_preview(self) -> None:
        idx = self.task_combo.currentIndex()
        if idx < 0 or idx >= len(state.tasks_cache):
            return
        task_id = state.tasks_cache[idx]
        label = self.label_edit.text().strip()
        preview = f"{task_id} {label}".strip() if label else task_id
        self.preview_label.setText(f"Preview: {preview}")

    def _apply_label(self) -> None:
        idx = self.task_combo.currentIndex()
        if idx < 0 or idx >= len(state.tasks_cache):
            return
        task_id = state.tasks_cache[idx]
        label = self.label_edit.text().strip()

        if label:
            state.task_labels[task_id] = label
        else:
            state.task_labels.pop(task_id, None)

        # Refresh combobox
        current_idx = self.task_combo.currentIndex()
        self.task_combo.clear()
        self.task_combo.addItems([state.format_task(t) for t in state.tasks_cache])
        self.task_combo.setCurrentIndex(current_idx)

        # Refresh button texts
        for i in range(self.max_groups):
            self._update_btn_text(i)

        self._update_preview()

    def _already_selected_elsewhere(self, current_row: int) -> List[str]:
        s: Set[str] = set()
        for r, items in enumerate(self.group_items):
            if r != current_row:
                s.update(items)
        return sorted(s)

    def _update_btn_text(self, row_idx: int) -> None:
        sel = self.group_items[row_idx]
        if not sel:
            self.select_btns[row_idx].setText("Select tasks...")
        elif len(sel) <= 6:
            self.select_btns[row_idx].setText(", ".join(state.format_task(t) for t in sel))
        else:
            self.select_btns[row_idx].setText(f"{len(sel)} selected")

    def _update_row_visibility(self) -> None:
        for i in range(self.max_groups):
            if i == 0:
                self.row_widgets[i].show()
            elif self.group_items[i - 1]:
                self.row_widgets[i].show()
            else:
                self.row_widgets[i].hide()

    def _select_tasks(self, row_idx: int) -> None:
        dialog = MultiSelectDialog(
            self,
            title=f"Select tasks for {self.group_name_edits[row_idx].text() or f'Group {row_idx+1}'}",
            items=state.tasks_cache,
            selected=self.group_items[row_idx],
            gray_hint_items=self._already_selected_elsewhere(row_idx),
            display_func=state.format_task,
        )

        if dialog.exec() == QDialog.DialogCode.Accepted and dialog.result is not None:
            self.group_items[row_idx] = dialog.result
            self._update_btn_text(row_idx)
            self._update_row_visibility()

    def _save_apply(self) -> None:
        new_groups: dict = {}
        new_names: dict = {}

        for i in range(self.max_groups):
            gid = f"T{i+1}"
            name = self.group_name_edits[i].text().strip() or f"Group {i+1}"
            items = self.group_items[i]

            if not items and i > 0:
                continue

            new_groups[gid] = items
            new_names[gid] = name

        if all(len(v) == 0 for v in new_groups.values()):
            state.task_groups.clear()
            state.task_group_names.clear()
        else:
            state.task_groups.clear()
            state.task_groups.update(new_groups)
            state.task_group_names.clear()
            state.task_group_names.update(new_names)

        self.accept()
```

> Tokens: 9.7k sent, 7.6k received. Cost: $0.12 message, $0.20 session.  
> Applied edit to dialogs.py  
> Applied edit to eye_tracking_tool\dialogs.py  
> Commit 5b55e5e style: Kompaktiere GroupTasksDialog-Layout und richte Header oben aus  
> You can use /undo to undo and discard each aider commit.  

#### /add  

#### /add __pycache__\dialogs.cpython-313.pyc  
> D:\Documents\01_MCI\WS2025\Studentproject\Software\aider\__pycache__\dialogs.cpython-313.pyc: 'utf-8' codec can't decode byte 0xf3 in position 0: invalid continuation byte  
> Use --encoding to set the unicode encoding.  
> Unable to read D:\Documents\01_MCI\WS2025\Studentproject\Software\aider\__pycache__\dialogs.cpython-313.pyc  

#### after pressing the button group tasks you get to the pop up window group tasks. Here the drop/down window in the box task labels work. but has problems displaying the tasks inside of the drop/down menu. Also, i want u to eliminate the functionalitie to group the tasks.  

### Ziel der Änderung
1) **Dropdown (Task labels) zeigt Tasks „komisch“/falsch an** → Ursache ist sehr wahrscheinlich, dass `state.format_task(...)` **HTML** (z.B. `<b>…</b>`) oder Sonderzeichen liefert und `QComboBox`/Popup das dann als RichText interpretiert bzw. abgeschnitten wirkt. Wir erzwingen **Plain-Text** im ComboBox-View/Delegate.

2) **Funktionalität „Tasks gruppieren“ komplett entfernen** → Im „Group Tasks“-Dialog soll nur noch **Task-Labeling** existieren. Der komplette Scrollbereich mit Gruppen + „Save & Apply“ wird entfernt. Damit gibt es auch keine `state.task_groups`/`state.task_group_names` Änderungen mehr aus diesem Dialog.

Die Änderungen müssen in **beiden** Dateien erfolgen:
- `dialogs.py`
- `eye_tracking_tool/dialogs.py`

---

## A) Fix: Tasks im Dropdown korrekt anzeigen (Plain Text erzwingen)

### 1) Imports ergänzen
In beiden Dateien oben bei den Imports ergänzen:

- In `from PyQt6.QtWidgets import (...)` **hinzufügen**:
  - `QStyledItemDelegate`

- Zusätzlich **neu importieren**:
```py
from PyQt6.QtGui import QTextDocument
```

### 2) Plain-Text Delegate hinzufügen (neu)
Füge in beiden Dateien **oberhalb** von `class GroupTasksDialog` (oder irgendwo passend auf Modulebene) diese neue Klasse ein:

```py
class PlainTextDelegate(QStyledItemDelegate):
    """Forces plain-text rendering in item views (prevents HTML/RichText issues)."""

    def initStyleOption(self, option, index):  # type: ignore[override]
        super().initStyleOption(option, index)
        # Convert any rich text to plain text to avoid broken rendering in QComboBox popup
        doc = QTextDocument()
        doc.setHtml(option.text)
        option.text = doc.toPlainText()
```

### 3) Delegate am Task-Combo setzen
In `GroupTasksDialog.__init__`, **direkt nach**:
```py
self.task_combo = QComboBox()
```
füge hinzu:

```py
self.task_combo.setItemDelegate(PlainTextDelegate(self.task_combo))
```

Damit wird die Anzeige im Dropdown-Popup stabil, selbst wenn `state.format_task()` HTML liefert.

---

## B) „Group Tasks“ Dialog: Task-Gruppierung entfernen (nur Labeling behalten)

### 1) Scrollbereich + Gruppen-Header + Gruppen-Row-Logik entfernen
In `GroupTasksDialog.__init__` entfernst du den kompletten Block **ab** Kommentar:
```py
# Scrollable groups area
```
bis **einschließlich**:
```py
main_layout.addWidget(scroll)
```

Das umfasst:
- `scroll = QScrollArea()` … `main_layout.addWidget(scroll)`
- `self.container_layout...`
- Header-Layout
- alle Listen: `self.group_name_edits`, `self.group_items`, `self.select_btns`, `self.row_widgets`
- die `for i in range(self.max_groups): ...` Schleife
- `_update_btn_text(i)` Aufrufe

### 2) Button-Leiste unten anpassen (Save & Apply entfernen)
Im unteren „Buttons“-Block in `__init__`:

Aktuell:
```py
cancel_btn = QPushButton("Cancel")
cancel_btn.clicked.connect(self.reject)
save_btn = QPushButton("Save & Apply")
save_btn.clicked.connect(self._save_apply)

btn_layout.addWidget(save_btn)
btn_layout.addWidget(cancel_btn)
main_layout.addLayout(btn_layout)
```

Ändere zu **nur einem Close/OK Button** (unmissverständlich):

```py
close_btn = QPushButton("Close")
close_btn.clicked.connect(self.accept)

btn_layout.addWidget(close_btn)
main_layout.addLayout(btn_layout)
```

(Und entferne `cancel_btn`/`save_btn` komplett.)

### 3) Aufrufe am Ende von `__init__` bereinigen
Am Ende von `__init__` stehen aktuell:
```py
self._update_row_visibility()
self._on_task_changed()
```

Da es keine Rows mehr gibt: **lösche** die Zeile
```py
self._update_row_visibility()
```
und lasse nur:
```py
self._on_task_changed()
```

### 4) Nicht mehr benötigte Methoden entfernen
In `GroupTasksDialog` entferne komplett diese Methoden, weil sie nur für Gruppierung gebraucht werden und sonst tote/fehlerhafte Referenzen bleiben:

- `_already_selected_elsewhere`
- `_update_btn_text`
- `_update_row_visibility`
- `_select_tasks`
- `_save_apply`

Wichtig: Nach dem Entfernen darf es **keine** Referenzen mehr auf:
- `self.group_items`, `self.group_name_edits`, `self.select_btns`, `self.row_widgets`
- `state.task_groups`, `state.task_group_names`
geben.

### 5) `_apply_label` vereinfachen (Button-Refresh entfernen)
In `_apply_label` gibt es aktuell:

```py
# Refresh button texts
for i in range(self.max_groups):
    self._update_btn_text(i)
```

Da es keine Gruppenbuttons mehr gibt: **diesen Block löschen**.

Alles andere in `_apply_label` (Labels speichern, ComboBox refresh, Preview) bleibt.

---

## C) Optional: Dialogtitel/Copy anpassen (damit es nicht mehr „Group Tasks“ heißt)
Wenn du willst, dass es nicht mehr nach Gruppierung klingt:

- `self.setWindowTitle("Group Tasks")` ändern zu:
  - `"Task Labels"` oder `"Label Tasks"`

- `naming_group = QGroupBox("Task labels")` kann bleiben.

Das ist optional, aber UX-mäßig sinnvoll.

---

## D) Was ich ggf. noch sehen muss
Wenn nach dem Delegate-Fix die Dropdown-Anzeige immer noch kaputt ist, liegt es nicht an RichText, sondern an `state.format_task()` selbst (z.B. extrem lange Strings, Newlines, Tabs). Dann brauche ich den Inhalt von `state.format_task` aus `state.py`.

> Tokens: 13k sent, 1.4k received. Cost: $0.04 message, $0.24 session.  
> state.py  
> Add file to the chat? (Y)es/(N)o/(D)on't ask again [Yes]: y  

`state.py` reicht; weitere Dateien brauche ich dafür nicht.

Unten sind die **konkreten Code-Änderungen** (nur Deltas) in **beiden** Dateien:
- `dialogs.py`
- `eye_tracking_tool/dialogs.py`

---

## 1) Dropdown-Anzeige fixen (Plain-Text erzwingen)

### 1.1 Imports ergänzen
**Ändere** in beiden Dateien den QtWidgets-Import und füge QtGui hinzu.

**In** `from PyQt6.QtWidgets import (...)` **ergänzen**:
```py
QStyledItemDelegate,
```

**Neu hinzufügen** (unter den bestehenden Imports):
```py
from PyQt6.QtGui import QTextDocument
```

### 1.2 PlainTextDelegate hinzufügen
**Neu einfügen** (z.B. direkt oberhalb von `class GroupTasksDialog`):

```py
class PlainTextDelegate(QStyledItemDelegate):
    """Forces plain-text rendering in item views (prevents HTML/RichText issues)."""

    def initStyleOption(self, option, index):  # type: ignore[override]
        super().initStyleOption(option, index)
        doc = QTextDocument()
        doc.setHtml(option.text)
        option.text = doc.toPlainText()
```

### 1.3 Delegate am ComboBox setzen
In `GroupTasksDialog.__init__` **direkt nach**:
```py
self.task_combo = QComboBox()
```
**einfügen**:
```py
self.task_combo.setItemDelegate(PlainTextDelegate(self.task_combo))
```

---

## 2) Task-Gruppierung komplett entfernen (Dialog nur noch für Labels)

### 2.1 Scroll-/Gruppenbereich entfernen
In `GroupTasksDialog.__init__` **lösche komplett** den Block:

- **ab** der Zeile:
```py
# Scrollable groups area
```
- **bis einschließlich**:
```py
main_layout.addWidget(scroll)
```

Damit entfernst du:
- `QScrollArea`, `container`, `self.container_layout`
- Header „Group name / Tasks“
- alle Group-Row-Listen (`self.group_name_edits`, `self.group_items`, `self.select_btns`, `self.row_widgets`)
- die `for i in range(self.max_groups): ...` Schleife

### 2.2 Button-Leiste unten: Save & Apply entfernen
Ersetze im Buttons-Block in `__init__`:

**Alt:**
```py
cancel_btn = QPushButton("Cancel")
cancel_btn.clicked.connect(self.reject)
save_btn = QPushButton("Save & Apply")
save_btn.clicked.connect(self._save_apply)

btn_layout.addWidget(save_btn)
btn_layout.addWidget(cancel_btn)
main_layout.addLayout(btn_layout)
```

**Neu:**
```py
close_btn = QPushButton("Close")
close_btn.clicked.connect(self.accept)

btn_layout.addWidget(close_btn)
main_layout.addLayout(btn_layout)
```

### 2.3 Aufrufe am Ende von `__init__` bereinigen
Am Ende von `__init__`:

**Entfernen:**
```py
self._update_row_visibility()
```

**Beibehalten:**
```py
self._on_task_changed()
```

### 2.4 Gruppierungs-Methoden entfernen
In `class GroupTasksDialog` **komplett löschen** (ganze Methoden):

- `_already_selected_elsewhere`
- `_update_btn_text`
- `_update_row_visibility`
- `_select_tasks`
- `_save_apply`

Wichtig: Danach darf es keine Referenzen mehr auf `state.task_groups` / `state.task_group_names` aus diesem Dialog geben.

### 2.5 `_apply_label`: Button-Refresh entfernen
In `_apply_label` **lösche** diesen Block:

```py
# Refresh button texts
for i in range(self.max_groups):
    self._update_btn_text(i)
```

Alles andere in `_apply_label` bleibt.

---

## 3) (Optional, aber empfohlen) Dialogtitel anpassen
Damit es nicht mehr „Group Tasks“ heißt:

In `GroupTasksDialog.__init__` ändern:
```py
self.setWindowTitle("Group Tasks")
```
zu z.B.:
```py
self.setWindowTitle("Task Labels")
```

---

### Hinweis zu `state.format_task`
Dein `format_task` liefert **kein HTML**, nur Plain-Text. Trotzdem kann Qt je nach Style/Delegate bei bestimmten Zeichenfolgen „komisch“ rendern; der Delegate-Fix macht die Anzeige robust. Wenn es danach immer noch schlecht aussieht, sag mir bitte:
- Beispiel eines Task-IDs aus `state.tasks_cache` (1–2 Stück)
- wie genau „Probleme displaying“ aussieht (abgeschnitten? leer? falsche Reihenfolge? Zeilenumbrüche?)

> Tokens: 14k sent, 1.1k received. Cost: $0.04 message, $0.28 session.  

#### `state.py` reicht; weitere Dateien brauche ich dafür nicht.  
####   
#### Unten sind die **konkreten Code-Änderungen** (nur Deltas) in **beiden** Dateien:  
#### - `dialogs.py`  
#### - `eye_tracking_tool/dialogs.py`  
####   
#### ---  
####   
#### ## 1) Dropdown-Anzeige fixen (Plain-Text erzwingen)  
####   
#### ### 1.1 Imports ergänzen  
#### **Ändere** in beiden Dateien den QtWidgets-Import und füge QtGui hinzu.  
####   
#### **In** `from PyQt6.QtWidgets import (...)` **ergänzen**:  
#### ```py  
#### QStyledItemDelegate,  
#### ```  
####   
#### **Neu hinzufügen** (unter den bestehenden Imports):  
#### ```py  
#### from PyQt6.QtGui import QTextDocument  
#### ```  
####   
#### ### 1.2 PlainTextDelegate hinzufügen  
#### **Neu einfügen** (z.B. direkt oberhalb von `class GroupTasksDialog`):  
####   
#### ```py  
#### class PlainTextDelegate(QStyledItemDelegate):  
####     """Forces plain-text rendering in item views (prevents HTML/RichText issues)."""  
####   
####     def initStyleOption(self, option, index):  # type: ignore[override]  
####         super().initStyleOption(option, index)  
####         doc = QTextDocument()  
####         doc.setHtml(option.text)  
####         option.text = doc.toPlainText()  
#### ```  
####   
#### ### 1.3 Delegate am ComboBox setzen  
#### In `GroupTasksDialog.__init__` **direkt nach**:  
#### ```py  
#### self.task_combo = QComboBox()  
#### ```  
#### **einfügen**:  
#### ```py  
#### self.task_combo.setItemDelegate(PlainTextDelegate(self.task_combo))  
#### ```  
####   
#### ---  
####   
#### ## 2) Task-Gruppierung komplett entfernen (Dialog nur noch für Labels)  
####   
#### ### 2.1 Scroll-/Gruppenbereich entfernen  
#### In `GroupTasksDialog.__init__` **lösche komplett** den Block:  
####   
#### - **ab** der Zeile:  
#### ```py  
#### # Scrollable groups area  
#### ```  
#### - **bis einschließlich**:  
#### ```py  
#### main_layout.addWidget(scroll)  
#### ```  
####   
#### Damit entfernst du:  
#### - `QScrollArea`, `container`, `self.container_layout`  
#### - Header „Group name / Tasks“  
#### - alle Group-Row-Listen (`self.group_name_edits`, `self.group_items`, `self.select_btns`, `self.row_widgets`)  
#### - die `for i in range(self.max_groups): ...` Schleife  
####   
#### ### 2.2 Button-Leiste unten: Save & Apply entfernen  
#### Ersetze im Buttons-Block in `__init__`:  
####   
#### **Alt:**  
#### ```py  
#### cancel_btn = QPushButton("Cancel")  
#### cancel_btn.clicked.connect(self.reject)  
#### save_btn = QPushButton("Save & Apply")  
#### save_btn.clicked.connect(self._save_apply)  
####   
#### btn_layout.addWidget(save_btn)  
#### btn_layout.addWidget(cancel_btn)  
#### main_layout.addLayout(btn_layout)  
#### ```  
####   
#### **Neu:**  
#### ```py  
#### close_btn = QPushButton("Close")  
#### close_btn.clicked.connect(self.accept)  
####   
#### btn_layout.addWidget(close_btn)  
#### main_layout.addLayout(btn_layout)  
#### ```  
####   
#### ### 2.3 Aufrufe am Ende von `__init__` bereinigen  
#### Am Ende von `__init__`:  
####   
#### **Entfernen:**  
#### ```py  
#### self._update_row_visibility()  
#### ```  
####   
#### **Beibehalten:**  
#### ```py  
#### self._on_task_changed()  
#### ```  
####   
#### ### 2.4 Gruppierungs-Methoden entfernen  
#### In `class GroupTasksDialog` **komplett löschen** (ganze Methoden):  
####   
#### - `_already_selected_elsewhere`  
#### - `_update_btn_text`  
#### - `_update_row_visibility`  
#### - `_select_tasks`  
#### - `_save_apply`  
####   
#### Wichtig: Danach darf es keine Referenzen mehr auf `state.task_groups` / `state.task_group_names` aus diesem Dialog geben.  
####   
#### ### 2.5 `_apply_label`: Button-Refresh entfernen  
#### In `_apply_label` **lösche** diesen Block:  
####   
#### ```py  
#### # Refresh button texts  
#### for i in range(self.max_groups):  
####     self._update_btn_text(i)  
#### ```  
####   
#### Alles andere in `_apply_label` bleibt.  
####   
#### ---  
####   
#### ## 3) (Optional, aber empfohlen) Dialogtitel anpassen  
#### Damit es nicht mehr „Group Tasks“ heißt:  
####   
#### In `GroupTasksDialog.__init__` ändern:  
#### ```py  
#### self.setWindowTitle("Group Tasks")  
#### ```  
#### zu z.B.:  
#### ```py  
#### self.setWindowTitle("Task Labels")  
#### ```  
####   
#### ---  
####   
#### ### Hinweis zu `state.format_task`  
#### Dein `format_task` liefert **kein HTML**, nur Plain-Text. Trotzdem kann Qt je nach Style/Delegate bei bestimmten Zeichenfolgen „komisch“ rendern; der Delegate-Fix macht die Anzeige robust. Wenn es danach immer noch schlecht aussieht, sag mir bitte:  
#### - Beispiel eines Task-IDs aus `state.tasks_cache` (1–2 Stück)  
#### - wie genau „Probleme displaying“ aussieht (abgeschnitten? leer? falsche Reihenfolge? Zeilenumbrüche?)  

dialogs.py
```
"""
Dialog windows and custom widgets using PyQt6.
"""
from __future__ import annotations

from typing import Optional, List, Callable, Set

from PyQt6.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QWidget, QLabel, QPushButton,
    QListWidget, QListWidgetItem, QCheckBox, QLineEdit, QComboBox,
    QFrame, QScrollArea, QGroupBox, QGridLayout, QAbstractItemView,
    QMessageBox, QStyledItemDelegate
)
from PyQt6.QtCore import Qt
from PyQt6.QtGui import QTextDocument

from state import state


class MultiSelectDialog(QDialog):
    """
    Modal dialog for multi-selection:
    - Select all checkbox
    - Multi-select list
    - OK / Cancel
    """

    def __init__(
        self,
        parent: QWidget,
        title: str,
        items: List[str],
        selected: Optional[List[str]] = None,
        gray_hint_items: Optional[List[str]] = None,
        display_func: Optional[Callable[[str], str]] = None,
    ) -> None:
        super().__init__(parent)
        self.items = items
        self._selected_set = set(selected or [])
        self._gray_hint = set(gray_hint_items or [])
        self._display_func = display_func or (lambda x: x)
        self.result: Optional[List[str]] = None

        self.setWindowTitle(title)
        self.setMinimumSize(420, 460)
        self.setModal(True)

        layout = QVBoxLayout(self)

        # Select all checkbox
        self.select_all_cb = QCheckBox("Select all")
        self.select_all_cb.stateChanged.connect(self._toggle_select_all)
        layout.addWidget(self.select_all_cb)

        # List widget
        self.list_widget = QListWidget()
        self.list_widget.setSelectionMode(QAbstractItemView.SelectionMode.MultiSelection)

        for item in self.items:
            list_item = QListWidgetItem(self._display_func(item))
            list_item.setData(Qt.ItemDataRole.UserRole, item)
            if item in self._gray_hint:
                list_item.setForeground(Qt.GlobalColor.gray)
            if item in self._selected_set:
                list_item.setSelected(True)
            self.list_widget.addItem(list_item)

        layout.addWidget(self.list_widget)

        # Buttons
        btn_layout = QHBoxLayout()
        btn_layout.addStretch()

        ok_btn = QPushButton("OK")
        ok_btn.clicked.connect(self._on_ok)
        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self._on_cancel)

        btn_layout.addWidget(ok_btn)
        btn_layout.addWidget(cancel_btn)
        layout.addLayout(btn_layout)

    def _toggle_select_all(self, state: int) -> None:
        for i in range(self.list_widget.count()):
            self.list_widget.item(i).setSelected(state == Qt.CheckState.Checked.value)

    def _on_ok(self) -> None:
        self.result = [
            self.list_widget.item(i).data(Qt.ItemDataRole.UserRole)
            for i in range(self.list_widget.count())
            if self.list_widget.item(i).isSelected()
        ]
        self.accept()

    def _on_cancel(self) -> None:
        self.result = None
        self.reject()


class MultiSelectPicker(QWidget):
    """
    A button that opens a multi-select popup dialog.
    """

    def __init__(
        self,
        parent: QWidget,
        options: List[str],
        get_global_selected: Callable[[], Set[str]],
        on_change: Optional[Callable[[], None]] = None,
        placeholder: str = "Select items...",
        popup_title: str = "Select items",
        display_func: Optional[Callable[[str], str]] = None,
    ) -> None:
        super().__init__(parent)
        self._options = options
        self._get_global_selected = get_global_selected
        self._on_change = on_change
        self._placeholder = placeholder
        self._popup_title = popup_title
        self._display_func = display_func or (lambda x: x)

        self._selected: Set[str] = set()

        layout = QHBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)

        self._btn = QPushButton(placeholder)
        self._btn.clicked.connect(self._open_popup)
        layout.addWidget(self._btn)

        self._refresh_summary()

    def get_selected(self) -> List[str]:
        return [o for o in self._options if o in self._selected]

    def set_selected(self, selected: List[str]) -> None:
        self._selected = set(selected)
        self._refresh_summary()

    def refresh_ui(self) -> None:
        self._refresh_summary()

    def _refresh_summary(self) -> None:
        selected = self.get_selected()
        if not selected:
            self._btn.setText(self._placeholder)
        elif len(selected) <= 3:
            self._btn.setText(", ".join(self._display_func(s) for s in selected))
        else:
            self._btn.setText(f"{len(selected)} selected")

    def _open_popup(self) -> None:
        global_selected = self._get_global_selected()
        gray_hint = [o for o in self._options if o in global_selected and o not in self._selected]

        dialog = MultiSelectDialog(
            self,
            title=self._popup_title,
            items=self._options,
            selected=list(self._selected),
            gray_hint_items=gray_hint,
            display_func=self._display_func,
        )

        if dialog.exec() == QDialog.DialogCode.Accepted and dialog.result is not None:
            self._selected = set(dialog.result)
            self._refresh_summary()
            if self._on_change is not None:
                self._on_change()


class GroupParticipantsDialog(QDialog):
    """Dialog for grouping participants."""

    def __init__(self, parent: QWidget) -> None:
        super().__init__(parent)
        self.setWindowTitle("Group Participants")
        self.setMinimumSize(900, 600)
        self.setModal(True)

        self.max_groups = 15

        main_layout = QVBoxLayout(self)

        # Scrollable area
        scroll = QScrollArea()
        scroll.setWidgetResizable(True)
        container = QWidget()
        self.container_layout = QVBoxLayout(container)

        # Header
        header = QHBoxLayout()
        header.addWidget(QLabel("Group name"), stretch=1)
        header.addWidget(QLabel("Participants"), stretch=2)
        self.container_layout.addLayout(header)

        # Group rows
        self.group_name_edits: List[QLineEdit] = []
        self.group_members: List[List[str]] = []
        self.select_btns: List[QPushButton] = []
        self.row_widgets: List[QWidget] = []

        existing_ids = sorted(state.participant_groups.keys())

        for i in range(self.max_groups):
            gid = existing_ids[i] if i < len(existing_ids) else f"G{i+1}"

            row_widget = QWidget()
            row_layout = QHBoxLayout(row_widget)
            row_layout.setContentsMargins(0, 4, 0, 4)

            name_edit = QLineEdit(state.group_names.get(gid, f"Group {i+1}"))
            name_edit.setFixedWidth(200)
            row_layout.addWidget(name_edit)

            members = state.participant_groups.get(gid, []).copy()

            btn = QPushButton("Select participants...")
            btn.clicked.connect(lambda checked, idx=i: self._select_participants(idx))
            row_layout.addWidget(btn, stretch=1)

            self.group_name_edits.append(name_edit)
            self.group_members.append(members)
            self.select_btns.append(btn)
            self.row_widgets.append(row_widget)

            self.container_layout.addWidget(row_widget)
            self._update_btn_text(i)

        scroll.setWidget(container)
        main_layout.addWidget(scroll)

        # Buttons
        btn_layout = QHBoxLayout()
        btn_layout.addStretch()

        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        save_btn = QPushButton("Save & Apply")
        save_btn.clicked.connect(self._save_apply)

        btn_layout.addWidget(save_btn)
        btn_layout.addWidget(cancel_btn)
        main_layout.addLayout(btn_layout)

        self._update_row_visibility()

    def _already_selected_elsewhere(self, current_row: int) -> List[str]:
        s: Set[str] = set()
        for r, members in enumerate(self.group_members):
            if r != current_row:
                s.update(members)
        return sorted(s)

    def _update_btn_text(self, row_idx: int) -> None:
        sel = self.group_members[row_idx]
        if not sel:
            self.select_btns[row_idx].setText("Select participants...")
        elif len(sel) <= 4:
            self.select_btns[row_idx].setText(", ".join(sel))
        else:
            self.select_btns[row_idx].setText(f"{len(sel)} selected")

    def _update_row_visibility(self) -> None:
        for i in range(self.max_groups):
            if i == 0:
                self.row_widgets[i].show()
            elif self.group_members[i - 1]:
                self.row_widgets[i].show()
            else:
                self.row_widgets[i].hide()

    def _select_participants(self, row_idx: int) -> None:
        dialog = MultiSelectDialog(
            self,
            title=f"Select participants for {self.group_name_edits[row_idx].text() or f'Group {row_idx+1}'}",
            items=state.participants_cache,
            selected=self.group_members[row_idx],
            gray_hint_items=self._already_selected_elsewhere(row_idx),
        )

        if dialog.exec() == QDialog.DialogCode.Accepted and dialog.result is not None:
            self.group_members[row_idx] = dialog.result
            self._update_btn_text(row_idx)
            self._update_row_visibility()

    def _save_apply(self) -> None:
        new_groups: dict = {}
        new_names: dict = {}

        for i in range(self.max_groups):
            gid = f"G{i+1}"
            name = self.group_name_edits[i].text().strip() or f"Group {i+1}"
            members = self.group_members[i]

            if not members and i > 0:
                continue

            new_groups[gid] = members
            new_names[gid] = name

        if all(len(v) == 0 for v in new_groups.values()):
            state.participant_groups.clear()
            state.group_names.clear()
        else:
            state.participant_groups.clear()
            state.participant_groups.update(new_groups)
            state.group_names.clear()
            state.group_names.update(new_names)

        self.accept()


class PlainTextDelegate(QStyledItemDelegate):
    """Forces plain-text rendering in item views (prevents HTML/RichText issues)."""

    def initStyleOption(self, option, index):  # type: ignore[override]
        super().initStyleOption(option, index)
        doc = QTextDocument()
        doc.setHtml(option.text)
        option.text = doc.toPlainText()


class GroupTasksDialog(QDialog):
    """Dialog for grouping tasks with task labeling."""

    def __init__(self, parent: QWidget) -> None:
        super().__init__(parent)
        self.setWindowTitle("Task Labels")
        self.setMinimumSize(980, 640)
        self.setModal(True)

        self.max_groups = 15

        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(8, 8, 8, 8)
        main_layout.setSpacing(6)

        # Task naming section
        naming_group = QGroupBox("Task labels")
        naming_layout = QHBoxLayout(naming_group)

        naming_layout.addWidget(QLabel("Task:"))
        self.task_combo = QComboBox()
        self.task_combo.setItemDelegate(PlainTextDelegate(self.task_combo))
        self.task_combo.addItems([state.format_task(t) for t in state.tasks_cache])
        self.task_combo.currentIndexChanged.connect(self._on_task_changed)
        naming_layout.addWidget(self.task_combo)

        naming_layout.addWidget(QLabel("Label:"))
        self.label_edit = QLineEdit()
        self.label_edit.returnPressed.connect(self._apply_label)
        self.label_edit.textChanged.connect(self._update_preview)
        naming_layout.addWidget(self.label_edit)

        self.preview_label = QLabel("Preview: ")
        naming_layout.addWidget(self.preview_label)

        naming_layout.addWidget(QLabel("Press Enter to apply."))
        naming_layout.addStretch()

        main_layout.addWidget(naming_group)

        # Buttons
        btn_layout = QHBoxLayout()
        btn_layout.addStretch()

        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.accept)

        btn_layout.addWidget(close_btn)
        main_layout.addLayout(btn_layout)

        self._on_task_changed()

    def _on_task_changed(self) -> None:
        idx = self.task_combo.currentIndex()
        if idx < 0 or idx >= len(state.tasks_cache):
            return
        task_id = state.tasks_cache[idx]
        self.label_edit.setText(state.task_labels.get(task_id, ""))
        self._update_preview()

    def _update_preview(self) -> None:
        idx = self.task_combo.currentIndex()
        if idx < 0 or idx >= len(state.tasks_cache):
            return
        task_id = state.tasks_cache[idx]
        label = self.label_edit.text().strip()
        preview = f"{task_id} {label}".strip() if label else task_id
        self.preview_label.setText(f"Preview: {preview}")

    def _apply_label(self) -> None:
        idx = self.task_combo.currentIndex()
        if idx < 0 or idx >= len(state.tasks_cache):
            return
        task_id = state.tasks_cache[idx]
        label = self.label_edit.text().strip()

        if label:
            state.task_labels[task_id] = label
        else:
            state.task_labels.pop(task_id, None)

        # Refresh combobox
        current_idx = self.task_combo.currentIndex()
        self.task_combo.clear()
        self.task_combo.addItems([state.format_task(t) for t in state.tasks_cache])
        self.task_combo.setCurrentIndex(current_idx)

        self._update_preview()
```

eye_tracking_tool\dialogs.py
```
"""
Dialog windows and custom widgets using PyQt6.
"""
from __future__ import annotations

from typing import Optional, List, Callable, Set

from PyQt6.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QWidget, QLabel, QPushButton,
    QListWidget, QListWidgetItem, QCheckBox, QLineEdit, QComboBox,
    QFrame, QScrollArea, QGroupBox, QGridLayout, QAbstractItemView,
    QMessageBox, QStyledItemDelegate
)
from PyQt6.QtCore import Qt
from PyQt6.QtGui import QTextDocument

from state import state


class MultiSelectDialog(QDialog):
    """
    Modal dialog for multi-selection:
    - Select all checkbox
    - Multi-select list
    - OK / Cancel
    """

    def __init__(
        self,
        parent: QWidget,
        title: str,
        items: List[str],
        selected: Optional[List[str]] = None,
        gray_hint_items: Optional[List[str]] = None,
        display_func: Optional[Callable[[str], str]] = None,
    ) -> None:
        super().__init__(parent)
        self.items = items
        self._selected_set = set(selected or [])
        self._gray_hint = set(gray_hint_items or [])
        self._display_func = display_func or (lambda x: x)
        self.result: Optional[List[str]] = None

        self.setWindowTitle(title)
        self.setMinimumSize(420, 460)
        self.setModal(True)

        layout = QVBoxLayout(self)

        # Select all checkbox
        self.select_all_cb = QCheckBox("Select all")
        self.select_all_cb.stateChanged.connect(self._toggle_select_all)
        layout.addWidget(self.select_all_cb)

        # List widget
        self.list_widget = QListWidget()
        self.list_widget.setSelectionMode(QAbstractItemView.SelectionMode.MultiSelection)

        for item in self.items:
            list_item = QListWidgetItem(self._display_func(item))
            list_item.setData(Qt.ItemDataRole.UserRole, item)
            if item in self._gray_hint:
                list_item.setForeground(Qt.GlobalColor.gray)
            if item in self._selected_set:
                list_item.setSelected(True)
            self.list_widget.addItem(list_item)

        layout.addWidget(self.list_widget)

        # Buttons
        btn_layout = QHBoxLayout()
        btn_layout.addStretch()

        ok_btn = QPushButton("OK")
        ok_btn.clicked.connect(self._on_ok)
        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self._on_cancel)

        btn_layout.addWidget(ok_btn)
        btn_layout.addWidget(cancel_btn)
        layout.addLayout(btn_layout)

    def _toggle_select_all(self, state: int) -> None:
        for i in range(self.list_widget.count()):
            self.list_widget.item(i).setSelected(state == Qt.CheckState.Checked.value)

    def _on_ok(self) -> None:
        self.result = [
            self.list_widget.item(i).data(Qt.ItemDataRole.UserRole)
            for i in range(self.list_widget.count())
            if self.list_widget.item(i).isSelected()
        ]
        self.accept()

    def _on_cancel(self) -> None:
        self.result = None
        self.reject()


class MultiSelectPicker(QWidget):
    """
    A button that opens a multi-select popup dialog.
    """

    def __init__(
        self,
        parent: QWidget,
        options: List[str],
        get_global_selected: Callable[[], Set[str]],
        on_change: Optional[Callable[[], None]] = None,
        placeholder: str = "Select items...",
        popup_title: str = "Select items",
        display_func: Optional[Callable[[str], str]] = None,
    ) -> None:
        super().__init__(parent)
        self._options = options
        self._get_global_selected = get_global_selected
        self._on_change = on_change
        self._placeholder = placeholder
        self._popup_title = popup_title
        self._display_func = display_func or (lambda x: x)

        self._selected: Set[str] = set()

        layout = QHBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)

        self._btn = QPushButton(placeholder)
        self._btn.clicked.connect(self._open_popup)
        layout.addWidget(self._btn)

        self._refresh_summary()

    def get_selected(self) -> List[str]:
        return [o for o in self._options if o in self._selected]

    def set_selected(self, selected: List[str]) -> None:
        self._selected = set(selected)
        self._refresh_summary()

    def refresh_ui(self) -> None:
        self._refresh_summary()

    def _refresh_summary(self) -> None:
        selected = self.get_selected()
        if not selected:
            self._btn.setText(self._placeholder)
        elif len(selected) <= 3:
            self._btn.setText(", ".join(self._display_func(s) for s in selected))
        else:
            self._btn.setText(f"{len(selected)} selected")

    def _open_popup(self) -> None:
        global_selected = self._get_global_selected()
        gray_hint = [o for o in self._options if o in global_selected and o not in self._selected]

        dialog = MultiSelectDialog(
            self,
            title=self._popup_title,
            items=self._options,
            selected=list(self._selected),
            gray_hint_items=gray_hint,
            display_func=self._display_func,
        )

        if dialog.exec() == QDialog.DialogCode.Accepted and dialog.result is not None:
            self._selected = set(dialog.result)
            self._refresh_summary()
            if self._on_change is not None:
                self._on_change()


class GroupParticipantsDialog(QDialog):
    """Dialog for grouping participants."""

    def __init__(self, parent: QWidget) -> None:
        super().__init__(parent)
        self.setWindowTitle("Group Participants")
        self.setMinimumSize(900, 600)
        self.setModal(True)

        self.max_groups = 15

        main_layout = QVBoxLayout(self)

        # Scrollable area
        scroll = QScrollArea()
        scroll.setWidgetResizable(True)
        container = QWidget()
        self.container_layout = QVBoxLayout(container)

        # Header
        header = QHBoxLayout()
        header.addWidget(QLabel("Group name"), stretch=1)
        header.addWidget(QLabel("Participants"), stretch=2)
        self.container_layout.addLayout(header)

        # Group rows
        self.group_name_edits: List[QLineEdit] = []
        self.group_members: List[List[str]] = []
        self.select_btns: List[QPushButton] = []
        self.row_widgets: List[QWidget] = []

        existing_ids = sorted(state.participant_groups.keys())

        for i in range(self.max_groups):
            gid = existing_ids[i] if i < len(existing_ids) else f"G{i+1}"

            row_widget = QWidget()
            row_layout = QHBoxLayout(row_widget)
            row_layout.setContentsMargins(0, 4, 0, 4)

            name_edit = QLineEdit(state.group_names.get(gid, f"Group {i+1}"))
            name_edit.setFixedWidth(200)
            row_layout.addWidget(name_edit)

            members = state.participant_groups.get(gid, []).copy()

            btn = QPushButton("Select participants...")
            btn.clicked.connect(lambda checked, idx=i: self._select_participants(idx))
            row_layout.addWidget(btn, stretch=1)

            self.group_name_edits.append(name_edit)
            self.group_members.append(members)
            self.select_btns.append(btn)
            self.row_widgets.append(row_widget)

            self.container_layout.addWidget(row_widget)
            self._update_btn_text(i)

        scroll.setWidget(container)
        main_layout.addWidget(scroll)

        # Buttons
        btn_layout = QHBoxLayout()
        btn_layout.addStretch()

        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        save_btn = QPushButton("Save & Apply")
        save_btn.clicked.connect(self._save_apply)

        btn_layout.addWidget(save_btn)
        btn_layout.addWidget(cancel_btn)
        main_layout.addLayout(btn_layout)

        self._update_row_visibility()

    def _already_selected_elsewhere(self, current_row: int) -> List[str]:
        s: Set[str] = set()
        for r, members in enumerate(self.group_members):
            if r != current_row:
                s.update(members)
        return sorted(s)

    def _update_btn_text(self, row_idx: int) -> None:
        sel = self.group_members[row_idx]
        if not sel:
            self.select_btns[row_idx].setText("Select participants...")
        elif len(sel) <= 4:
            self.select_btns[row_idx].setText(", ".join(sel))
        else:
            self.select_btns[row_idx].setText(f"{len(sel)} selected")

    def _update_row_visibility(self) -> None:
        for i in range(self.max_groups):
            if i == 0:
                self.row_widgets[i].show()
            elif self.group_members[i - 1]:
                self.row_widgets[i].show()
            else:
                self.row_widgets[i].hide()

    def _select_participants(self, row_idx: int) -> None:
        dialog = MultiSelectDialog(
            self,
            title=f"Select participants for {self.group_name_edits[row_idx].text() or f'Group {row_idx+1}'}",
            items=state.participants_cache,
            selected=self.group_members[row_idx],
            gray_hint_items=self._already_selected_elsewhere(row_idx),
        )

        if dialog.exec() == QDialog.DialogCode.Accepted and dialog.result is not None:
            self.group_members[row_idx] = dialog.result
            self._update_btn_text(row_idx)
            self._update_row_visibility()

    def _save_apply(self) -> None:
        new_groups: dict = {}
        new_names: dict = {}

        for i in range(self.max_groups):
            gid = f"G{i+1}"
            name = self.group_name_edits[i].text().strip() or f"Group {i+1}"
            members = self.group_members[i]

            if not members and i > 0:
                continue

            new_groups[gid] = members
            new_names[gid] = name

        if all(len(v) == 0 for v in new_groups.values()):
            state.participant_groups.clear()
            state.group_names.clear()
        else:
            state.participant_groups.clear()
            state.participant_groups.update(new_groups)
            state.group_names.clear()
            state.group_names.update(new_names)

        self.accept()


class PlainTextDelegate(QStyledItemDelegate):
    """Forces plain-text rendering in item views (prevents HTML/RichText issues)."""

    def initStyleOption(self, option, index):  # type: ignore[override]
        super().initStyleOption(option, index)
        doc = QTextDocument()
        doc.setHtml(option.text)
        option.text = doc.toPlainText()


class GroupTasksDialog(QDialog):
    """Dialog for grouping tasks with task labeling."""

    def __init__(self, parent: QWidget) -> None:
        super().__init__(parent)
        self.setWindowTitle("Task Labels")
        self.setMinimumSize(980, 640)
        self.setModal(True)

        self.max_groups = 15

        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(8, 8, 8, 8)
        main_layout.setSpacing(6)

        # Task naming section
        naming_group = QGroupBox("Task labels")
        naming_layout = QHBoxLayout(naming_group)

        naming_layout.addWidget(QLabel("Task:"))
        self.task_combo = QComboBox()
        self.task_combo.setItemDelegate(PlainTextDelegate(self.task_combo))
        self.task_combo.addItems([state.format_task(t) for t in state.tasks_cache])
        self.task_combo.currentIndexChanged.connect(self._on_task_changed)
        naming_layout.addWidget(self.task_combo)

        naming_layout.addWidget(QLabel("Label:"))
        self.label_edit = QLineEdit()
        self.label_edit.returnPressed.connect(self._apply_label)
        self.label_edit.textChanged.connect(self._update_preview)
        naming_layout.addWidget(self.label_edit)

        self.preview_label = QLabel("Preview: ")
        naming_layout.addWidget(self.preview_label)

        naming_layout.addWidget(QLabel("Press Enter to apply."))
        naming_layout.addStretch()

        main_layout.addWidget(naming_group)

        # Buttons
        btn_layout = QHBoxLayout()
        btn_layout.addStretch()

        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.accept)

        btn_layout.addWidget(close_btn)
        main_layout.addLayout(btn_layout)

        self._on_task_changed()

    def _on_task_changed(self) -> None:
        idx = self.task_combo.currentIndex()
        if idx < 0 or idx >= len(state.tasks_cache):
            return
        task_id = state.tasks_cache[idx]
        self.label_edit.setText(state.task_labels.get(task_id, ""))
        self._update_preview()

    def _update_preview(self) -> None:
        idx = self.task_combo.currentIndex()
        if idx < 0 or idx >= len(state.tasks_cache):
            return
        task_id = state.tasks_cache[idx]
        label = self.label_edit.text().strip()
        preview = f"{task_id} {label}".strip() if label else task_id
        self.preview_label.setText(f"Preview: {preview}")

    def _apply_label(self) -> None:
        idx = self.task_combo.currentIndex()
        if idx < 0 or idx >= len(state.tasks_cache):
            return
        task_id = state.tasks_cache[idx]
        label = self.label_edit.text().strip()

        if label:
            state.task_labels[task_id] = label
        else:
            state.task_labels.pop(task_id, None)

        # Refresh combobox
        current_idx = self.task_combo.currentIndex()
        self.task_combo.clear()
        self.task_combo.addItems([state.format_task(t) for t in state.tasks_cache])
        self.task_combo.setCurrentIndex(current_idx)

        self._update_preview()
```

> Tokens: 10k sent, 5.8k received. Cost: $0.10 message, $0.38 session.  
> Applied edit to dialogs.py  
> Applied edit to eye_tracking_tool\dialogs.py  
> Commit eba60ef refactor: Task-Gruppierung entfernen und Plain-Text-ComboBox nutzen  
> You can use /undo to undo and discard each aider commit.  

#### /role  
> Invalid command: /role  

#### /help  
> /add              Add files to the chat so aider can edit them or review them in detail  
> /architect        Enter architect/editor mode using 2 different models. If no prompt provided, switches to architect/editor mode.  
> /ask              Ask questions about the code base without editing any files. If no prompt provided, switches to ask mode.  
> /chat-mode        Switch to a new chat mode  
> /clear            Clear the chat history  
> /code             Ask for changes to your code. If no prompt provided, switches to code mode.  
> /commit           Commit edits to the repo made outside the chat (commit message optional)  
> /context          Enter context mode to see surrounding code context. If no prompt provided, switches to context mode.  
> /copy             Copy the last assistant message to the clipboard  
> /copy-context     Copy the current chat context as markdown, suitable to paste into a web UI  
> /diff             Display the diff of changes since the last message  
> /drop             Remove files from the chat session to free up context space  
> /edit             Alias for /editor: Open an editor to write a prompt  
> /editor           Open an editor to write a prompt  
> /editor-model     Switch the Editor Model to a new LLM  
> /exit             Exit the application  
> /git              Run a git command (output excluded from chat)  
> /help             Ask questions about aider  
> /lint             Lint and fix in-chat files or all dirty files if none in chat  
> /load             Load and execute commands from a file  
> /ls               List all known files and indicate which are included in the chat session  
> /map              Print out the current repository map  
> /map-refresh      Force a refresh of the repository map  
> /model            Switch the Main Model to a new LLM  
> /models           Search the list of available models  
> /multiline-mode   Toggle multiline mode (swaps behavior of Enter and Meta+Enter)  
> /paste            Paste image/text from the clipboard into the chat.        Optionally provide a name for the image.  
> /quit             Exit the application  
> /read-only        Add files to the chat that are for reference only, or turn added files to read-only  
> /reasoning-effort Set the reasoning effort level (values: number or low/medium/high depending on model)  
> /report           Report a problem by opening a GitHub Issue  
> /reset            Drop all files and clear the chat history  
> /run              Run a shell command and optionally add the output to the chat (alias: !)  
> /save             Save commands to a file that can reconstruct the current chat session's files  
> /settings         Print out the current settings  
> /test             Run a shell command and add the output to the chat on non-zero exit code  
> /think-tokens     Set the thinking token budget, eg: 8096, 8k, 10.5k, 0.5M, or 0 to disable.  
> /tokens           Report on the number of tokens used by the current chat context  
> /undo             Undo the last git commit if it was done by aider  
> /voice            Record and transcribe voice input  
> /weak-model       Switch the Weak Model to a new LLM  
> /web              Scrape a webpage, convert to markdown and send in a message  
> Use `/help <question>` to ask questions about how to use aider.  

#### /code  
> Aider v0.86.1  
> Model: gpt-5.2 with whole edit format  
> Git repo: .git with 25 files  
> Repo-map: using 4096 tokens, auto refresh  
> Added dialogs.py to the chat.  
> Added eye_tracking_tool\dialogs.py to the chat.  
> Added main.py to the chat.  
> Added state.py to the chat.  
> Restored previous conversation history.  

#### /drop main.py  
> Removed main.py from the chat  

#### /drop state.py  
> Removed state.py from the chat  

#### 1) Button-Text ändern  
####   
#### Der Button in der Haupt-UI heißt aktuell "Group Tasks".  
####   
#### Ändere die Beschriftung auf "Name Tasks".  
####   
#### Funktionalität bleibt: Beim Klick öffnet sich weiterhin das vorhandene „Task Labels“-Fenster.  
####   
#### 2) Popup-Fenster kompakter machen (Layout)  
####   
#### Das Fenster „Task Labels“ soll deutlich kleiner werden und ein klares, kompaktes Layout bekommen:  
####   
#### Die Eingabeelemente (Dropdown „Task“, Label-Textbox, Preview) sollen oben im Fenster ausgerichtet sein (Top-Alignment), nicht mittig/verteilt.  
####   
#### Die große leere Fläche soll verschwinden: Fensterhöhe reduzieren, sinnvolle feste geometry/minsize setzen.  
####   
#### Die restliche Fläche unterhalb soll nicht unnötig Platz verbrauchen (falls ein großer Container/Frame/Text-Widget existiert: entfernen oder stark verkleinern).  
####   
#### Verwende ein einfaches Grid/Pack-Layout mit wenigen Frames, ohne zusätzliche Komplexität.  
####   
#### 3) Dropdown reparieren (unsichtbare/alte Einträge)  
####   
#### Das Dropdown für „Task“ hat aktuell offenbar „unsichtbare Elemente“ bzw. alte Einträge/Artefakte.  
####   
#### Stelle sicher, dass die Combobox genau die aktuellen Task-Items enthält (keine Duplikate, keine leeren Strings, keine „ghost entries“).  
####   
#### Beim Aktualisieren der Task-Liste sollen alte Werte sauber ersetzt werden (z. B. combobox["values"] = new_values und ggf. set() auf gültigen Wert).  
####   
#### Falls die Werte aus einer Liste/Dict kommen: normalisieren (strip), leere entfernen, eindeutige Reihenfolge beibehalten.  
####   
#### 4) Enter-Verhalten ändern (Workflow)  
####   
#### Aktuell: Enter in der Label-Textbox schließt offenbar das Popup.  
#### Gewünschtes Verhalten:  
####   
#### Wenn in der Label-Textbox Enter gedrückt wird:  
####   
#### Den aktuellen Label-Text auf den aktuell ausgewählten Task anwenden (wie bisher).  
####   
#### Popup bleibt offen (nicht schließen).  
####   
#### Im Dropdown wird automatisch der nächste Task ausgewählt (Index + 1).  
####   
#### Wenn bereits der letzte Task ausgewählt ist: entweder beim letzten bleiben oder auf den ersten springen (bitte sinnvoll implementieren; bevorzugt: beim letzten bleiben).  
####   
#### Die Label-Textbox wird geleert und der Cursor bleibt in der Textbox (so dass man direkt weiter tippen kann).  
####   
#### Preview wird entsprechend aktualisiert.  
####   
#### 5) Robustheit / UX  
####   
#### Wenn keine Tasks vorhanden sind: Dropdown disabled und Enter macht nichts.  
####   
#### Wenn der Label-Text leer ist: Enter soll nichts anwenden, aber trotzdem zum nächsten Task springen (oder optional: nicht springen – entscheide sinnvoll und konsistent; bevorzugt: nicht anwenden und nicht springen).  
####   
#### Keine Änderungen am restlichen UI-Layout außerhalb der notwendigen Button-Umbenennung.  
####   
#### Am Ende: Bitte zeige nur die Diffs/Änderungen an diesen beiden Dateien.  

Es sind **Code-Änderungen nötig**, aber nicht alle Punkte können mit den **zwei bereitgestellten Dateien** umgesetzt werden:

- **(1) Button-Text „Group Tasks“ → „Name Tasks“**: Das sitzt sehr wahrscheinlich in `main_window.py` (oder `eye_tracking_tool/main_window.py`) und **nicht** in `dialogs.py`. Diese Dateien sind aktuell *read-only* (nicht im Chat als editierbar enthalten). Dafür muss ich dich bitten, die betreffende `main_window.py` in den Chat zu kopieren.
- **(2)-(5)** betreffen das Popup **„Task Labels“** und damit `GroupTasksDialog` in **beiden** `dialogs.py`-Dateien → das kann ich hier sauber umsetzen.

### Geplante Änderungen in `GroupTasksDialog` (beide Dateien)
1) **Popup kompakter / Top-Alignment**
- Fenstergröße deutlich reduzieren (`setMinimumSize` runter, zusätzlich `resize(...)`).
- Layout vereinfachen: statt breitem `QHBoxLayout` in einem `QGroupBox` ein kompaktes `QGridLayout` (oben ausgerichtet), keine „Stretch“-Elemente, die Fläche aufblasen.

2) **Dropdown „ghost entries“ verhindern**
- Zentrale Methode `_rebuild_task_combo(keep_task_id=...)`:
  - Quelle `state.tasks_cache` normalisieren: `strip()`, leere entfernen, Duplikate entfernen **bei stabiler Reihenfolge**.
  - Combobox wird mit `blockSignals(True)` sauber geleert und neu befüllt.
  - Auswahl wird auf einen gültigen Index gesetzt (vorzugsweise gleicher Task wie vorher, sonst 0).
- Zusätzlich: Combobox disabled, wenn keine Tasks vorhanden.

3) **Enter-Workflow**
- `returnPressed` ruft neue Methode `_apply_and_advance()`:
  - Wenn keine Tasks: nichts tun.
  - Wenn Label leer: **nicht anwenden und nicht springen** (wie von dir bevorzugt).
  - Sonst: Label anwenden, Popup bleibt offen, dann **zum nächsten Task springen** (wenn letzter: beim letzten bleiben).
  - Textbox leeren, Fokus/Cursor bleibt in der Textbox, Preview aktualisieren.

4) **UX/Robustheit**
- Preview/Label-Feld werden sinnvoll disabled/geleert, wenn keine Tasks vorhanden.

---

## Aktualisierte Dateien

eye_tracking_tool/dialogs.py
```
"""
Dialog windows and custom widgets using PyQt6.
"""
from __future__ import annotations

from typing import Optional, List, Callable, Set

from PyQt6.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QWidget, QLabel, QPushButton,
    QListWidget, QListWidgetItem, QCheckBox, QLineEdit, QComboBox,
    QFrame, QScrollArea, QGroupBox, QGridLayout, QAbstractItemView,
    QMessageBox, QStyledItemDelegate
)
from PyQt6.QtCore import Qt
from PyQt6.QtGui import QTextDocument

from state import state


class MultiSelectDialog(QDialog):
    """
    Modal dialog for multi-selection:
    - Select all checkbox
    - Multi-select list
    - OK / Cancel
    """

    def __init__(
        self,
        parent: QWidget,
        title: str,
        items: List[str],
        selected: Optional[List[str]] = None,
        gray_hint_items: Optional[List[str]] = None,
        display_func: Optional[Callable[[str], str]] = None,
    ) -> None:
        super().__init__(parent)
        self.items = items
        self._selected_set = set(selected or [])
        self._gray_hint = set(gray_hint_items or [])
        self._display_func = display_func or (lambda x: x)
        self.result: Optional[List[str]] = None

        self.setWindowTitle(title)
        self.setMinimumSize(420, 460)
        self.setModal(True)

        layout = QVBoxLayout(self)

        # Select all checkbox
        self.select_all_cb = QCheckBox("Select all")
        self.select_all_cb.stateChanged.connect(self._toggle_select_all)
        layout.addWidget(self.select_all_cb)

        # List widget
        self.list_widget = QListWidget()
        self.list_widget.setSelectionMode(QAbstractItemView.SelectionMode.MultiSelection)

        for item in self.items:
            list_item = QListWidgetItem(self._display_func(item))
            list_item.setData(Qt.ItemDataRole.UserRole, item)
            if item in self._gray_hint:
                list_item.setForeground(Qt.GlobalColor.gray)
            if item in self._selected_set:
                list_item.setSelected(True)
            self.list_widget.addItem(list_item)

        layout.addWidget(self.list_widget)

        # Buttons
        btn_layout = QHBoxLayout()
        btn_layout.addStretch()

        ok_btn = QPushButton("OK")
        ok_btn.clicked.connect(self._on_ok)
        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self._on_cancel)

        btn_layout.addWidget(ok_btn)
        btn_layout.addWidget(cancel_btn)
        layout.addLayout(btn_layout)

    def _toggle_select_all(self, state: int) -> None:
        for i in range(self.list_widget.count()):
            self.list_widget.item(i).setSelected(state == Qt.CheckState.Checked.value)

    def _on_ok(self) -> None:
        self.result = [
            self.list_widget.item(i).data(Qt.ItemDataRole.UserRole)
            for i in range(self.list_widget.count())
            if self.list_widget.item(i).isSelected()
        ]
        self.accept()

    def _on_cancel(self) -> None:
        self.result = None
        self.reject()


class MultiSelectPicker(QWidget):
    """
    A button that opens a multi-select popup dialog.
    """

    def __init__(
        self,
        parent: QWidget,
        options: List[str],
        get_global_selected: Callable[[], Set[str]],
        on_change: Optional[Callable[[], None]] = None,
        placeholder: str = "Select items...",
        popup_title: str = "Select items",
        display_func: Optional[Callable[[str], str]] = None,
    ) -> None:
        super().__init__(parent)
        self._options = options
        self._get_global_selected = get_global_selected
        self._on_change = on_change
        self._placeholder = placeholder
        self._popup_title = popup_title
        self._display_func = display_func or (lambda x: x)

        self._selected: Set[str] = set()

        layout = QHBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)

        self._btn = QPushButton(placeholder)
        self._btn.clicked.connect(self._open_popup)
        layout.addWidget(self._btn)

        self._refresh_summary()

    def get_selected(self) -> List[str]:
        return [o for o in self._options if o in self._selected]

    def set_selected(self, selected: List[str]) -> None:
        self._selected = set(selected)
        self._refresh_summary()

    def refresh_ui(self) -> None:
        self._refresh_summary()

    def _refresh_summary(self) -> None:
        selected = self.get_selected()
        if not selected:
            self._btn.setText(self._placeholder)
        elif len(selected) <= 3:
            self._btn.setText(", ".join(self._display_func(s) for s in selected))
        else:
            self._btn.setText(f"{len(selected)} selected")

    def _open_popup(self) -> None:
        global_selected = self._get_global_selected()
        gray_hint = [o for o in self._options if o in global_selected and o not in self._selected]

        dialog = MultiSelectDialog(
            self,
            title=self._popup_title,
            items=self._options,
            selected=list(self._selected),
            gray_hint_items=gray_hint,
            display_func=self._display_func,
        )

        if dialog.exec() == QDialog.DialogCode.Accepted and dialog.result is not None:
            self._selected = set(dialog.result)
            self._refresh_summary()
            if self._on_change is not None:
                self._on_change()


class GroupParticipantsDialog(QDialog):
    """Dialog for grouping participants."""

    def __init__(self, parent: QWidget) -> None:
        super().__init__(parent)
        self.setWindowTitle("Group Participants")
        self.setMinimumSize(900, 600)
        self.setModal(True)

        self.max_groups = 15

        main_layout = QVBoxLayout(self)

        # Scrollable area
        scroll = QScrollArea()
        scroll.setWidgetResizable(True)
        container = QWidget()
        self.container_layout = QVBoxLayout(container)

        # Header
        header = QHBoxLayout()
        header.addWidget(QLabel("Group name"), stretch=1)
        header.addWidget(QLabel("Participants"), stretch=2)
        self.container_layout.addLayout(header)

        # Group rows
        self.group_name_edits: List[QLineEdit] = []
        self.group_members: List[List[str]] = []
        self.select_btns: List[QPushButton] = []
        self.row_widgets: List[QWidget] = []

        existing_ids = sorted(state.participant_groups.keys())

        for i in range(self.max_groups):
            gid = existing_ids[i] if i < len(existing_ids) else f"G{i+1}"

            row_widget = QWidget()
            row_layout = QHBoxLayout(row_widget)
            row_layout.setContentsMargins(0, 4, 0, 4)

            name_edit = QLineEdit(state.group_names.get(gid, f"Group {i+1}"))
            name_edit.setFixedWidth(200)
            row_layout.addWidget(name_edit)

            members = state.participant_groups.get(gid, []).copy()

            btn = QPushButton("Select participants...")
            btn.clicked.connect(lambda checked, idx=i: self._select_participants(idx))
            row_layout.addWidget(btn, stretch=1)

            self.group_name_edits.append(name_edit)
            self.group_members.append(members)
            self.select_btns.append(btn)
            self.row_widgets.append(row_widget)

            self.container_layout.addWidget(row_widget)
            self._update_btn_text(i)

        scroll.setWidget(container)
        main_layout.addWidget(scroll)

        # Buttons
        btn_layout = QHBoxLayout()
        btn_layout.addStretch()

        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        save_btn = QPushButton("Save & Apply")
        save_btn.clicked.connect(self._save_apply)

        btn_layout.addWidget(save_btn)
        btn_layout.addWidget(cancel_btn)
        main_layout.addLayout(btn_layout)

        self._update_row_visibility()

    def _already_selected_elsewhere(self, current_row: int) -> List[str]:
        s: Set[str] = set()
        for r, members in enumerate(self.group_members):
            if r != current_row:
                s.update(members)
        return sorted(s)

    def _update_btn_text(self, row_idx: int) -> None:
        sel = self.group_members[row_idx]
        if not sel:
            self.select_btns[row_idx].setText("Select participants...")
        elif len(sel) <= 4:
            self.select_btns[row_idx].setText(", ".join(sel))
        else:
            self.select_btns[row_idx].setText(f"{len(sel)} selected")

    def _update_row_visibility(self) -> None:
        for i in range(self.max_groups):
            if i == 0:
                self.row_widgets[i].show()
            elif self.group_members[i - 1]:
                self.row_widgets[i].show()
            else:
                self.row_widgets[i].hide()

    def _select_participants(self, row_idx: int) -> None:
        dialog = MultiSelectDialog(
            self,
            title=f"Select participants for {self.group_name_edits[row_idx].text() or f'Group {row_idx+1}'}",
            items=state.participants_cache,
            selected=self.group_members[row_idx],
            gray_hint_items=self._already_selected_elsewhere(row_idx),
        )

        if dialog.exec() == QDialog.DialogCode.Accepted and dialog.result is not None:
            self.group_members[row_idx] = dialog.result
            self._update_btn_text(row_idx)
            self._update_row_visibility()

    def _save_apply(self) -> None:
        new_groups: dict = {}
        new_names: dict = {}

        for i in range(self.max_groups):
            gid = f"G{i+1}"
            name = self.group_name_edits[i].text().strip() or f"Group {i+1}"
            members = self.group_members[i]

            if not members and i > 0:
                continue

            new_groups[gid] = members
            new_names[gid] = name

        if all(len(v) == 0 for v in new_groups.values()):
            state.participant_groups.clear()
            state.group_names.clear()
        else:
            state.participant_groups.clear()
            state.participant_groups.update(new_groups)
            state.group_names.clear()
            state.group_names.update(new_names)

        self.accept()


class PlainTextDelegate(QStyledItemDelegate):
    """Forces plain-text rendering in item views (prevents HTML/RichText issues)."""

    def initStyleOption(self, option, index):  # type: ignore[override]
        super().initStyleOption(option, index)
        doc = QTextDocument()
        doc.setHtml(option.text)
        option.text = doc.toPlainText()


class GroupTasksDialog(QDialog):
    """Dialog for task labeling."""

    def __init__(self, parent: QWidget) -> None:
        super().__init__(parent)
        self.setWindowTitle("Task Labels")
        self.setModal(True)

        # Kompaktere Default-Größe
        self.setMinimumSize(640, 180)
        self.resize(720, 220)

        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(10, 10, 10, 10)
        main_layout.setSpacing(8)

        # Kompakter Eingabeblock (Top-aligned)
        form_group = QGroupBox("Task labels")
        form_layout = QGridLayout(form_group)
        form_layout.setContentsMargins(10, 10, 10, 10)
        form_layout.setHorizontalSpacing(8)
        form_layout.setVerticalSpacing(6)
        form_layout.setAlignment(Qt.AlignmentFlag.AlignTop)

        task_lbl = QLabel("Task:")
        task_lbl.setAlignment(Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignLeft)
        form_layout.addWidget(task_lbl, 0, 0)

        self.task_combo = QComboBox()
        self.task_combo.setItemDelegate(PlainTextDelegate(self.task_combo))
        self.task_combo.currentIndexChanged.connect(self._on_task_changed)
        form_layout.addWidget(self.task_combo, 0, 1, 1, 3)

        label_lbl = QLabel("Label:")
        label_lbl.setAlignment(Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignLeft)
        form_layout.addWidget(label_lbl, 1, 0)

        self.label_edit = QLineEdit()
        # Enter soll anwenden + weiter springen, aber NICHT schließen
        self.label_edit.returnPressed.connect(self._apply_and_advance)
        self.label_edit.textChanged.connect(self._update_preview)
        form_layout.addWidget(self.label_edit, 1, 1, 1, 3)

        self.preview_label = QLabel("Preview:")
        self.preview_label.setAlignment(Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignLeft)
        form_layout.addWidget(self.preview_label, 2, 0)

        self.preview_value = QLabel("")
        self.preview_value.setTextInteractionFlags(Qt.TextInteractionFlag.TextSelectableByMouse)
        self.preview_value.setAlignment(Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignLeft)
        form_layout.addWidget(self.preview_value, 2, 1, 1, 3)

        hint = QLabel("Enter = apply label")
        hint.setAlignment(Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignRight)
        form_layout.addWidget(hint, 3, 0, 1, 4)

        main_layout.addWidget(form_group, 0, Qt.AlignmentFlag.AlignTop)

        # Buttons
        btn_layout = QHBoxLayout()
        btn_layout.addStretch()

        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.accept)

        btn_layout.addWidget(close_btn)
        main_layout.addLayout(btn_layout)

        # Initialer Aufbau der Combobox (verhindert Ghost-Entries)
        self._rebuild_task_combo(keep_task_id=None)

    def _normalized_tasks(self) -> List[str]:
        seen: Set[str] = set()
        out: List[str] = []
        for t in getattr(state, "tasks_cache", []) or []:
            t2 = (t or "").strip()
            if not t2:
                continue
            if t2 in seen:
                continue
            seen.add(t2)
            out.append(t2)
        return out

    def _rebuild_task_combo(self, keep_task_id: Optional[str]) -> None:
        tasks = self._normalized_tasks()

        self.task_combo.blockSignals(True)
        try:
            self.task_combo.clear()
            self.task_combo.addItems([state.format_task(t) for t in tasks])
        finally:
            self.task_combo.blockSignals(False)

        has_tasks = len(tasks) > 0
        self.task_combo.setEnabled(has_tasks)
        self.label_edit.setEnabled(has_tasks)

        if not has_tasks:
            self.label_edit.setText("")
            self.preview_value.setText("")
            return

        # Auswahl wiederherstellen (wenn möglich)
        idx_to_set = 0
        if keep_task_id is not None:
            try:
                idx_to_set = tasks.index(keep_task_id)
            except ValueError:
                idx_to_set = 0

        self.task_combo.setCurrentIndex(max(0, min(idx_to_set, len(tasks) - 1)))
        self._on_task_changed()

    def _current_task_id(self) -> Optional[str]:
        tasks = self._normalized_tasks()
        idx = self.task_combo.currentIndex()
        if idx < 0 or idx >= len(tasks):
            return None
        return tasks[idx]

    def _on_task_changed(self) -> None:
        task_id = self._current_task_id()
        if task_id is None:
            self.label_edit.setText("")
            self.preview_value.setText("")
            return

        self.label_edit.setText(state.task_labels.get(task_id, ""))
        self._update_preview()

    def _update_preview(self) -> None:
        task_id = self._current_task_id()
        if task_id is None:
            self.preview_value.setText("")
            return

        label = self.label_edit.text().strip()
        preview = f"{task_id} {label}".strip() if label else task_id
        self.preview_value.setText(preview)

    def _apply_label_to_current(self) -> bool:
        """
        Wendet das Label auf den aktuellen Task an.
        Returns True, wenn tatsächlich angewendet wurde (label nicht leer).
        """
        task_id = self._current_task_id()
        if task_id is None:
            return False

        label = self.label_edit.text().strip()
        if not label:
            return False

        state.task_labels[task_id] = label
        return True

    def _apply_and_advance(self) -> None:
        # Keine Tasks -> nichts tun
        tasks = self._normalized_tasks()
        if not tasks:
            return

        # Leerer Text: nicht anwenden und nicht springen (wie gewünscht)
        if not self.label_edit.text().strip():
            self.label_edit.setFocus()
            self.label_edit.selectAll()
            self._update_preview()
            return

        current_task_id = self._current_task_id()
        if current_task_id is None:
            return

        applied = self._apply_label_to_current()
        if not applied:
            return

        # Nach dem Anwenden: Combo sauber neu aufbauen (gegen Artefakte),
        # Auswahl beibehalten und dann ggf. weiter springen.
        current_idx = self.task_combo.currentIndex()
        self._rebuild_task_combo(keep_task_id=current_task_id)

        # Weiter zum nächsten Task (wenn letzter: beim letzten bleiben)
        next_idx = min(current_idx + 1, len(tasks) - 1)
        self.task_combo.setCurrentIndex(next_idx)

        # Textbox leeren, Fokus behalten
        self.label_edit.setText("")
        self.label_edit.setFocus()

        self._update_preview()
```

dialogs.py
```
"""
Dialog windows and custom widgets using PyQt6.
"""
from __future__ import annotations

from typing import Optional, List, Callable, Set

from PyQt6.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QWidget, QLabel, QPushButton,
    QListWidget, QListWidgetItem, QCheckBox, QLineEdit, QComboBox,
    QFrame, QScrollArea, QGroupBox, QGridLayout, QAbstractItemView,
    QMessageBox, QStyledItemDelegate
)
from PyQt6.QtCore import Qt
from PyQt6.QtGui import QTextDocument

from state import state


class MultiSelectDialog(QDialog):
    """
    Modal dialog for multi-selection:
    - Select all checkbox
    - Multi-select list
    - OK / Cancel
    """

    def __init__(
        self,
        parent: QWidget,
        title: str,
        items: List[str],
        selected: Optional[List[str]] = None,
        gray_hint_items: Optional[List[str]] = None,
        display_func: Optional[Callable[[str], str]] = None,
    ) -> None:
        super().__init__(parent)
        self.items = items
        self._selected_set = set(selected or [])
        self._gray_hint = set(gray_hint_items or [])
        self._display_func = display_func or (lambda x: x)
        self.result: Optional[List[str]] = None

        self.setWindowTitle(title)
        self.setMinimumSize(420, 460)
        self.setModal(True)

        layout = QVBoxLayout(self)

        # Select all checkbox
        self.select_all_cb = QCheckBox("Select all")
        self.select_all_cb.stateChanged.connect(self._toggle_select_all)
        layout.addWidget(self.select_all_cb)

        # List widget
        self.list_widget = QListWidget()
        self.list_widget.setSelectionMode(QAbstractItemView.SelectionMode.MultiSelection)

        for item in self.items:
            list_item = QListWidgetItem(self._display_func(item))
            list_item.setData(Qt.ItemDataRole.UserRole, item)
            if item in self._gray_hint:
                list_item.setForeground(Qt.GlobalColor.gray)
            if item in self._selected_set:
                list_item.setSelected(True)
            self.list_widget.addItem(list_item)

        layout.addWidget(self.list_widget)

        # Buttons
        btn_layout = QHBoxLayout()
        btn_layout.addStretch()

        ok_btn = QPushButton("OK")
        ok_btn.clicked.connect(self._on_ok)
        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self._on_cancel)

        btn_layout.addWidget(ok_btn)
        btn_layout.addWidget(cancel_btn)
        layout.addLayout(btn_layout)

    def _toggle_select_all(self, state: int) -> None:
        for i in range(self.list_widget.count()):
            self.list_widget.item(i).setSelected(state == Qt.CheckState.Checked.value)

    def _on_ok(self) -> None:
        self.result = [
            self.list_widget.item(i).data(Qt.ItemDataRole.UserRole)
            for i in range(self.list_widget.count())
            if self.list_widget.item(i).isSelected()
        ]
        self.accept()

    def _on_cancel(self) -> None:
        self.result = None
        self.reject()


class MultiSelectPicker(QWidget):
    """
    A button that opens a multi-select popup dialog.
    """

    def __init__(
        self,
        parent: QWidget,
        options: List[str],
        get_global_selected: Callable[[], Set[str]],
        on_change: Optional[Callable[[], None]] = None,
        placeholder: str = "Select items...",
        popup_title: str = "Select items",
        display_func: Optional[Callable[[str], str]] = None,
    ) -> None:
        super().__init__(parent)
        self._options = options
        self._get_global_selected = get_global_selected
        self._on_change = on_change
        self._placeholder = placeholder
        self._popup_title = popup_title
        self._display_func = display_func or (lambda x: x)

        self._selected: Set[str] = set()

        layout = QHBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)

        self._btn = QPushButton(placeholder)
        self._btn.clicked.connect(self._open_popup)
        layout.addWidget(self._btn)

        self._refresh_summary()

    def get_selected(self) -> List[str]:
        return [o for o in self._options if o in self._selected]

    def set_selected(self, selected: List[str]) -> None:
        self._selected = set(selected)
        self._refresh_summary()

    def refresh_ui(self) -> None:
        self._refresh_summary()

    def _refresh_summary(self) -> None:
        selected = self.get_selected()
        if not selected:
            self._btn.setText(self._placeholder)
        elif len(selected) <= 3:
            self._btn.setText(", ".join(self._display_func(s) for s in selected))
        else:
            self._btn.setText(f"{len(selected)} selected")

    def _open_popup(self) -> None:
        global_selected = self._get_global_selected()
        gray_hint = [o for o in self._options if o in global_selected and o not in self._selected]

        dialog = MultiSelectDialog(
            self,
            title=self._popup_title,
            items=self._options,
            selected=list(self._selected),
            gray_hint_items=gray_hint,
            display_func=self._display_func,
        )

        if dialog.exec() == QDialog.DialogCode.Accepted and dialog.result is not None:
            self._selected = set(dialog.result)
            self._refresh_summary()
            if self._on_change is not None:
                self._on_change()


class GroupParticipantsDialog(QDialog):
    """Dialog for grouping participants."""

    def __init__(self, parent: QWidget) -> None:
        super().__init__(parent)
        self.setWindowTitle("Group Participants")
        self.setMinimumSize(900, 600)
        self.setModal(True)

        self.max_groups = 15

        main_layout = QVBoxLayout(self)

        # Scrollable area
        scroll = QScrollArea()
        scroll.setWidgetResizable(True)
        container = QWidget()
        self.container_layout = QVBoxLayout(container)

        # Header
        header = QHBoxLayout()
        header.addWidget(QLabel("Group name"), stretch=1)
        header.addWidget(QLabel("Participants"), stretch=2)
        self.container_layout.addLayout(header)

        # Group rows
        self.group_name_edits: List[QLineEdit] = []
        self.group_members: List[List[str]] = []
        self.select_btns: List[QPushButton] = []
        self.row_widgets: List[QWidget] = []

        existing_ids = sorted(state.participant_groups.keys())

        for i in range(self.max_groups):
            gid = existing_ids[i] if i < len(existing_ids) else f"G{i+1}"

            row_widget = QWidget()
            row_layout = QHBoxLayout(row_widget)
            row_layout.setContentsMargins(0, 4, 0, 4)

            name_edit = QLineEdit(state.group_names.get(gid, f"Group {i+1}"))
            name_edit.setFixedWidth(200)
            row_layout.addWidget(name_edit)

            members = state.participant_groups.get(gid, []).copy()

            btn = QPushButton("Select participants...")
            btn.clicked.connect(lambda checked, idx=i: self._select_participants(idx))
            row_layout.addWidget(btn, stretch=1)

            self.group_name_edits.append(name_edit)
            self.group_members.append(members)
            self.select_btns.append(btn)
            self.row_widgets.append(row_widget)

            self.container_layout.addWidget(row_widget)
            self._update_btn_text(i)

        scroll.setWidget(container)
        main_layout.addWidget(scroll)

        # Buttons
        btn_layout = QHBoxLayout()
        btn_layout.addStretch()

        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        save_btn = QPushButton("Save & Apply")
        save_btn.clicked.connect(self._save_apply)

        btn_layout.addWidget(save_btn)
        btn_layout.addWidget(cancel_btn)
        main_layout.addLayout(btn_layout)

        self._update_row_visibility()

    def _already_selected_elsewhere(self, current_row: int) -> List[str]:
        s: Set[str] = set()
        for r, members in enumerate(self.group_members):
            if r != current_row:
                s.update(members)
        return sorted(s)

    def _update_btn_text(self, row_idx: int) -> None:
        sel = self.group_members[row_idx]
        if not sel:
            self.select_btns[row_idx].setText("Select participants...")
        elif len(sel) <= 4:
            self.select_btns[row_idx].setText(", ".join(sel))
        else:
            self.select_btns[row_idx].setText(f"{len(sel)} selected")

    def _update_row_visibility(self) -> None:
        for i in range(self.max_groups):
            if i == 0:
                self.row_widgets[i].show()
            elif self.group_members[i - 1]:
                self.row_widgets[i].show()
            else:
                self.row_widgets[i].hide()

    def _select_participants(self, row_idx: int) -> None:
        dialog = MultiSelectDialog(
            self,
            title=f"Select participants for {self.group_name_edits[row_idx].text() or f'Group {row_idx+1}'}",
            items=state.participants_cache,
            selected=self.group_members[row_idx],
            gray_hint_items=self._already_selected_elsewhere(row_idx),
        )

        if dialog.exec() == QDialog.DialogCode.Accepted and dialog.result is not None:
            self.group_members[row_idx] = dialog.result
            self._update_btn_text(row_idx)
            self._update_row_visibility()

    def _save_apply(self) -> None:
        new_groups: dict = {}
        new_names: dict = {}

        for i in range(self.max_groups):
            gid = f"G{i+1}"
            name = self.group_name_edits[i].text().strip() or f"Group {i+1}"
            members = self.group_members[i]

            if not members and i > 0:
                continue

            new_groups[gid] = members
            new_names[gid] = name

        if all(len(v) == 0 for v in new_groups.values()):
            state.participant_groups.clear()
            state.group_names.clear()
        else:
            state.participant_groups.clear()
            state.participant_groups.update(new_groups)
            state.group_names.clear()
            state.group_names.update(new_names)

        self.accept()


class PlainTextDelegate(QStyledItemDelegate):
    """Forces plain-text rendering in item views (prevents HTML/RichText issues)."""

    def initStyleOption(self, option, index):  # type: ignore[override]
        super().initStyleOption(option, index)
        doc = QTextDocument()
        doc.setHtml(option.text)
        option.text = doc.toPlainText()


class GroupTasksDialog(QDialog):
    """Dialog for task labeling."""

    def __init__(self, parent: QWidget) -> None:
        super().__init__(parent)
        self.setWindowTitle("Task Labels")
        self.setModal(True)

        # Kompaktere Default-Größe
        self.setMinimumSize(640, 180)
        self.resize(720, 220)

        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(10, 10, 10, 10)
        main_layout.setSpacing(8)

        # Kompakter Eingabeblock (Top-aligned)
        form_group = QGroupBox("Task labels")
        form_layout = QGridLayout(form_group)
        form_layout.setContentsMargins(10, 10, 10, 10)
        form_layout.setHorizontalSpacing(8)
        form_layout.setVerticalSpacing(6)
        form_layout.setAlignment(Qt.AlignmentFlag.AlignTop)

        task_lbl = QLabel("Task:")
        task_lbl.setAlignment(Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignLeft)
        form_layout.addWidget(task_lbl, 0, 0)

        self.task_combo = QComboBox()
        self.task_combo.setItemDelegate(PlainTextDelegate(self.task_combo))
        self.task_combo.currentIndexChanged.connect(self._on_task_changed)
        form_layout.addWidget(self.task_combo, 0, 1, 1, 3)

        label_lbl = QLabel("Label:")
        label_lbl.setAlignment(Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignLeft)
        form_layout.addWidget(label_lbl, 1, 0)

        self.label_edit = QLineEdit()
        # Enter soll anwenden + weiter springen, aber NICHT schließen
        self.label_edit.returnPressed.connect(self._apply_and_advance)
        self.label_edit.textChanged.connect(self._update_preview)
        form_layout.addWidget(self.label_edit, 1, 1, 1, 3)

        self.preview_label = QLabel("Preview:")
        self.preview_label.setAlignment(Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignLeft)
        form_layout.addWidget(self.preview_label, 2, 0)

        self.preview_value = QLabel("")
        self.preview_value.setTextInteractionFlags(Qt.TextInteractionFlag.TextSelectableByMouse)
        self.preview_value.setAlignment(Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignLeft)
        form_layout.addWidget(self.preview_value, 2, 1, 1, 3)

        hint = QLabel("Enter = apply label")
        hint.setAlignment(Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignRight)
        form_layout.addWidget(hint, 3, 0, 1, 4)

        main_layout.addWidget(form_group, 0, Qt.AlignmentFlag.AlignTop)

        # Buttons
        btn_layout = QHBoxLayout()
        btn_layout.addStretch()

        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.accept)

        btn_layout.addWidget(close_btn)
        main_layout.addLayout(btn_layout)

        # Initialer Aufbau der Combobox (verhindert Ghost-Entries)
        self._rebuild_task_combo(keep_task_id=None)

    def _normalized_tasks(self) -> List[str]:
        seen: Set[str] = set()
        out: List[str] = []
        for t in getattr(state, "tasks_cache", []) or []:
            t2 = (t or "").strip()
            if not t2:
                continue
            if t2 in seen:
                continue
            seen.add(t2)
            out.append(t2)
        return out

    def _rebuild_task_combo(self, keep_task_id: Optional[str]) -> None:
        tasks = self._normalized_tasks()

        self.task_combo.blockSignals(True)
        try:
            self.task_combo.clear()
            self.task_combo.addItems([state.format_task(t) for t in tasks])
        finally:
            self.task_combo.blockSignals(False)

        has_tasks = len(tasks) > 0
        self.task_combo.setEnabled(has_tasks)
        self.label_edit.setEnabled(has_tasks)

        if not has_tasks:
            self.label_edit.setText("")
            self.preview_value.setText("")
            return

        # Auswahl wiederherstellen (wenn möglich)
        idx_to_set = 0
        if keep_task_id is not None:
            try:
                idx_to_set = tasks.index(keep_task_id)
            except ValueError:
                idx_to_set = 0

        self.task_combo.setCurrentIndex(max(0, min(idx_to_set, len(tasks) - 1)))
        self._on_task_changed()

    def _current_task_id(self) -> Optional[str]:
        tasks = self._normalized_tasks()
        idx = self.task_combo.currentIndex()
        if idx < 0 or idx >= len(tasks):
            return None
        return tasks[idx]

    def _on_task_changed(self) -> None:
        task_id = self._current_task_id()
        if task_id is None:
            self.label_edit.setText("")
            self.preview_value.setText("")
            return

        self.label_edit.setText(state.task_labels.get(task_id, ""))
        self._update_preview()

    def _update_preview(self) -> None:
        task_id = self._current_task_id()
        if task_id is None:
            self.preview_value.setText("")
            return

        label = self.label_edit.text().strip()
        preview = f"{task_id} {label}".strip() if label else task_id
        self.preview_value.setText(preview)

    def _apply_label_to_current(self) -> bool:
        """
        Wendet das Label auf den aktuellen Task an.
        Returns True, wenn tatsächlich angewendet wurde (label nicht leer).
        """
        task_id = self._current_task_id()
        if task_id is None:
            return False

        label = self.label_edit.text().strip()
        if not label:
            return False

        state.task_labels[task_id] = label
        return True

    def _apply_and_advance(self) -> None:
        # Keine Tasks -> nichts tun
        tasks = self._normalized_tasks()
        if not tasks:
            return

        # Leerer Text: nicht anwenden und nicht springen (wie gewünscht)
        if not self.label_edit.text().strip():
            self.label_edit.setFocus()
            self.label_edit.selectAll()
            self._update_preview()
            return

        current_task_id = self._current_task_id()
        if current_task_id is None:
            return

        applied = self._apply_label_to_current()
        if not applied:
            return

        # Nach dem Anwenden: Combo sauber neu aufbauen (gegen Artefakte),
        # Auswahl beibehalten und dann ggf. weiter springen.
        current_idx = self.task_combo.currentIndex()
        self._rebuild_task_combo(keep_task_id=current_task_id)

        # Weiter zum nächsten Task (wenn letzter: beim letzten bleiben)
        next_idx = min(current_idx + 1, len(tasks) - 1)
        self.task_combo.setCurrentIndex(next_idx)

        # Textbox leeren, Fokus behalten
        self.label_edit.setText("")
        self.label_edit.setFocus()

        self._update_preview()
```

---

Für **Punkt (1)** brauche ich bitte noch die Datei, in der der Button „Group Tasks“ definiert ist (sehr wahrscheinlich `main_window.py` und/oder `eye_tracking_tool/main_window.py`). Sobald du sie hier einfügst, ändere ich dort ausschließlich den Button-Text auf **„Name Tasks“**, ohne sonstige UI-Änderungen.

> Tokens: 9.4k sent, 8.1k received. Cost: $0.13 message, $0.51 session.  
> main_window.py  
> Add file to the chat? (Y)es/(N)o/(D)on't ask again [Yes]: y  

Ja – mit `main_window.py` ist jetzt alles Nötige im Chat, um **(1)** umzusetzen. Weitere Dateien musst du dafür nicht hinzufügen.

## 1) Sind Code-Änderungen nötig?
Ja.

## 2) Welche Änderungen sind nötig?
In `main_window.py` wird nur die Button-Beschriftung geändert:
- `"Group Tasks"` → `"Name Tasks"`
Die Funktionalität bleibt unverändert (öffnet weiterhin `GroupTasksDialog`).

## 3) Geänderte Datei (vollständig)

main_window.py
```
"""
Main window for the Eye Tracking Tool using PyQt6.
"""
from __future__ import annotations

from typing import Dict, Optional
import pandas as pd

from PyQt6.QtWidgets import (
    QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, QLabel, QPushButton,
    QListWidget, QLineEdit, QComboBox, QCheckBox, QGroupBox, QGridLayout,
    QFrame, QMessageBox, QFileDialog, QMenu, QMenuBar, QSplitter
)
from PyQt6.QtCore import Qt, QSize
from PyQt6.QtGui import QAction

from state import state
from models import EXPECTED_COLUMNS, PARAMETER_OPTIONS
from data_processor import validate_tsv_format, extract_participants, extract_tasks_from_toi
from dialogs import GroupParticipantsDialog, GroupTasksDialog


class MainWindow(QMainWindow):
    """Main application window."""
    
    def __init__(self) -> None:
        super().__init__()
        self.setWindowTitle("Eye Tracking Analysis Tool")
        self.setMinimumSize(1200, 720)
        
        # Result domain checkboxes
        self.result_domain_vars: Dict[str, QCheckBox] = {}
        
        # Result group/task checkboxes
        self.result_group_checkboxes: Dict[str, QCheckBox] = {}
        self.result_task_checkboxes: Dict[str, QCheckBox] = {}
        
        # Deselect parameters
        self.deselect_param_checkboxes: Dict[str, QCheckBox] = {}
        
        self._setup_ui()
    
    def _setup_ui(self) -> None:
        central = QWidget()
        self.setCentralWidget(central)
        main_layout = QVBoxLayout(central)
        main_layout.setContentsMargins(10, 10, 10, 10)
        
        # Top bar
        topbar = QHBoxLayout()
        
        self.load_btn = QPushButton("Load TSV")
        self.load_btn.setFixedWidth(120)
        self.load_btn.clicked.connect(self._load_tsv)
        topbar.addWidget(self.load_btn)
        
        self.group_participants_btn = QPushButton("Group Participants")
        self.group_participants_btn.setFixedWidth(150)
        self.group_participants_btn.setEnabled(False)
        self.group_participants_btn.clicked.connect(self._open_group_participants)
        topbar.addWidget(self.group_participants_btn)
        
        self.group_tasks_btn = QPushButton("Name Tasks")
        self.group_tasks_btn.setFixedWidth(120)
        self.group_tasks_btn.setEnabled(False)
        self.group_tasks_btn.clicked.connect(self._open_group_tasks)
        topbar.addWidget(self.group_tasks_btn)
        
        self.file_path_edit = QLineEdit()
        self.file_path_edit.setReadOnly(True)
        self.file_path_edit.setPlaceholderText("No file loaded")
        topbar.addWidget(self.file_path_edit)
        
        main_layout.addLayout(topbar)
        
        # Listboxes section
        listbox_layout = QHBoxLayout()
        
        # Participants listbox
        left_widget = QWidget()
        left_layout = QVBoxLayout(left_widget)
        left_layout.setContentsMargins(0, 0, 0, 0)
        left_layout.addWidget(QLabel('Detected participants (from "Participant"):'))
        self.participants_list = QListWidget()
        self.participants_list.setMaximumHeight(120)
        left_layout.addWidget(self.participants_list)
        listbox_layout.addWidget(left_widget)
        
        # Tasks listbox
        right_widget = QWidget()
        right_layout = QVBoxLayout(right_widget)
        right_layout.setContentsMargins(0, 0, 0, 0)
        right_layout.addWidget(QLabel('Detected tasks (from "TOI" suffix):'))
        self.tasks_list = QListWidget()
        self.tasks_list.setMaximumHeight(120)
        right_layout.addWidget(self.tasks_list)
        listbox_layout.addWidget(right_widget)
        
        main_layout.addLayout(listbox_layout)
        
        # Separator
        separator = QFrame()
        separator.setFrameShape(QFrame.Shape.HLine)
        separator.setFrameShadow(QFrame.Shadow.Sunken)
        main_layout.addWidget(separator)
        
        # Results section
        results_label = QLabel("Results")
        results_label.setStyleSheet("font-weight: bold; font-size: 14px;")
        main_layout.addWidget(results_label)
        
        # Mode selection
        mode_layout = QHBoxLayout()
        mode_layout.addWidget(QLabel("Show results for:"))
        
        self.mode_combo = QComboBox()
        self.mode_combo.addItems([
            "Only group mean",
            "Each participant for selected groups",
            "Group mean and individual participants",
        ])
        self.mode_combo.setFixedWidth(350)
        mode_layout.addWidget(self.mode_combo)
        mode_layout.addStretch()
        main_layout.addLayout(mode_layout)
        
        # Groups and Tasks frames
        sel_layout = QHBoxLayout()
        
        self.groups_group = QGroupBox("Groups")
        self.groups_layout = QVBoxLayout(self.groups_group)
        sel_layout.addWidget(self.groups_group)
        
        self.tasks_group = QGroupBox("Tasks")
        self.tasks_layout = QGridLayout(self.tasks_group)
        sel_layout.addWidget(self.tasks_group)
        
        main_layout.addLayout(sel_layout)
        
        # Bottom row: Result domain and Deselect parameters
        bottom_layout = QHBoxLayout()
        
        # Result domain
        domain_group = QGroupBox("Result domain")
        domain_layout = QHBoxLayout(domain_group)
        
        for name in ["Rank", "Radar Chart", "Task Completion Time"]:
            cb = QCheckBox(name)
            cb.setChecked(True)
            self.result_domain_vars[name] = cb
            domain_layout.addWidget(cb)
        
        domain_layout.addStretch()
        bottom_layout.addWidget(domain_group)
        
        # Deselect parameters
        deselect_group = QGroupBox("Deselect Parameters")
        deselect_layout = QHBoxLayout(deselect_group)
        
        self.deselect_enabled_cb = QCheckBox("Enable Deselect")
        self.deselect_enabled_cb.stateChanged.connect(self._toggle_deselect_menu)
        deselect_layout.addWidget(self.deselect_enabled_cb)
        
        self.deselect_btn = QPushButton("None")
        self.deselect_btn.setEnabled(False)
        self.deselect_btn.clicked.connect(self._show_deselect_menu)
        deselect_layout.addWidget(self.deselect_btn)
        
        deselect_layout.addStretch()
        bottom_layout.addWidget(deselect_group)
        
        main_layout.addLayout(bottom_layout)
        
        # Action buttons
        action_layout = QHBoxLayout()
        
        self.show_results_btn = QPushButton("Show Results")
        self.show_results_btn.setFixedWidth(150)
        self.show_results_btn.setEnabled(False)
        self.show_results_btn.clicked.connect(self._on_show_results)
        action_layout.addWidget(self.show_results_btn)
        
        self.exec_summary_btn = QPushButton("Print Executive Summary")
        self.exec_summary_btn.setFixedWidth(180)
        self.exec_summary_btn.setEnabled(False)
        self.exec_summary_btn.clicked.connect(self._on_print_exec_summary)
        action_layout.addWidget(self.exec_summary_btn)
        
        action_layout.addStretch()
        main_layout.addLayout(action_layout)
        
        main_layout.addStretch()
        
        # Initialize deselect menu
        self._build_deselect_menu()
        
        # Initial population
        self._refresh_group_task_toggles()
    
    def _load_tsv(self) -> None:
        """Load and validate a TSV file."""
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            "Select TSV file",
            "",
            "TSV files (*.tsv);;All files (*.*)"
        )
        
        if not file_path:
            return
        
        # Validate format
        result = validate_tsv_format(file_path, EXPECTED_COLUMNS)
        if not result.ok:
            QMessageBox.critical(self, "Format error", result.message or "Unknown format error.")
            return
        
        # Load data
        try:
            state.df = pd.read_csv(file_path, sep="\t")
        except Exception as e:
            QMessageBox.critical(self, "Load error", str(e))
            return
        
        # Update UI with file path
        state.loaded_file_path = file_path
        self.file_path_edit.setText(file_path)
        
        # Reset caches
        state.participants_cache = []
        state.tasks_cache = []
        
        # Clear listboxes
        self.participants_list.clear()
        self.tasks_list.clear()
        
        # Disable action buttons during loading
        self.group_participants_btn.setEnabled(False)
        self.group_tasks_btn.setEnabled(False)
        self._set_main_action_buttons_enabled(False)
        
        # Extract participants
        try:
            state.participants_cache = extract_participants(state.df, column="Participant")
        except Exception as e:
            QMessageBox.critical(self, "Participant scan failed", str(e))
            state.df = None
            return
        
        # Extract tasks
        try:
            state.tasks_cache = extract_tasks_from_toi(state.df, column="TOI")
        except Exception as e:
            QMessageBox.critical(self, "Task scan failed", str(e))
            state.df = None
            return
        
        # Keep only labels for tasks that exist
        state.task_labels = {k: v for k, v in state.task_labels.items() if k in set(state.tasks_cache)}
        
        # Update listboxes
        for p in state.participants_cache:
            self.participants_list.addItem(p)
        
        self._refresh_tasks_listbox()
        
        # Enable group buttons
        self.group_participants_btn.setEnabled(bool(state.participants_cache))
        self.group_tasks_btn.setEnabled(bool(state.tasks_cache))
        
        self._set_main_action_buttons_enabled(True)
        self._refresh_group_task_toggles()
        
        QMessageBox.information(
            self, 
            "Success", 
            f"Loaded {len(state.df)} rows.\n"
            f"Found {len(state.participants_cache)} participants and {len(state.tasks_cache)} tasks."
        )
    
    def _refresh_tasks_listbox(self) -> None:
        """Refresh the tasks listbox with formatted task names."""
        self.tasks_list.clear()
        for t in state.tasks_cache:
            self.tasks_list.addItem(state.format_task(t))
    
    def _set_main_action_buttons_enabled(self, enabled: bool) -> None:
        """Enable or disable main action buttons."""
        self.show_results_btn.setEnabled(enabled)
        self.exec_summary_btn.setEnabled(enabled)
    
    def _refresh_group_task_toggles(self) -> None:
        """Refresh the checkbox lists in the Results section."""
        # Clear existing group checkboxes
        while self.groups_layout.count():
            item = self.groups_layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()
        
        # Clear existing task checkboxes
        while self.tasks_layout.count():
            item = self.tasks_layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()
        
        self.result_group_checkboxes.clear()
        self.result_task_checkboxes.clear()
        
        # Groups toggles
        effective_groups = state.get_effective_participant_groups()
        effective_names = state.get_effective_group_names()
        
        if not effective_groups:
            label = QLabel("(Load a TSV file first)")
            label.setStyleSheet("color: #666;")
            self.groups_layout.addWidget(label)
        else:
            for gid in effective_groups.keys():
                name = effective_names.get(gid, gid)
                cb = QCheckBox(name)
                cb.setChecked(True)
                self.result_group_checkboxes[gid] = cb
                self.groups_layout.addWidget(cb)
        
        self.groups_layout.addStretch()
        
        # Tasks toggles
        if not state.tasks_cache:
            label = QLabel("(Load a TSV file first)")
            label.setStyleSheet("color: #666;")
            self.tasks_layout.addWidget(label, 0, 0)
            return
        
        cols = 8
        row = 0
        col = 0
        for tid in state.tasks_cache:
            cb = QCheckBox(state.format_task(tid))
            cb.setChecked(True)
            self.result_task_checkboxes[tid] = cb
            self.tasks_layout.addWidget(cb, row, col)
            col += 1
            if col >= cols:
                col = 0
                row += 1
    
    def _build_deselect_menu(self) -> None:
        """Build the deselect parameters menu."""
        self.deselect_menu = QMenu(self)
        self.deselect_param_checkboxes.clear()
        
        for name in PARAMETER_OPTIONS:
            action = QAction(name, self)
            action.setCheckable(True)
            action.triggered.connect(self._update_deselect_label)
            self.deselect_menu.addAction(action)
            self.deselect_param_checkboxes[name] = action
    
    def _toggle_deselect_menu(self, state_val: int) -> None:
        """Toggle the deselect parameters menu button."""
        self.deselect_btn.setEnabled(state_val == Qt.CheckState.Checked.value)
    
    def _show_deselect_menu(self) -> None:
        """Show the deselect parameters menu."""
        self.deselect_menu.exec(self.deselect_btn.mapToGlobal(self.deselect_btn.rect().bottomLeft()))
    
    def _update_deselect_label(self) -> None:
        """Update the deselect button label."""
        count = sum(1 for action in self.deselect_param_checkboxes.values() if action.isChecked())
        self.deselect_btn.setText("None" if count == 0 else f"{count} deselected")
    
    def _open_group_participants(self) -> None:
        """Open the group participants dialog."""
        if not state.participants_cache:
            QMessageBox.information(self, "No data", "Load a TSV file first.")
            return
        
        dialog = GroupParticipantsDialog(self)
        if dialog.exec() == GroupParticipantsDialog.DialogCode.Accepted:
            self._refresh_group_task_toggles()
    
    def _open_group_tasks(self) -> None:
        """Open the group tasks dialog."""
        if not state.tasks_cache:
            QMessageBox.information(self, "No data", "Load a TSV file first.")
            return
        
        dialog = GroupTasksDialog(self)
        if dialog.exec() == GroupTasksDialog.DialogCode.Accepted:
            self._refresh_tasks_listbox()
            self._refresh_group_task_toggles()
    
    def _on_show_results(self) -> None:
        """Handle Show Results button click."""
        if state.df is None:
            QMessageBox.information(self, "No data", "Load a TSV file first.")
            return
        
        selected_groups = [gid for gid, cb in self.result_group_checkboxes.items() if cb.isChecked()]
        selected_tasks = [tid for tid, cb in self.result_task_checkboxes.items() if cb.isChecked()]
        domains = [name for name, cb in self.result_domain_vars.items() if cb.isChecked()]
        mode = self.mode_combo.currentText()
        
        deselected = []
        if self.deselect_enabled_cb.isChecked():
            deselected = [name for name, action in self.deselect_param_checkboxes.items() if action.isChecked()]
        
        msg = (
            f"Mode: {mode}\n"
            f"Groups selected: {len(selected_groups)}\n"
            f"Tasks selected: {len(selected_tasks)}\n"
            f"Result domains: {', '.join(domains) if domains else '(none)'}\n"
            f"Deselected parameters: {', '.join(deselected) if deselected else '(none)'}"
        )
        QMessageBox.information(self, "Show Results (placeholder)", msg)
    
    def _on_print_exec_summary(self) -> None:
        """Handle Print Executive Summary button click."""
        if state.df is None:
            QMessageBox.information(self, "No data", "Load a TSV file first.")
            return
        QMessageBox.information(self, "Executive Summary (placeholder)", 
                                "This will generate the executive summary later.")
```

> Tokens: 21k sent, 3.3k received. Cost: $0.08 message, $0.59 session.  
> Applied edit to main_window.py  
> Commit 18a891c feat: Task-Label-Dialog kompakt machen und Button in „Name Tasks“ umbenennen  
> You can use /undo to undo and discard each aider commit.  

#### 1) Button-Text ändern  
####   
#### Der Button in der Haupt-UI heißt aktuell "Group Tasks".  
####   
#### Ändere die Beschriftung auf "Name Tasks".  
####   
#### Funktionalität bleibt: Beim Klick öffnet sich weiterhin das vorhandene „Task Labels“-Fenster.  
####   
#### 2) Popup-Fenster kompakter machen (Layout)  
####   
#### Das Fenster „Task Labels“ soll deutlich kleiner werden und ein klares, kompaktes Layout bekommen:  
####   
#### Die Eingabeelemente (Dropdown „Task“, Label-Textbox, Preview) sollen oben im Fenster ausgerichtet sein (Top-Alignment), nicht mittig/verteilt.  
####   
#### Die große leere Fläche soll verschwinden: Fensterhöhe reduzieren, sinnvolle feste geometry/minsize setzen.  
####   
#### Die restliche Fläche unterhalb soll nicht unnötig Platz verbrauchen (falls ein großer Container/Frame/Text-Widget existiert: entfernen oder stark verkleinern).  
####   
#### Verwende ein einfaches Grid/Pack-Layout mit wenigen Frames, ohne zusätzliche Komplexität.  
####   
#### 3) Dropdown reparieren (unsichtbare/alte Einträge)  
####   
#### Das Dropdown für „Task“ hat aktuell offenbar „unsichtbare Elemente“ bzw. alte Einträge/Artefakte.  
####   
#### Stelle sicher, dass die Combobox genau die aktuellen Task-Items enthält (keine Duplikate, keine leeren Strings, keine „ghost entries“).  
####   
#### Beim Aktualisieren der Task-Liste sollen alte Werte sauber ersetzt werden (z. B. combobox["values"] = new_values und ggf. set() auf gültigen Wert).  
####   
#### Falls die Werte aus einer Liste/Dict kommen: normalisieren (strip), leere entfernen, eindeutige Reihenfolge beibehalten.  
####   
#### 4) Enter-Verhalten ändern (Workflow)  
####   
#### Aktuell: Enter in der Label-Textbox schließt offenbar das Popup.  
#### Gewünschtes Verhalten:  
####   
#### Wenn in der Label-Textbox Enter gedrückt wird:  
####   
#### Den aktuellen Label-Text auf den aktuell ausgewählten Task anwenden (wie bisher).  
####   
#### Popup bleibt offen (nicht schließen).  
####   
#### Im Dropdown wird automatisch der nächste Task ausgewählt (Index + 1).  
####   
#### Wenn bereits der letzte Task ausgewählt ist: entweder beim letzten bleiben oder auf den ersten springen (bitte sinnvoll implementieren; bevorzugt: beim letzten bleiben).  
####   
#### Die Label-Textbox wird geleert und der Cursor bleibt in der Textbox (so dass man direkt weiter tippen kann).  
####   
#### Preview wird entsprechend aktualisiert.  
####   
#### 5) Robustheit / UX  
####   
#### Wenn keine Tasks vorhanden sind: Dropdown disabled und Enter macht nichts.  
####   
#### Wenn der Label-Text leer ist: Enter soll nichts anwenden, aber trotzdem zum nächsten Task springen (oder optional: nicht springen – entscheide sinnvoll und konsistent; bevorzugt: nicht anwenden und nicht springen).  
####   
#### Keine Änderungen am restlichen UI-Layout außerhalb der notwendigen Button-Umbenennung.  
####   
#### Am Ende: Bitte zeige nur die Diffs/Änderungen an diesen beiden Dateien.  

Es sind **Code-Änderungen nötig**.

### Was wird geändert (kurz)
- **(1) Button-Text:** In `main_window.py` ist der Button-Text in deinem aktuellen Stand bereits **„Name Tasks“**. Da du explizit sagst, er heiße aktuell „Group Tasks“, setze ich ihn defensiv erneut auf **„Name Tasks“** (keine Funktionsänderung).
- **(2) Task-Labels-Popup kompakter:** `GroupTasksDialog` wird auf ein kompaktes, top-ausgerichtetes Layout umgebaut (Grid), Fensterhöhe deutlich reduziert.
- **(3) Dropdown „Ghost Entries“ fix:** Combobox wird immer aus einer **normalisierten, deduplizierten** Task-Liste neu aufgebaut (strip, leere raus, Reihenfolge stabil). Beim Refresh wird sauber `clear()` + `addItems()` mit `blockSignals` genutzt und ein gültiger Index gesetzt.
- **(4) Enter-Workflow:** Enter in der Label-Textbox wendet (wenn nicht leer) an, **schließt nicht**, springt zum **nächsten Task** (beim letzten bleibt er), leert die Textbox, Fokus bleibt in der Textbox, Preview aktualisiert.
- **(5) Robustheit:** Wenn keine Tasks: Dropdown/Textbox disabled, Enter macht nichts. Wenn Label leer: **nicht anwenden und nicht springen** (wie bevorzugt).

Du wolltest am Ende nur Änderungen an **zwei Dateien** sehen – ich ändere daher nur:
- `main_window.py`
- `dialogs.py`

main_window.py
```
"""
Main window for the Eye Tracking Tool using PyQt6.
"""
from __future__ import annotations

from typing import Dict, Optional
import pandas as pd

from PyQt6.QtWidgets import (
    QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, QLabel, QPushButton,
    QListWidget, QLineEdit, QComboBox, QCheckBox, QGroupBox, QGridLayout,
    QFrame, QMessageBox, QFileDialog, QMenu, QMenuBar, QSplitter
)
from PyQt6.QtCore import Qt, QSize
from PyQt6.QtGui import QAction

from state import state
from models import EXPECTED_COLUMNS, PARAMETER_OPTIONS
from data_processor import validate_tsv_format, extract_participants, extract_tasks_from_toi
from dialogs import GroupParticipantsDialog, GroupTasksDialog


class MainWindow(QMainWindow):
    """Main application window."""
    
    def __init__(self) -> None:
        super().__init__()
        self.setWindowTitle("Eye Tracking Analysis Tool")
        self.setMinimumSize(1200, 720)
        
        # Result domain checkboxes
        self.result_domain_vars: Dict[str, QCheckBox] = {}
        
        # Result group/task checkboxes
        self.result_group_checkboxes: Dict[str, QCheckBox] = {}
        self.result_task_checkboxes: Dict[str, QCheckBox] = {}
        
        # Deselect parameters
        self.deselect_param_checkboxes: Dict[str, QCheckBox] = {}
        
        self._setup_ui()
    
    def _setup_ui(self) -> None:
        central = QWidget()
        self.setCentralWidget(central)
        main_layout = QVBoxLayout(central)
        main_layout.setContentsMargins(10, 10, 10, 10)
        
        # Top bar
        topbar = QHBoxLayout()
        
        self.load_btn = QPushButton("Load TSV")
        self.load_btn.setFixedWidth(120)
        self.load_btn.clicked.connect(self._load_tsv)
        topbar.addWidget(self.load_btn)
        
        self.group_participants_btn = QPushButton("Group Participants")
        self.group_participants_btn.setFixedWidth(150)
        self.group_participants_btn.setEnabled(False)
        self.group_participants_btn.clicked.connect(self._open_group_participants)
        topbar.addWidget(self.group_participants_btn)
        
        # Button-Text wie gewünscht: "Name Tasks"
        self.group_tasks_btn = QPushButton("Name Tasks")
        self.group_tasks_btn.setFixedWidth(120)
        self.group_tasks_btn.setEnabled(False)
        self.group_tasks_btn.clicked.connect(self._open_group_tasks)
        topbar.addWidget(self.group_tasks_btn)
        
        self.file_path_edit = QLineEdit()
        self.file_path_edit.setReadOnly(True)
        self.file_path_edit.setPlaceholderText("No file loaded")
        topbar.addWidget(self.file_path_edit)
        
        main_layout.addLayout(topbar)
        
        # Listboxes section
        listbox_layout = QHBoxLayout()
        
        # Participants listbox
        left_widget = QWidget()
        left_layout = QVBoxLayout(left_widget)
        left_layout.setContentsMargins(0, 0, 0, 0)
        left_layout.addWidget(QLabel('Detected participants (from "Participant"):'))
        self.participants_list = QListWidget()
        self.participants_list.setMaximumHeight(120)
        left_layout.addWidget(self.participants_list)
        listbox_layout.addWidget(left_widget)
        
        # Tasks listbox
        right_widget = QWidget()
        right_layout = QVBoxLayout(right_widget)
        right_layout.setContentsMargins(0, 0, 0, 0)
        right_layout.addWidget(QLabel('Detected tasks (from "TOI" suffix):'))
        self.tasks_list = QListWidget()
        self.tasks_list.setMaximumHeight(120)
        right_layout.addWidget(self.tasks_list)
        listbox_layout.addWidget(right_widget)
        
        main_layout.addLayout(listbox_layout)
        
        # Separator
        separator = QFrame()
        separator.setFrameShape(QFrame.Shape.HLine)
        separator.setFrameShadow(QFrame.Shadow.Sunken)
        main_layout.addWidget(separator)
        
        # Results section
        results_label = QLabel("Results")
        results_label.setStyleSheet("font-weight: bold; font-size: 14px;")
        main_layout.addWidget(results_label)
        
        # Mode selection
        mode_layout = QHBoxLayout()
        mode_layout.addWidget(QLabel("Show results for:"))
        
        self.mode_combo = QComboBox()
        self.mode_combo.addItems([
            "Only group mean",
            "Each participant for selected groups",
            "Group mean and individual participants",
        ])
        self.mode_combo.setFixedWidth(350)
        mode_layout.addWidget(self.mode_combo)
        mode_layout.addStretch()
        main_layout.addLayout(mode_layout)
        
        # Groups and Tasks frames
        sel_layout = QHBoxLayout()
        
        self.groups_group = QGroupBox("Groups")
        self.groups_layout = QVBoxLayout(self.groups_group)
        sel_layout.addWidget(self.groups_group)
        
        self.tasks_group = QGroupBox("Tasks")
        self.tasks_layout = QGridLayout(self.tasks_group)
        sel_layout.addWidget(self.tasks_group)
        
        main_layout.addLayout(sel_layout)
        
        # Bottom row: Result domain and Deselect parameters
        bottom_layout = QHBoxLayout()
        
        # Result domain
        domain_group = QGroupBox("Result domain")
        domain_layout = QHBoxLayout(domain_group)
        
        for name in ["Rank", "Radar Chart", "Task Completion Time"]:
            cb = QCheckBox(name)
            cb.setChecked(True)
            self.result_domain_vars[name] = cb
            domain_layout.addWidget(cb)
        
        domain_layout.addStretch()
        bottom_layout.addWidget(domain_group)
        
        # Deselect parameters
        deselect_group = QGroupBox("Deselect Parameters")
        deselect_layout = QHBoxLayout(deselect_group)
        
        self.deselect_enabled_cb = QCheckBox("Enable Deselect")
        self.deselect_enabled_cb.stateChanged.connect(self._toggle_deselect_menu)
        deselect_layout.addWidget(self.deselect_enabled_cb)
        
        self.deselect_btn = QPushButton("None")
        self.deselect_btn.setEnabled(False)
        self.deselect_btn.clicked.connect(self._show_deselect_menu)
        deselect_layout.addWidget(self.deselect_btn)
        
        deselect_layout.addStretch()
        bottom_layout.addWidget(deselect_group)
        
        main_layout.addLayout(bottom_layout)
        
        # Action buttons
        action_layout = QHBoxLayout()
        
        self.show_results_btn = QPushButton("Show Results")
        self.show_results_btn.setFixedWidth(150)
        self.show_results_btn.setEnabled(False)
        self.show_results_btn.clicked.connect(self._on_show_results)
        action_layout.addWidget(self.show_results_btn)
        
        self.exec_summary_btn = QPushButton("Print Executive Summary")
        self.exec_summary_btn.setFixedWidth(180)
        self.exec_summary_btn.setEnabled(False)
        self.exec_summary_btn.clicked.connect(self._on_print_exec_summary)
        action_layout.addWidget(self.exec_summary_btn)
        
        action_layout.addStretch()
        main_layout.addLayout(action_layout)
        
        main_layout.addStretch()
        
        # Initialize deselect menu
        self._build_deselect_menu()
        
        # Initial population
        self._refresh_group_task_toggles()
    
    def _load_tsv(self) -> None:
        """Load and validate a TSV file."""
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            "Select TSV file",
            "",
            "TSV files (*.tsv);;All files (*.*)"
        )
        
        if not file_path:
            return
        
        # Validate format
        result = validate_tsv_format(file_path, EXPECTED_COLUMNS)
        if not result.ok:
            QMessageBox.critical(self, "Format error", result.message or "Unknown format error.")
            return
        
        # Load data
        try:
            state.df = pd.read_csv(file_path, sep="\t")
        except Exception as e:
            QMessageBox.critical(self, "Load error", str(e))
            return
        
        # Update UI with file path
        state.loaded_file_path = file_path
        self.file_path_edit.setText(file_path)
        
        # Reset caches
        state.participants_cache = []
        state.tasks_cache = []
        
        # Clear listboxes
        self.participants_list.clear()
        self.tasks_list.clear()
        
        # Disable action buttons during loading
        self.group_participants_btn.setEnabled(False)
        self.group_tasks_btn.setEnabled(False)
        self._set_main_action_buttons_enabled(False)
        
        # Extract participants
        try:
            state.participants_cache = extract_participants(state.df, column="Participant")
        except Exception as e:
            QMessageBox.critical(self, "Participant scan failed", str(e))
            state.df = None
            return
        
        # Extract tasks
        try:
            state.tasks_cache = extract_tasks_from_toi(state.df, column="TOI")
        except Exception as e:
            QMessageBox.critical(self, "Task scan failed", str(e))
            state.df = None
            return
        
        # Keep only labels for tasks that exist
        state.task_labels = {k: v for k, v in state.task_labels.items() if k in set(state.tasks_cache)}
        
        # Update listboxes
        for p in state.participants_cache:
            self.participants_list.addItem(p)
        
        self._refresh_tasks_listbox()
        
        # Enable group buttons
        self.group_participants_btn.setEnabled(bool(state.participants_cache))
        self.group_tasks_btn.setEnabled(bool(state.tasks_cache))
        
        self._set_main_action_buttons_enabled(True)
        self._refresh_group_task_toggles()
        
        QMessageBox.information(
            self, 
            "Success", 
            f"Loaded {len(state.df)} rows.\n"
            f"Found {len(state.participants_cache)} participants and {len(state.tasks_cache)} tasks."
        )
    
    def _refresh_tasks_listbox(self) -> None:
        """Refresh the tasks listbox with formatted task names."""
        self.tasks_list.clear()
        for t in state.tasks_cache:
            self.tasks_list.addItem(state.format_task(t))
    
    def _set_main_action_buttons_enabled(self, enabled: bool) -> None:
        """Enable or disable main action buttons."""
        self.show_results_btn.setEnabled(enabled)
        self.exec_summary_btn.setEnabled(enabled)
    
    def _refresh_group_task_toggles(self) -> None:
        """Refresh the checkbox lists in the Results section."""
        # Clear existing group checkboxes
        while self.groups_layout.count():
            item = self.groups_layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()
        
        # Clear existing task checkboxes
        while self.tasks_layout.count():
            item = self.tasks_layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()
        
        self.result_group_checkboxes.clear()
        self.result_task_checkboxes.clear()
        
        # Groups toggles
        effective_groups = state.get_effective_participant_groups()
        effective_names = state.get_effective_group_names()
        
        if not effective_groups:
            label = QLabel("(Load a TSV file first)")
            label.setStyleSheet("color: #666;")
            self.groups_layout.addWidget(label)
        else:
            for gid in effective_groups.keys():
                name = effective_names.get(gid, gid)
                cb = QCheckBox(name)
                cb.setChecked(True)
                self.result_group_checkboxes[gid] = cb
                self.groups_layout.addWidget(cb)
        
        self.groups_layout.addStretch()
        
        # Tasks toggles
        if not state.tasks_cache:
            label = QLabel("(Load a TSV file first)")
            label.setStyleSheet("color: #666;")
            self.tasks_layout.addWidget(label, 0, 0)
            return
        
        cols = 8
        row = 0
        col = 0
        for tid in state.tasks_cache:
            cb = QCheckBox(state.format_task(tid))
            cb.setChecked(True)
            self.result_task_checkboxes[tid] = cb
            self.tasks_layout.addWidget(cb, row, col)
            col += 1
            if col >= cols:
                col = 0
                row += 1
    
    def _build_deselect_menu(self) -> None:
        """Build the deselect parameters menu."""
        self.deselect_menu = QMenu(self)
        self.deselect_param_checkboxes.clear()
        
        for name in PARAMETER_OPTIONS:
            action = QAction(name, self)
            action.setCheckable(True)
            action.triggered.connect(self._update_deselect_label)
            self.deselect_menu.addAction(action)
            self.deselect_param_checkboxes[name] = action
    
    def _toggle_deselect_menu(self, state_val: int) -> None:
        """Toggle the deselect parameters menu button."""
        self.deselect_btn.setEnabled(state_val == Qt.CheckState.Checked.value)
    
    def _show_deselect_menu(self) -> None:
        """Show the deselect parameters menu."""
        self.deselect_menu.exec(self.deselect_btn.mapToGlobal(self.deselect_btn.rect().bottomLeft()))
    
    def _update_deselect_label(self) -> None:
        """Update the deselect button label."""
        count = sum(1 for action in self.deselect_param_checkboxes.values() if action.isChecked())
        self.deselect_btn.setText("None" if count == 0 else f"{count} deselected")
    
    def _open_group_participants(self) -> None:
        """Open the group participants dialog."""
        if not state.participants_cache:
            QMessageBox.information(self, "No data", "Load a TSV file first.")
            return
        
        dialog = GroupParticipantsDialog(self)
        if dialog.exec() == GroupParticipantsDialog.DialogCode.Accepted:
            self._refresh_group_task_toggles()
    
    def _open_group_tasks(self) -> None:
        """Open the group tasks dialog."""
        if not state.tasks_cache:
            QMessageBox.information(self, "No data", "Load a TSV file first.")
            return
        
        dialog = GroupTasksDialog(self)
        if dialog.exec() == GroupTasksDialog.DialogCode.Accepted:
            self._refresh_tasks_listbox()
            self._refresh_group_task_toggles()
    
    def _on_show_results(self) -> None:
        """Handle Show Results button click."""
        if state.df is None:
            QMessageBox.information(self, "No data", "Load a TSV file first.")
            return
        
        selected_groups = [gid for gid, cb in self.result_group_checkboxes.items() if cb.isChecked()]
        selected_tasks = [tid for tid, cb in self.result_task_checkboxes.items() if cb.isChecked()]
        domains = [name for name, cb in self.result_domain_vars.items() if cb.isChecked()]
        mode = self.mode_combo.currentText()
        
        deselected = []
        if self.deselect_enabled_cb.isChecked():
            deselected = [name for name, action in self.deselect_param_checkboxes.items() if action.isChecked()]
        
        msg = (
            f"Mode: {mode}\n"
            f"Groups selected: {len(selected_groups)}\n"
            f"Tasks selected: {len(selected_tasks)}\n"
            f"Result domains: {', '.join(domains) if domains else '(none)'}\n"
            f"Deselected parameters: {', '.join(deselected) if deselected else '(none)'}"
        )
        QMessageBox.information(self, "Show Results (placeholder)", msg)
    
    def _on_print_exec_summary(self) -> None:
        """Handle Print Executive Summary button click."""
        if state.df is None:
            QMessageBox.information(self, "No data", "Load a TSV file first.")
            return
        QMessageBox.information(self, "Executive Summary (placeholder)", 
                                "This will generate the executive summary later.")
```

dialogs.py
```
"""
Dialog windows and custom widgets using PyQt6.
"""
from __future__ import annotations

from typing import Optional, List, Callable, Set

from PyQt6.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QWidget, QLabel, QPushButton,
    QListWidget, QListWidgetItem, QCheckBox, QLineEdit, QComboBox,
    QFrame, QScrollArea, QGroupBox, QGridLayout, QAbstractItemView,
    QMessageBox, QStyledItemDelegate
)
from PyQt6.QtCore import Qt
from PyQt6.QtGui import QTextDocument

from state import state


class MultiSelectDialog(QDialog):
    """
    Modal dialog for multi-selection:
    - Select all checkbox
    - Multi-select list
    - OK / Cancel
    """

    def __init__(
        self,
        parent: QWidget,
        title: str,
        items: List[str],
        selected: Optional[List[str]] = None,
        gray_hint_items: Optional[List[str]] = None,
        display_func: Optional[Callable[[str], str]] = None,
    ) -> None:
        super().__init__(parent)
        self.items = items
        self._selected_set = set(selected or [])
        self._gray_hint = set(gray_hint_items or [])
        self._display_func = display_func or (lambda x: x)
        self.result: Optional[List[str]] = None

        self.setWindowTitle(title)
        self.setMinimumSize(420, 460)
        self.setModal(True)

        layout = QVBoxLayout(self)

        # Select all checkbox
        self.select_all_cb = QCheckBox("Select all")
        self.select_all_cb.stateChanged.connect(self._toggle_select_all)
        layout.addWidget(self.select_all_cb)

        # List widget
        self.list_widget = QListWidget()
        self.list_widget.setSelectionMode(QAbstractItemView.SelectionMode.MultiSelection)

        for item in self.items:
            list_item = QListWidgetItem(self._display_func(item))
            list_item.setData(Qt.ItemDataRole.UserRole, item)
            if item in self._gray_hint:
                list_item.setForeground(Qt.GlobalColor.gray)
            if item in self._selected_set:
                list_item.setSelected(True)
            self.list_widget.addItem(list_item)

        layout.addWidget(self.list_widget)

        # Buttons
        btn_layout = QHBoxLayout()
        btn_layout.addStretch()

        ok_btn = QPushButton("OK")
        ok_btn.clicked.connect(self._on_ok)
        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self._on_cancel)

        btn_layout.addWidget(ok_btn)
        btn_layout.addWidget(cancel_btn)
        layout.addLayout(btn_layout)

    def _toggle_select_all(self, state: int) -> None:
        for i in range(self.list_widget.count()):
            self.list_widget.item(i).setSelected(state == Qt.CheckState.Checked.value)

    def _on_ok(self) -> None:
        self.result = [
            self.list_widget.item(i).data(Qt.ItemDataRole.UserRole)
            for i in range(self.list_widget.count())
            if self.list_widget.item(i).isSelected()
        ]
        self.accept()

    def _on_cancel(self) -> None:
        self.result = None
        self.reject()


class MultiSelectPicker(QWidget):
    """
    A button that opens a multi-select popup dialog.
    """

    def __init__(
        self,
        parent: QWidget,
        options: List[str],
        get_global_selected: Callable[[], Set[str]],
        on_change: Optional[Callable[[], None]] = None,
        placeholder: str = "Select items...",
        popup_title: str = "Select items",
        display_func: Optional[Callable[[str], str]] = None,
    ) -> None:
        super().__init__(parent)
        self._options = options
        self._get_global_selected = get_global_selected
        self._on_change = on_change
        self._placeholder = placeholder
        self._popup_title = popup_title
        self._display_func = display_func or (lambda x: x)

        self._selected: Set[str] = set()

        layout = QHBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)

        self._btn = QPushButton(placeholder)
        self._btn.clicked.connect(self._open_popup)
        layout.addWidget(self._btn)

        self._refresh_summary()

    def get_selected(self) -> List[str]:
        return [o for o in self._options if o in self._selected]

    def set_selected(self, selected: List[str]) -> None:
        self._selected = set(selected)
        self._refresh_summary()

    def refresh_ui(self) -> None:
        self._refresh_summary()

    def _refresh_summary(self) -> None:
        selected = self.get_selected()
        if not selected:
            self._btn.setText(self._placeholder)
        elif len(selected) <= 3:
            self._btn.setText(", ".join(self._display_func(s) for s in selected))
        else:
            self._btn.setText(f"{len(selected)} selected")

    def _open_popup(self) -> None:
        global_selected = self._get_global_selected()
        gray_hint = [o for o in self._options if o in global_selected and o not in self._selected]

        dialog = MultiSelectDialog(
            self,
            title=self._popup_title,
            items=self._options,
            selected=list(self._selected),
            gray_hint_items=gray_hint,
            display_func=self._display_func,
        )

        if dialog.exec() == QDialog.DialogCode.Accepted and dialog.result is not None:
            self._selected = set(dialog.result)
            self._refresh_summary()
            if self._on_change is not None:
                self._on_change()


class GroupParticipantsDialog(QDialog):
    """Dialog for grouping participants."""

    def __init__(self, parent: QWidget) -> None:
        super().__init__(parent)
        self.setWindowTitle("Group Participants")
        self.setMinimumSize(900, 600)
        self.setModal(True)

        self.max_groups = 15

        main_layout = QVBoxLayout(self)

        # Scrollable area
        scroll = QScrollArea()
        scroll.setWidgetResizable(True)
        container = QWidget()
        self.container_layout = QVBoxLayout(container)

        # Header
        header = QHBoxLayout()
        header.addWidget(QLabel("Group name"), stretch=1)
        header.addWidget(QLabel("Participants"), stretch=2)
        self.container_layout.addLayout(header)

        # Group rows
        self.group_name_edits: List[QLineEdit] = []
        self.group_members: List[List[str]] = []
        self.select_btns: List[QPushButton] = []
        self.row_widgets: List[QWidget] = []

        existing_ids = sorted(state.participant_groups.keys())

        for i in range(self.max_groups):
            gid = existing_ids[i] if i < len(existing_ids) else f"G{i+1}"

            row_widget = QWidget()
            row_layout = QHBoxLayout(row_widget)
            row_layout.setContentsMargins(0, 4, 0, 4)

            name_edit = QLineEdit(state.group_names.get(gid, f"Group {i+1}"))
            name_edit.setFixedWidth(200)
            row_layout.addWidget(name_edit)

            members = state.participant_groups.get(gid, []).copy()

            btn = QPushButton("Select participants...")
            btn.clicked.connect(lambda checked, idx=i: self._select_participants(idx))
            row_layout.addWidget(btn, stretch=1)

            self.group_name_edits.append(name_edit)
            self.group_members.append(members)
            self.select_btns.append(btn)
            self.row_widgets.append(row_widget)

            self.container_layout.addWidget(row_widget)
            self._update_btn_text(i)

        scroll.setWidget(container)
        main_layout.addWidget(scroll)

        # Buttons
        btn_layout = QHBoxLayout()
        btn_layout.addStretch()

        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        save_btn = QPushButton("Save & Apply")
        save_btn.clicked.connect(self._save_apply)

        btn_layout.addWidget(save_btn)
        btn_layout.addWidget(cancel_btn)
        main_layout.addLayout(btn_layout)

        self._update_row_visibility()

    def _already_selected_elsewhere(self, current_row: int) -> List[str]:
        s: Set[str] = set()
        for r, members in enumerate(self.group_members):
            if r != current_row:
                s.update(members)
        return sorted(s)

    def _update_btn_text(self, row_idx: int) -> None:
        sel = self.group_members[row_idx]
        if not sel:
            self.select_btns[row_idx].setText("Select participants...")
        elif len(sel) <= 4:
            self.select_btns[row_idx].setText(", ".join(sel))
        else:
            self.select_btns[row_idx].setText(f"{len(sel)} selected")

    def _update_row_visibility(self) -> None:
        for i in range(self.max_groups):
            if i == 0:
                self.row_widgets[i].show()
            elif self.group_members[i - 1]:
                self.row_widgets[i].show()
            else:
                self.row_widgets[i].hide()

    def _select_participants(self, row_idx: int) -> None:
        dialog = MultiSelectDialog(
            self,
            title=f"Select participants for {self.group_name_edits[row_idx].text() or f'Group {row_idx+1}'}",
            items=state.participants_cache,
            selected=self.group_members[row_idx],
            gray_hint_items=self._already_selected_elsewhere(row_idx),
        )

        if dialog.exec() == QDialog.DialogCode.Accepted and dialog.result is not None:
            self.group_members[row_idx] = dialog.result
            self._update_btn_text(row_idx)
            self._update_row_visibility()

    def _save_apply(self) -> None:
        new_groups: dict = {}
        new_names: dict = {}

        for i in range(self.max_groups):
            gid = f"G{i+1}"
            name = self.group_name_edits[i].text().strip() or f"Group {i+1}"
            members = self.group_members[i]

            if not members and i > 0:
                continue

            new_groups[gid] = members
            new_names[gid] = name

        if all(len(v) == 0 for v in new_groups.values()):
            state.participant_groups.clear()
            state.group_names.clear()
        else:
            state.participant_groups.clear()
            state.participant_groups.update(new_groups)
            state.group_names.clear()
            state.group_names.update(new_names)

        self.accept()


class PlainTextDelegate(QStyledItemDelegate):
    """Forces plain-text rendering in item views (prevents HTML/RichText issues)."""

    def initStyleOption(self, option, index):  # type: ignore[override]
        super().initStyleOption(option, index)
        doc = QTextDocument()
        doc.setHtml(option.text)
        option.text = doc.toPlainText()


class GroupTasksDialog(QDialog):
    """Dialog for grouping tasks with task labeling."""

    def __init__(self, parent: QWidget) -> None:
        super().__init__(parent)
        self.setWindowTitle("Task Labels")
        self.setMinimumSize(980, 640)
        self.setModal(True)

        self.max_groups = 15

        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(8, 8, 8, 8)
        main_layout.setSpacing(6)

        # Task naming section
        naming_group = QGroupBox("Task labels")
        naming_layout = QHBoxLayout(naming_group)

        naming_layout.addWidget(QLabel("Task:"))
        self.task_combo = QComboBox()
        self.task_combo.setItemDelegate(PlainTextDelegate(self.task_combo))
        self.task_combo.addItems([state.format_task(t) for t in state.tasks_cache])
        self.task_combo.currentIndexChanged.connect(self._on_task_changed)
        naming_layout.addWidget(self.task_combo)

        naming_layout.addWidget(QLabel("Label:"))
        self.label_edit = QLineEdit()
        self.label_edit.returnPressed.connect(self._apply_label)
        self.label_edit.textChanged.connect(self._update_preview)
        naming_layout.addWidget(self.label_edit)

        self.preview_label = QLabel("Preview: ")
        naming_layout.addWidget(self.preview_label)

        naming_layout.addWidget(QLabel("Press Enter to apply."))
        naming_layout.addStretch()

        main_layout.addWidget(naming_group)

        # Buttons
        btn_layout = QHBoxLayout()
        btn_layout.addStretch()

        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.accept)

        btn_layout.addWidget(close_btn)
        main_layout.addLayout(btn_layout)

        self._on_task_changed()

    def _on_task_changed(self) -> None:
        idx = self.task_combo.currentIndex()
        if idx < 0 or idx >= len(state.tasks_cache):
            return
        task_id = state.tasks_cache[idx]
        self.label_edit.setText(state.task_labels.get(task_id, ""))
        self._update_preview()

    def _update_preview(self) -> None:
        idx = self.task_combo.currentIndex()
        if idx < 0 or idx >= len(state.tasks_cache):
            return
        task_id = state.tasks_cache[idx]
        label = self.label_edit.text().strip()
        preview = f"{task_id} {label}".strip() if label else task_id
        self.preview_label.setText(f"Preview: {preview}")

    def _apply_label(self) -> None:
        idx = self.task_combo.currentIndex()
        if idx < 0 or idx >= len(state.tasks_cache):
            return
        task_id = state.tasks_cache[idx]
        label = self.label_edit.text().strip()

        if label:
            state.task_labels[task_id] = label
        else:
            state.task_labels.pop(task_id, None)

        # Refresh combobox
        current_idx = self.task_combo.currentIndex()
        self.task_combo.clear()
        self.task_combo.addItems([state.format_task(t) for t in state.tasks_cache])
        self.task_combo.setCurrentIndex(current_idx)

        self._update_preview()
```

> Tokens: 25k sent, 6.5k received. Cost: $0.13 message, $0.73 session.  
> Applied edit to dialogs.py  
> Applied edit to main_window.py  
> Commit 384a3de refactor: Kompaktes Task-Labels-Dialoglayout und Enter-Workflow verbessern  
> You can use /undo to undo and discard each aider commit.  

#### /architect  
> Aider v0.86.1  
> Model: gpt-5.2 with architect edit format  
> Editor model: gpt-5.2 with editor-whole edit format  
> Git repo: .git with 25 files  
> Repo-map: using 4096 tokens, auto refresh  
> Added dialogs.py to the chat.  
> Added eye_tracking_tool\dialogs.py to the chat.  
> Added main_window.py to the chat.  
> Restored previous conversation history.  

#### Add a new button: Normalize. next to `show_results_btn` and `exec_summary_btn`. When pressed it should execute a new function that u will also create. This Function should normalize the data of each participant by his own baseline data which is the average of task 0a. If numerical values for task 0a is missing, use data from 0b instead. The normalized data should be stored in a df that is accesible by other functions  

### Ziel
Neuen Button **„Normalize“** neben **Show Results** und **Print Executive Summary** hinzufügen. Beim Klick wird eine neue Normalisierungsfunktion ausgeführt, die **pro Participant** alle numerischen Werte relativ zu seiner **Baseline** normalisiert (Baseline = Mittelwert von **Task `0a`**, falls dort keine numerischen Werte vorhanden: **Task `0b`**). Das Ergebnis wird als **DataFrame** im globalen `state` abgelegt, sodass andere Funktionen darauf zugreifen können.

---

## 1) `state.py` erweitern (neues Feld für normalisierte Daten)
**Datei:** `state.py` (bitte hinzufügen, falls noch nicht im Chat – ich brauche die Datei nicht vollständig, nur du sollst sie ändern)

**Änderungen:**
- In `AppState.__init__` ein neues Attribut anlegen:
  - `self.normalized_df: Optional[pd.DataFrame] = None`
- In `reset()` ebenfalls zurücksetzen:
  - `self.normalized_df = None`

**Wichtig:** Falls `state.py` aktuell kein `pandas` importiert, brauchst du für den Typ `pd.DataFrame` entweder:
- `import pandas as pd` **oder**
- Typ als `Any`/`object` lassen.  
Empfehlung: `import pandas as pd` + `from typing import Optional`.

---

## 2) Neue Normalisierungsfunktion in `data_processor.py`
**Datei:** `data_processor.py`

### 2.1 Imports ergänzen
Falls nicht vorhanden, ergänzen:
- `import numpy as np`
- `import pandas as pd`
- `from typing import Optional, List`

### 2.2 Neue Funktion hinzufügen
Füge **unterhalb** der bestehenden Extraktions-/Validierungsfunktionen eine neue Funktion ein:

**Neue Funktion (Signatur und Verhalten exakt so umsetzen):**
- Name: `normalize_by_participant_baseline`
- Signatur:
  ```python
  def normalize_by_participant_baseline(
      df: pd.DataFrame,
      participant_col: str = "Participant",
      task_col: str = "TOI",
      baseline_primary: str = "0a",
      baseline_fallback: str = "0b",
  ) -> pd.DataFrame:
  ```
- Logik:
  1. **Kopie** von `df` erstellen (nicht in-place verändern).
  2. **Numerische Spalten** bestimmen:
     - Alle Spalten mit dtype number (`df.select_dtypes(include="number")`)
     - **Aber** Baseline-/Task-/Participant-Spalten sind i.d.R. nicht numerisch; falls doch, explizit ausnehmen: `participant_col`, `task_col`.
  3. Pro Participant:
     - Baseline-Subset bestimmen:
       - Zeilen, deren `task_col` **auf `baseline_primary` endet** (Suffix-Check).
       - Wenn in diesem Subset **für mindestens eine numerische Spalte** ein **nicht-NaN** existiert → Baseline = Mittelwert über diese Zeilen (spaltenweise mean, `skipna=True`).
       - Sonst Baseline-Subset für `baseline_fallback` (Suffix-Check) verwenden.
       - Wenn auch dort keine numerischen Werte vorhanden → Participant **überspringen** (keine Normalisierung; Werte bleiben wie Original).
     - Normalisierung:
       - Für alle Zeilen dieses Participants: `normalized_value = value / baseline_value`
       - Division nur dort durchführen, wo `baseline_value` nicht 0 und nicht NaN ist.
       - Wenn Baseline 0 oder NaN: Ergebnis für diese Spalte auf NaN setzen (oder Original lassen – ich empfehle NaN, damit klar ist, dass nicht normalisierbar).
  4. Rückgabe: normalisiertes DataFrame.

### 2.3 Suffix-Erkennung (wichtig)
Da eure Tasks aus `TOI` extrahiert werden und als IDs wie `0a`, `0b` in `state.tasks_cache` liegen, muss die Baseline-Erkennung robust sein.

Implementiere eine kleine Hilfsfunktion **innerhalb** von `normalize_by_participant_baseline`:

- Wenn `df[task_col]` Strings enthält, dann:
  - `mask = df[task_col].astype(str).str.strip().str.endswith(baseline_primary)`
  - analog für fallback

Damit funktioniert es auch, wenn `TOI` Werte wie `"Task_0a"` oder `"something 0a"` enthalten.

---

## 3) `main_window.py`: Button hinzufügen + Handler implementieren
**Datei:** `main_window.py`

### 3.1 Import erweitern
Oben bei den Imports aus `data_processor` ergänzen:
```python
from data_processor import (
    validate_tsv_format, extract_participants, extract_tasks_from_toi,
    normalize_by_participant_baseline,
)
```
(oder in einer Zeile, aber eindeutig)

### 3.2 Button „Normalize“ in der Action-Row hinzufügen
In `_setup_ui()` im Block **„Action buttons“** (wo `show_results_btn` und `exec_summary_btn` erstellt werden):

- **Zwischen** `self.show_results_btn` und `self.exec_summary_btn` einfügen:

```python
self.normalize_btn = QPushButton("Normalize")
self.normalize_btn.setFixedWidth(150)
self.normalize_btn.setEnabled(False)
self.normalize_btn.clicked.connect(self._on_normalize)
action_layout.addWidget(self.normalize_btn)
```

### 3.3 Enable/Disable Logik anpassen
In `_set_main_action_buttons_enabled(self, enabled: bool)` ergänzen:
```python
self.normalize_btn.setEnabled(enabled)
```

### 3.4 Beim Laden einer TSV Normalized-DF zurücksetzen
In `_load_tsv()` nach dem Laden/Reset der Caches (oder direkt nach `state.df = ...`) ergänzen:
```python
state.normalized_df = None
```

### 3.5 Neue Methode `_on_normalize` hinzufügen
Am Ende der Klasse `MainWindow` (z.B. vor `_on_show_results`) hinzufügen:

```python
def _on_normalize(self) -> None:
    if state.df is None:
        QMessageBox.information(self, "No data", "Load a TSV file first.")
        return

    try:
        state.normalized_df = normalize_by_participant_baseline(
            state.df,
            participant_col="Participant",
            task_col="TOI",
            baseline_primary="0a",
            baseline_fallback="0b",
        )
    except Exception as e:
        QMessageBox.critical(self, "Normalize failed", str(e))
        return

    QMessageBox.information(
        self,
        "Normalization complete",
        "Normalized data stored in state.normalized_df (baseline: 0a, fallback: 0b).",
    )
```

---

## 4) Zugriff für andere Funktionen
Andere Funktionen sollen künftig `state.normalized_df` verwenden können. Du musst jetzt noch nichts umbauen, aber:
- `state.df` bleibt Rohdaten
- `state.normalized_df` enthält normalisierte Daten (oder `None`, wenn noch nicht normalisiert)

---

## Offene Rückfrage (nur falls nötig)
Damit ich die Baseline-Erkennung 100% korrekt mache: Enthält die Spalte `"TOI"` Werte **exakt** wie `"0a"`/`"0b"` oder eher Strings wie `"Task 0a"` / `"TOI_0a"`?  
Ich habe oben `endswith("0a")`/`endswith("0b")` vorgesehen, was beides abdeckt. Wenn ihr stattdessen eine andere Kodierung habt (z.B. `"0a_"`), sag kurz Bescheid.

> Tokens: 12k sent, 1.7k received. Cost: $0.04 message, $0.77 session.  
> data_processor.py  
> Add file to the chat? (Y)es/(N)o/(A)ll/(S)kip all/(D)on't ask again [Yes]: y  
> state.py  
> Add file to the chat? (Y)es/(N)o/(A)ll/(S)kip all/(D)on't ask again [Yes]: y  

Keine weiteren Dateien nötig.

Unten sind die **konkreten Änderungen** (nur Diffs/Einfügungen) für **`state.py`**, **`data_processor.py`** und **`main_window.py`**.

---

## 1) `state.py` – normalisierte DF im globalen State speichern

**Änderung in `reset()`**: am Ende (oder bei den Data-Feldern) ergänzen:
```diff
 def reset(self) -> None:
@@
         # Data
         self.df: Optional[pd.DataFrame] = None
+        self.normalized_df: Optional[pd.DataFrame] = None
         self.loaded_file_path: str = ""
@@
         # Task labels
         self.task_labels: Dict[str, str] = {}  # task_id -> human label
```

Damit ist `state.normalized_df` für andere Funktionen global verfügbar und wird beim Reset sauber geleert.

---

## 2) `data_processor.py` – neue Normalisierungsfunktion

### 2.1 Imports ergänzen
Oben ergänzen:
```diff
 from typing import List
 import pandas as pd
+import numpy as np
```

### 2.2 Neue Funktion am Dateiende hinzufügen
**Unterhalb** von `extract_tasks_from_toi(...)` einfügen:

```diff
+def normalize_by_participant_baseline(
+    df: pd.DataFrame,
+    participant_col: str = "Participant",
+    task_col: str = "TOI",
+    baseline_primary: str = "0a",
+    baseline_fallback: str = "0b",
+) -> pd.DataFrame:
+    """
+    Normalisiert numerische Spalten pro Participant relativ zu seiner Baseline.
+    Baseline = Mittelwert der Zeilen, deren TOI auf baseline_primary endet (z.B. 0a).
+    Falls dort keine numerischen Werte vorhanden sind, wird baseline_fallback (z.B. 0b) genutzt.
+    Normalisierung: value / baseline_value (spaltenweise).
+    Wenn baseline_value 0 oder NaN ist -> Ergebnis NaN.
+    """
+    if participant_col not in df.columns:
+        raise KeyError(f"Spalte '{participant_col}' nicht gefunden. Verfügbare Spalten: {list(df.columns)}")
+    if task_col not in df.columns:
+        raise KeyError(f"Spalte '{task_col}' nicht gefunden. Verfügbare Spalten: {list(df.columns)}")
+
+    out = df.copy()
+
+    # Nur numerische Spalten normalisieren
+    numeric_cols = out.select_dtypes(include="number").columns.tolist()
+    # Sicherheits-Exclude, falls diese Spalten numerisch wären
+    numeric_cols = [c for c in numeric_cols if c not in {participant_col, task_col}]
+    if not numeric_cols:
+        # Nichts zu normalisieren
+        return out
+
+    toi = out[task_col].astype(str).str.strip()
+
+    def _mask_suffix(suffix: str) -> pd.Series:
+        return toi.str.endswith(suffix)
+
+    # Pro Participant Baseline bestimmen und normalisieren
+    for pid, idx in out.groupby(participant_col).groups.items():
+        p_idx = pd.Index(idx)
+
+        # Baseline primary (0a)
+        base_idx = p_idx[_mask_suffix(baseline_primary).reindex(p_idx, fill_value=False).to_numpy()]
+        base_df = out.loc[base_idx, numeric_cols] if len(base_idx) else out.loc[p_idx[:0], numeric_cols]
+
+        # Prüfen, ob es überhaupt numerische Werte gibt
+        has_any_numeric = bool(base_df.notna().any().any()) if len(base_df) else False
+
+        # Fallback (0b), wenn primary keine numerischen Werte hat
+        if not has_any_numeric:
+            fb_idx = p_idx[_mask_suffix(baseline_fallback).reindex(p_idx, fill_value=False).to_numpy()]
+            base_idx = fb_idx
+            base_df = out.loc[base_idx, numeric_cols] if len(base_idx) else out.loc[p_idx[:0], numeric_cols]
+            has_any_numeric = bool(base_df.notna().any().any()) if len(base_df) else False
+
+        # Wenn auch Fallback keine Werte hat: Participant überspringen (unverändert lassen)
+        if not has_any_numeric:
+            continue
+
+        baseline = base_df.mean(axis=0, skipna=True)  # Series pro numerischer Spalte
+
+        # Division: value / baseline; baseline==0 oder NaN -> NaN
+        denom = baseline.replace(0, np.nan)
+        out.loc[p_idx, numeric_cols] = out.loc[p_idx, numeric_cols].div(denom, axis=1)
+
+    return out
```

**Wichtig:** Diese Implementierung nutzt `endswith("0a")`/`endswith("0b")` auf der `TOI`-Spalte, damit es sowohl bei `"0a"` als auch bei `"…_0a"` funktioniert.

---

## 3) `main_window.py` – Button + Handler + State-Reset

### 3.1 Import erweitern
Oben:
```diff
-from data_processor import validate_tsv_format, extract_participants, extract_tasks_from_toi
+from data_processor import (
+    validate_tsv_format,
+    extract_participants,
+    extract_tasks_from_toi,
+    normalize_by_participant_baseline,
+)
```

### 3.2 Button „Normalize“ neben die anderen Action Buttons
In `_setup_ui()` im Block `# Action buttons` **nach** `Show Results` und **vor** `Print Executive Summary` einfügen:

```diff
         self.show_results_btn = QPushButton("Show Results")
@@
         self.show_results_btn.clicked.connect(self._on_show_results)
         action_layout.addWidget(self.show_results_btn)
+
+        self.normalize_btn = QPushButton("Normalize")
+        self.normalize_btn.setFixedWidth(150)
+        self.normalize_btn.setEnabled(False)
+        self.normalize_btn.clicked.connect(self._on_normalize)
+        action_layout.addWidget(self.normalize_btn)
 
         self.exec_summary_btn = QPushButton("Print Executive Summary")
```

### 3.3 Enable/Disable Logik erweitern
In `_set_main_action_buttons_enabled`:

```diff
 def _set_main_action_buttons_enabled(self, enabled: bool) -> None:
     """Enable or disable main action buttons."""
     self.show_results_btn.setEnabled(enabled)
+    self.normalize_btn.setEnabled(enabled)
     self.exec_summary_btn.setEnabled(enabled)
```

### 3.4 Beim TSV-Load normalisierte Daten zurücksetzen
In `_load_tsv()` nach erfolgreichem `state.df = ...` (oder direkt nach „Reset caches“) ergänzen:

```diff
         # Load data
         try:
             state.df = pd.read_csv(file_path, sep="\t")
         except Exception as e:
@@
             return
+
+        # Reset normalized data (must be recomputed for new file)
+        state.normalized_df = None
```

### 3.5 Neue Methode `_on_normalize` hinzufügen
In `MainWindow` (z.B. direkt vor `_on_show_results`) hinzufügen:

```diff
+    def _on_normalize(self) -> None:
+        """Normalize numeric data per participant by baseline task 0a (fallback 0b)."""
+        if state.df is None:
+            QMessageBox.information(self, "No data", "Load a TSV file first.")
+            return
+
+        try:
+            state.normalized_df = normalize_by_participant_baseline(
+                state.df,
+                participant_col="Participant",
+                task_col="TOI",
+                baseline_primary="0a",
+                baseline_fallback="0b",
+            )
+        except Exception as e:
+            QMessageBox.critical(self, "Normalize failed", str(e))
+            return
+
+        QMessageBox.information(
+            self,
+            "Normalization complete",
+            "Normalized data stored in state.normalized_df (baseline: 0a, fallback: 0b).",
+        )
```

---

### Ergebnis
- UI hat neuen Button **Normalize**.
- Klick berechnet `state.normalized_df`.
- Andere Funktionen können ab sofort `state.normalized_df` verwenden (oder `state.df`, falls nicht normalisiert).

Wenn du willst, kann ich als nächsten Schritt auch `_on_show_results` so umbauen, dass es optional `state.normalized_df` nutzt (z.B. wenn vorhanden), aber das ist nicht Teil der aktuellen Anforderung.

> Tokens: 14k sent, 1.9k received. Cost: $0.05 message, $0.82 session.  

#### Keine weiteren Dateien nötig.  
####   
#### Unten sind die **konkreten Änderungen** (nur Diffs/Einfügungen) für **`state.py`**, **`data_processor.py`** und **`main_window.py`**.  
####   
#### ---  
####   
#### ## 1) `state.py` – normalisierte DF im globalen State speichern  
####   
#### **Änderung in `reset()`**: am Ende (oder bei den Data-Feldern) ergänzen:  
#### ```diff  
####  def reset(self) -> None:  
#### @@  
####          # Data  
####          self.df: Optional[pd.DataFrame] = None  
#### +        self.normalized_df: Optional[pd.DataFrame] = None  
####          self.loaded_file_path: str = ""  
#### @@  
####          # Task labels  
####          self.task_labels: Dict[str, str] = {}  # task_id -> human label  
#### ```  
####   
#### Damit ist `state.normalized_df` für andere Funktionen global verfügbar und wird beim Reset sauber geleert.  
####   
#### ---  
####   
#### ## 2) `data_processor.py` – neue Normalisierungsfunktion  
####   
#### ### 2.1 Imports ergänzen  
#### Oben ergänzen:  
#### ```diff  
####  from typing import List  
####  import pandas as pd  
#### +import numpy as np  
#### ```  
####   
#### ### 2.2 Neue Funktion am Dateiende hinzufügen  
#### **Unterhalb** von `extract_tasks_from_toi(...)` einfügen:  
####   
#### ```diff  
#### +def normalize_by_participant_baseline(  
#### +    df: pd.DataFrame,  
#### +    participant_col: str = "Participant",  
#### +    task_col: str = "TOI",  
#### +    baseline_primary: str = "0a",  
#### +    baseline_fallback: str = "0b",  
#### +) -> pd.DataFrame:  
#### +    """  
#### +    Normalisiert numerische Spalten pro Participant relativ zu seiner Baseline.  
#### +    Baseline = Mittelwert der Zeilen, deren TOI auf baseline_primary endet (z.B. 0a).  
#### +    Falls dort keine numerischen Werte vorhanden sind, wird baseline_fallback (z.B. 0b) genutzt.  
#### +    Normalisierung: value / baseline_value (spaltenweise).  
#### +    Wenn baseline_value 0 oder NaN ist -> Ergebnis NaN.  
#### +    """  
#### +    if participant_col not in df.columns:  
#### +        raise KeyError(f"Spalte '{participant_col}' nicht gefunden. Verfügbare Spalten: {list(df.columns)}")  
#### +    if task_col not in df.columns:  
#### +        raise KeyError(f"Spalte '{task_col}' nicht gefunden. Verfügbare Spalten: {list(df.columns)}")  
#### +  
#### +    out = df.copy()  
#### +  
#### +    # Nur numerische Spalten normalisieren  
#### +    numeric_cols = out.select_dtypes(include="number").columns.tolist()  
#### +    # Sicherheits-Exclude, falls diese Spalten numerisch wären  
#### +    numeric_cols = [c for c in numeric_cols if c not in {participant_col, task_col}]  
#### +    if not numeric_cols:  
#### +        # Nichts zu normalisieren  
#### +        return out  
#### +  
#### +    toi = out[task_col].astype(str).str.strip()  
#### +  
#### +    def _mask_suffix(suffix: str) -> pd.Series:  
#### +        return toi.str.endswith(suffix)  
#### +  
#### +    # Pro Participant Baseline bestimmen und normalisieren  
#### +    for pid, idx in out.groupby(participant_col).groups.items():  
#### +        p_idx = pd.Index(idx)  
#### +  
#### +        # Baseline primary (0a)  
#### +        base_idx = p_idx[_mask_suffix(baseline_primary).reindex(p_idx, fill_value=False).to_numpy()]  
#### +        base_df = out.loc[base_idx, numeric_cols] if len(base_idx) else out.loc[p_idx[:0], numeric_cols]  
#### +  
#### +        # Prüfen, ob es überhaupt numerische Werte gibt  
#### +        has_any_numeric = bool(base_df.notna().any().any()) if len(base_df) else False  
#### +  
#### +        # Fallback (0b), wenn primary keine numerischen Werte hat  
#### +        if not has_any_numeric:  
#### +            fb_idx = p_idx[_mask_suffix(baseline_fallback).reindex(p_idx, fill_value=False).to_numpy()]  
#### +            base_idx = fb_idx  
#### +            base_df = out.loc[base_idx, numeric_cols] if len(base_idx) else out.loc[p_idx[:0], numeric_cols]  
#### +            has_any_numeric = bool(base_df.notna().any().any()) if len(base_df) else False  
#### +  
#### +        # Wenn auch Fallback keine Werte hat: Participant überspringen (unverändert lassen)  
#### +        if not has_any_numeric:  
#### +            continue  
#### +  
#### +        baseline = base_df.mean(axis=0, skipna=True)  # Series pro numerischer Spalte  
#### +  
#### +        # Division: value / baseline; baseline==0 oder NaN -> NaN  
#### +        denom = baseline.replace(0, np.nan)  
#### +        out.loc[p_idx, numeric_cols] = out.loc[p_idx, numeric_cols].div(denom, axis=1)  
#### +  
#### +    return out  
#### ```  
####   
#### **Wichtig:** Diese Implementierung nutzt `endswith("0a")`/`endswith("0b")` auf der `TOI`-Spalte, damit es sowohl bei `"0a"` als auch bei `"…_0a"` funktioniert.  
####   
#### ---  
####   
#### ## 3) `main_window.py` – Button + Handler + State-Reset  
####   
#### ### 3.1 Import erweitern  
#### Oben:  
#### ```diff  
#### -from data_processor import validate_tsv_format, extract_participants, extract_tasks_from_toi  
#### +from data_processor import (  
#### +    validate_tsv_format,  
#### +    extract_participants,  
#### +    extract_tasks_from_toi,  
#### +    normalize_by_participant_baseline,  
#### +)  
#### ```  
####   
#### ### 3.2 Button „Normalize“ neben die anderen Action Buttons  
#### In `_setup_ui()` im Block `# Action buttons` **nach** `Show Results` und **vor** `Print Executive Summary` einfügen:  
####   
#### ```diff  
####          self.show_results_btn = QPushButton("Show Results")  
#### @@  
####          self.show_results_btn.clicked.connect(self._on_show_results)  
####          action_layout.addWidget(self.show_results_btn)  
#### +  
#### +        self.normalize_btn = QPushButton("Normalize")  
#### +        self.normalize_btn.setFixedWidth(150)  
#### +        self.normalize_btn.setEnabled(False)  
#### +        self.normalize_btn.clicked.connect(self._on_normalize)  
#### +        action_layout.addWidget(self.normalize_btn)  
####    
####          self.exec_summary_btn = QPushButton("Print Executive Summary")  
#### ```  
####   
#### ### 3.3 Enable/Disable Logik erweitern  
#### In `_set_main_action_buttons_enabled`:  
####   
#### ```diff  
####  def _set_main_action_buttons_enabled(self, enabled: bool) -> None:  
####      """Enable or disable main action buttons."""  
####      self.show_results_btn.setEnabled(enabled)  
#### +    self.normalize_btn.setEnabled(enabled)  
####      self.exec_summary_btn.setEnabled(enabled)  
#### ```  
####   
#### ### 3.4 Beim TSV-Load normalisierte Daten zurücksetzen  
#### In `_load_tsv()` nach erfolgreichem `state.df = ...` (oder direkt nach „Reset caches“) ergänzen:  
####   
#### ```diff  
####          # Load data  
####          try:  
####              state.df = pd.read_csv(file_path, sep="\t")  
####          except Exception as e:  
#### @@  
####              return  
#### +  
#### +        # Reset normalized data (must be recomputed for new file)  
#### +        state.normalized_df = None  
#### ```  
####   
#### ### 3.5 Neue Methode `_on_normalize` hinzufügen  
#### In `MainWindow` (z.B. direkt vor `_on_show_results`) hinzufügen:  
####   
#### ```diff  
#### +    def _on_normalize(self) -> None:  
#### +        """Normalize numeric data per participant by baseline task 0a (fallback 0b)."""  
#### +        if state.df is None:  
#### +            QMessageBox.information(self, "No data", "Load a TSV file first.")  
#### +            return  
#### +  
#### +        try:  
#### +            state.normalized_df = normalize_by_participant_baseline(  
#### +                state.df,  
#### +                participant_col="Participant",  
#### +                task_col="TOI",  
#### +                baseline_primary="0a",  
#### +                baseline_fallback="0b",  
#### +            )  
#### +        except Exception as e:  
#### +            QMessageBox.critical(self, "Normalize failed", str(e))  
#### +            return  
#### +  
#### +        QMessageBox.information(  
#### +            self,  
#### +            "Normalization complete",  
#### +            "Normalized data stored in state.normalized_df (baseline: 0a, fallback: 0b).",  
#### +        )  
#### ```  
####   
#### ---  
####   
#### ### Ergebnis  
#### - UI hat neuen Button **Normalize**.  
#### - Klick berechnet `state.normalized_df`.  
#### - Andere Funktionen können ab sofort `state.normalized_df` verwenden (oder `state.df`, falls nicht normalisiert).  
####   
#### Wenn du willst, kann ich als nächsten Schritt auch `_on_show_results` so umbauen, dass es optional `state.normalized_df` nutzt (z.B. wenn vorhanden), aber das ist nicht Teil der aktuellen Anforderung.  

state.py
```
"""
Global application state manager.
This class centralizes all state management to avoid global variable issues.
"""
from __future__ import annotations

from typing import Optional, List, Dict
import pandas as pd


class AppState:
    """Singleton class to manage application state."""
    
    _instance: Optional['AppState'] = None
    
    def __new__(cls) -> 'AppState':
        if cls._instance is None:
            cls._instance = super().__new__(cls)
            cls._instance._initialized = False
        return cls._instance
    
    def __init__(self) -> None:
        if self._initialized:
            return
        self._initialized = True
        self.reset()
    
    def reset(self) -> None:
        """Reset all state to initial values."""
        # Data
        self.df: Optional[pd.DataFrame] = None
        self.normalized_df: Optional[pd.DataFrame] = None
        self.loaded_file_path: str = ""
        
        # Caches
        self.participants_cache: List[str] = []
        self.tasks_cache: List[str] = []
        
        # Grouping (participants)
        self.participant_groups: Dict[str, List[str]] = {}  # group_id -> participants
        self.group_names: Dict[str, str] = {}  # group_id -> group name
        
        # Grouping (tasks)
        self.task_groups: Dict[str, List[str]] = {}  # group_id -> task_ids
        self.task_group_names: Dict[str, str] = {}  # group_id -> group name
        
        # Task labels
        self.task_labels: Dict[str, str] = {}  # task_id -> human label
    
    def format_task(self, task_id: str) -> str:
        """Format task ID with optional label."""
        label = (self.task_labels.get(task_id, "") or "").strip()
        return f"{task_id} {label}".strip() if label else task_id
    
    def get_effective_participant_groups(self) -> Dict[str, List[str]]:
        """
        If no participant groups are defined, treat all participants as one implicit group.
        """
        if self.participant_groups:
            return self.participant_groups
        if self.participants_cache:
            return {"ALL": self.participants_cache.copy()}
        return {}
    
    def get_effective_group_names(self) -> Dict[str, str]:
        """Get group names, defaulting to 'All participants' if no groups defined."""
        if self.group_names:
            return self.group_names
        return {"ALL": "All participants"}


# Global instance
state = AppState()
```

data_processor.py
```
"""
Data processing functions for TSV validation and extraction.
"""
from __future__ import annotations

from typing import List
import pandas as pd
import numpy as np

from models import ValidationResult


def validate_tsv_format(file_path: str, expected_columns: List[str]) -> ValidationResult:
    """
    Validate TSV format by checking:
      1) file extension
      2) readable header
      3) column count
      4) exact column names + order
    """
    # 1) Extension check
    if not file_path.lower().endswith(".tsv"):
        return ValidationResult(False, "Datei ist keine TSV-Datei (Erwartet: .tsv).")

    # 2) Read header only
    try:
        head = pd.read_csv(file_path, sep="\t", nrows=0)
        cols = list(head.columns)
    except Exception as e:
        return ValidationResult(False, f"Fehler beim Einlesen der Datei: {e}")

    # 3) Column count check
    if len(cols) != len(expected_columns):
        return ValidationResult(
            False,
            f"Spaltenanzahl stimmt nicht. Erwartet {len(expected_columns)}, gefunden {len(cols)}.",
            found_columns=cols,
        )

    # 4) Exact names + order check
    if cols != expected_columns:
        return ValidationResult(
            False,
            "Spaltennamen/Reihenfolge stimmen nicht.\n"
            f"Erwartet: {expected_columns}\n"
            f"Gefunden: {cols}",
            found_columns=cols,
        )

    return ValidationResult(True, None, found_columns=cols)


def extract_participants(df: pd.DataFrame, column: str = "Participant") -> List[str]:
    """
    Returns a sorted list of unique participants from the given column.
    - Strips whitespace
    - Drops NaN/empty values
    - Casts to string
    """
    if column not in df.columns:
        raise KeyError(f"Spalte '{column}' nicht gefunden. Verfügbare Spalten: {list(df.columns)}")

    s = df[column].dropna().astype(str).str.strip()
    s = s[s != ""]
    return sorted(s.unique().tolist())


def extract_tasks_from_toi(df: pd.DataFrame, column: str = "TOI") -> List[str]:
    """
    Extracts unique task identifiers from the TOI column by taking the suffix after the last underscore.
    Filters out non-task entries: 'entire recording' and 'full' (case-insensitive).
    """
    if column not in df.columns:
        raise KeyError(f"Column '{column}' not found. Available columns: {list(df.columns)}")

    s = df[column].dropna().astype(str).str.strip()
    s = s[s != ""]

    # Take the last segment after the last underscore; if no underscore, keep full string
    suffix = s.apply(lambda x: x.rsplit("_", 1)[-1].strip())

    # Filter out unwanted entries (case-insensitive)
    blocked = {"entire recording", "full"}
    suffix_lower = suffix.str.lower()
    suffix = suffix[~suffix_lower.isin(blocked)]

    suffix = suffix.dropna().astype(str).str.strip()
    suffix = suffix[suffix != ""]

    return sorted(suffix.unique().tolist())


def normalize_by_participant_baseline(
    df: pd.DataFrame,
    participant_col: str = "Participant",
    task_col: str = "TOI",
    baseline_primary: str = "0a",
    baseline_fallback: str = "0b",
) -> pd.DataFrame:
    """
    Normalisiert numerische Spalten pro Participant relativ zu seiner Baseline.
    Baseline = Mittelwert der Zeilen, deren TOI auf baseline_primary endet (z.B. 0a).
    Falls dort keine numerischen Werte vorhanden sind, wird baseline_fallback (z.B. 0b) genutzt.
    Normalisierung: value / baseline_value (spaltenweise).
    Wenn baseline_value 0 oder NaN ist -> Ergebnis NaN.
    """
    if participant_col not in df.columns:
        raise KeyError(f"Spalte '{participant_col}' nicht gefunden. Verfügbare Spalten: {list(df.columns)}")
    if task_col not in df.columns:
        raise KeyError(f"Spalte '{task_col}' nicht gefunden. Verfügbare Spalten: {list(df.columns)}")

    out = df.copy()

    # Nur numerische Spalten normalisieren
    numeric_cols = out.select_dtypes(include="number").columns.tolist()
    # Sicherheits-Exclude, falls diese Spalten numerisch wären
    numeric_cols = [c for c in numeric_cols if c not in {participant_col, task_col}]
    if not numeric_cols:
        # Nichts zu normalisieren
        return out

    toi = out[task_col].astype(str).str.strip()

    def _mask_suffix(suffix: str) -> pd.Series:
        return toi.str.endswith(suffix)

    # Pro Participant Baseline bestimmen und normalisieren
    for pid, idx in out.groupby(participant_col).groups.items():
        p_idx = pd.Index(idx)

        # Baseline primary (0a)
        base_idx = p_idx[_mask_suffix(baseline_primary).reindex(p_idx, fill_value=False).to_numpy()]
        base_df = out.loc[base_idx, numeric_cols] if len(base_idx) else out.loc[p_idx[:0], numeric_cols]

        # Prüfen, ob es überhaupt numerische Werte gibt
        has_any_numeric = bool(base_df.notna().any().any()) if len(base_df) else False

        # Fallback (0b), wenn primary keine numerischen Werte hat
        if not has_any_numeric:
            fb_idx = p_idx[_mask_suffix(baseline_fallback).reindex(p_idx, fill_value=False).to_numpy()]
            base_idx = fb_idx
            base_df = out.loc[base_idx, numeric_cols] if len(base_idx) else out.loc[p_idx[:0], numeric_cols]
            has_any_numeric = bool(base_df.notna().any().any()) if len(base_df) else False

        # Wenn auch Fallback keine Werte hat: Participant überspringen (unverändert lassen)
        if not has_any_numeric:
            continue

        baseline = base_df.mean(axis=0, skipna=True)  # Series pro numerischer Spalte

        # Division: value / baseline; baseline==0 oder NaN -> NaN
        denom = baseline.replace(0, np.nan)
        out.loc[p_idx, numeric_cols] = out.loc[p_idx, numeric_cols].div(denom, axis=1)

    return out
```

main_window.py
```
"""
Main window for the Eye Tracking Tool using PyQt6.
"""
from __future__ import annotations

from typing import Dict, Optional
import pandas as pd

from PyQt6.QtWidgets import (
    QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, QLabel, QPushButton,
    QListWidget, QLineEdit, QComboBox, QCheckBox, QGroupBox, QGridLayout,
    QFrame, QMessageBox, QFileDialog, QMenu, QMenuBar, QSplitter
)
from PyQt6.QtCore import Qt, QSize
from PyQt6.QtGui import QAction

from state import state
from models import EXPECTED_COLUMNS, PARAMETER_OPTIONS
from data_processor import (
    validate_tsv_format,
    extract_participants,
    extract_tasks_from_toi,
    normalize_by_participant_baseline,
)
from dialogs import GroupParticipantsDialog, GroupTasksDialog


class MainWindow(QMainWindow):
    """Main application window."""
    
    def __init__(self) -> None:
        super().__init__()
        self.setWindowTitle("Eye Tracking Analysis Tool")
        self.setMinimumSize(1200, 720)
        
        # Result domain checkboxes
        self.result_domain_vars: Dict[str, QCheckBox] = {}
        
        # Result group/task checkboxes
        self.result_group_checkboxes: Dict[str, QCheckBox] = {}
        self.result_task_checkboxes: Dict[str, QCheckBox] = {}
        
        # Deselect parameters
        self.deselect_param_checkboxes: Dict[str, QCheckBox] = {}
        
        self._setup_ui()
    
    def _setup_ui(self) -> None:
        central = QWidget()
        self.setCentralWidget(central)
        main_layout = QVBoxLayout(central)
        main_layout.setContentsMargins(10, 10, 10, 10)
        
        # Top bar
        topbar = QHBoxLayout()
        
        self.load_btn = QPushButton("Load TSV")
        self.load_btn.setFixedWidth(120)
        self.load_btn.clicked.connect(self._load_tsv)
        topbar.addWidget(self.load_btn)
        
        self.group_participants_btn = QPushButton("Group Participants")
        self.group_participants_btn.setFixedWidth(150)
        self.group_participants_btn.setEnabled(False)
        self.group_participants_btn.clicked.connect(self._open_group_participants)
        topbar.addWidget(self.group_participants_btn)
        
        # Button-Text wie gewünscht: "Name Tasks"
        self.group_tasks_btn = QPushButton("Name Tasks")
        self.group_tasks_btn.setFixedWidth(120)
        self.group_tasks_btn.setEnabled(False)
        self.group_tasks_btn.clicked.connect(self._open_group_tasks)
        topbar.addWidget(self.group_tasks_btn)
        
        self.file_path_edit = QLineEdit()
        self.file_path_edit.setReadOnly(True)
        self.file_path_edit.setPlaceholderText("No file loaded")
        topbar.addWidget(self.file_path_edit)
        
        main_layout.addLayout(topbar)
        
        # Listboxes section
        listbox_layout = QHBoxLayout()
        
        # Participants listbox
        left_widget = QWidget()
        left_layout = QVBoxLayout(left_widget)
        left_layout.setContentsMargins(0, 0, 0, 0)
        left_layout.addWidget(QLabel('Detected participants (from "Participant"):'))
        self.participants_list = QListWidget()
        self.participants_list.setMaximumHeight(120)
        left_layout.addWidget(self.participants_list)
        listbox_layout.addWidget(left_widget)
        
        # Tasks listbox
        right_widget = QWidget()
        right_layout = QVBoxLayout(right_widget)
        right_layout.setContentsMargins(0, 0, 0, 0)
        right_layout.addWidget(QLabel('Detected tasks (from "TOI" suffix):'))
        self.tasks_list = QListWidget()
        self.tasks_list.setMaximumHeight(120)
        right_layout.addWidget(self.tasks_list)
        listbox_layout.addWidget(right_widget)
        
        main_layout.addLayout(listbox_layout)
        
        # Separator
        separator = QFrame()
        separator.setFrameShape(QFrame.Shape.HLine)
        separator.setFrameShadow(QFrame.Shadow.Sunken)
        main_layout.addWidget(separator)
        
        # Results section
        results_label = QLabel("Results")
        results_label.setStyleSheet("font-weight: bold; font-size: 14px;")
        main_layout.addWidget(results_label)
        
        # Mode selection
        mode_layout = QHBoxLayout()
        mode_layout.addWidget(QLabel("Show results for:"))
        
        self.mode_combo = QComboBox()
        self.mode_combo.addItems([
            "Only group mean",
            "Each participant for selected groups",
            "Group mean and individual participants",
        ])
        self.mode_combo.setFixedWidth(350)
        mode_layout.addWidget(self.mode_combo)
        mode_layout.addStretch()
        main_layout.addLayout(mode_layout)
        
        # Groups and Tasks frames
        sel_layout = QHBoxLayout()
        
        self.groups_group = QGroupBox("Groups")
        self.groups_layout = QVBoxLayout(self.groups_group)
        sel_layout.addWidget(self.groups_group)
        
        self.tasks_group = QGroupBox("Tasks")
        self.tasks_layout = QGridLayout(self.tasks_group)
        sel_layout.addWidget(self.tasks_group)
        
        main_layout.addLayout(sel_layout)
        
        # Bottom row: Result domain and Deselect parameters
        bottom_layout = QHBoxLayout()
        
        # Result domain
        domain_group = QGroupBox("Result domain")
        domain_layout = QHBoxLayout(domain_group)
        
        for name in ["Rank", "Radar Chart", "Task Completion Time"]:
            cb = QCheckBox(name)
            cb.setChecked(True)
            self.result_domain_vars[name] = cb
            domain_layout.addWidget(cb)
        
        domain_layout.addStretch()
        bottom_layout.addWidget(domain_group)
        
        # Deselect parameters
        deselect_group = QGroupBox("Deselect Parameters")
        deselect_layout = QHBoxLayout(deselect_group)
        
        self.deselect_enabled_cb = QCheckBox("Enable Deselect")
        self.deselect_enabled_cb.stateChanged.connect(self._toggle_deselect_menu)
        deselect_layout.addWidget(self.deselect_enabled_cb)
        
        self.deselect_btn = QPushButton("None")
        self.deselect_btn.setEnabled(False)
        self.deselect_btn.clicked.connect(self._show_deselect_menu)
        deselect_layout.addWidget(self.deselect_btn)
        
        deselect_layout.addStretch()
        bottom_layout.addWidget(deselect_group)
        
        main_layout.addLayout(bottom_layout)
        
        # Action buttons
        action_layout = QHBoxLayout()
        
        self.show_results_btn = QPushButton("Show Results")
        self.show_results_btn.setFixedWidth(150)
        self.show_results_btn.setEnabled(False)
        self.show_results_btn.clicked.connect(self._on_show_results)
        action_layout.addWidget(self.show_results_btn)

        self.normalize_btn = QPushButton("Normalize")
        self.normalize_btn.setFixedWidth(150)
        self.normalize_btn.setEnabled(False)
        self.normalize_btn.clicked.connect(self._on_normalize)
        action_layout.addWidget(self.normalize_btn)
        
        self.exec_summary_btn = QPushButton("Print Executive Summary")
        self.exec_summary_btn.setFixedWidth(180)
        self.exec_summary_btn.setEnabled(False)
        self.exec_summary_btn.clicked.connect(self._on_print_exec_summary)
        action_layout.addWidget(self.exec_summary_btn)
        
        action_layout.addStretch()
        main_layout.addLayout(action_layout)
        
        main_layout.addStretch()
        
        # Initialize deselect menu
        self._build_deselect_menu()
        
        # Initial population
        self._refresh_group_task_toggles()
    
    def _load_tsv(self) -> None:
        """Load and validate a TSV file."""
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            "Select TSV file",
            "",
            "TSV files (*.tsv);;All files (*.*)"
        )
        
        if not file_path:
            return
        
        # Validate format
        result = validate_tsv_format(file_path, EXPECTED_COLUMNS)
        if not result.ok:
            QMessageBox.critical(self, "Format error", result.message or "Unknown format error.")
            return
        
        # Load data
        try:
            state.df = pd.read_csv(file_path, sep="\t")
        except Exception as e:
            QMessageBox.critical(self, "Load error", str(e))
            return

        # Reset normalized data (must be recomputed for new file)
        state.normalized_df = None
        
        # Update UI with file path
        state.loaded_file_path = file_path
        self.file_path_edit.setText(file_path)
        
        # Reset caches
        state.participants_cache = []
        state.tasks_cache = []
        
        # Clear listboxes
        self.participants_list.clear()
        self.tasks_list.clear()
        
        # Disable action buttons during loading
        self.group_participants_btn.setEnabled(False)
        self.group_tasks_btn.setEnabled(False)
        self._set_main_action_buttons_enabled(False)
        
        # Extract participants
        try:
            state.participants_cache = extract_participants(state.df, column="Participant")
        except Exception as e:
            QMessageBox.critical(self, "Participant scan failed", str(e))
            state.df = None
            return
        
        # Extract tasks
        try:
            state.tasks_cache = extract_tasks_from_toi(state.df, column="TOI")
        except Exception as e:
            QMessageBox.critical(self, "Task scan failed", str(e))
            state.df = None
            return
        
        # Keep only labels for tasks that exist
        state.task_labels = {k: v for k, v in state.task_labels.items() if k in set(state.tasks_cache)}
        
        # Update listboxes
        for p in state.participants_cache:
            self.participants_list.addItem(p)
        
        self._refresh_tasks_listbox()
        
        # Enable group buttons
        self.group_participants_btn.setEnabled(bool(state.participants_cache))
        self.group_tasks_btn.setEnabled(bool(state.tasks_cache))
        
        self._set_main_action_buttons_enabled(True)
        self._refresh_group_task_toggles()
        
        QMessageBox.information(
            self, 
            "Success", 
            f"Loaded {len(state.df)} rows.\n"
            f"Found {len(state.participants_cache)} participants and {len(state.tasks_cache)} tasks."
        )
    
    def _refresh_tasks_listbox(self) -> None:
        """Refresh the tasks listbox with formatted task names."""
        self.tasks_list.clear()
        for t in state.tasks_cache:
            self.tasks_list.addItem(state.format_task(t))
    
    def _set_main_action_buttons_enabled(self, enabled: bool) -> None:
        """Enable or disable main action buttons."""
        self.show_results_btn.setEnabled(enabled)
        self.normalize_btn.setEnabled(enabled)
        self.exec_summary_btn.setEnabled(enabled)
    
    def _refresh_group_task_toggles(self) -> None:
        """Refresh the checkbox lists in the Results section."""
        # Clear existing group checkboxes
        while self.groups_layout.count():
            item = self.groups_layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()
        
        # Clear existing task checkboxes
        while self.tasks_layout.count():
            item = self.tasks_layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()
        
        self.result_group_checkboxes.clear()
        self.result_task_checkboxes.clear()
        
        # Groups toggles
        effective_groups = state.get_effective_participant_groups()
        effective_names = state.get_effective_group_names()
        
        if not effective_groups:
            label = QLabel("(Load a TSV file first)")
            label.setStyleSheet("color: #666;")
            self.groups_layout.addWidget(label)
        else:
            for gid in effective_groups.keys():
                name = effective_names.get(gid, gid)
                cb = QCheckBox(name)
                cb.setChecked(True)
                self.result_group_checkboxes[gid] = cb
                self.groups_layout.addWidget(cb)
        
        self.groups_layout.addStretch()
        
        # Tasks toggles
        if not state.tasks_cache:
            label = QLabel("(Load a TSV file first)")
            label.setStyleSheet("color: #666;")
            self.tasks_layout.addWidget(label, 0, 0)
            return
        
        cols = 8
        row = 0
        col = 0
        for tid in state.tasks_cache:
            cb = QCheckBox(state.format_task(tid))
            cb.setChecked(True)
            self.result_task_checkboxes[tid] = cb
            self.tasks_layout.addWidget(cb, row, col)
            col += 1
            if col >= cols:
                col = 0
                row += 1
    
    def _build_deselect_menu(self) -> None:
        """Build the deselect parameters menu."""
        self.deselect_menu = QMenu(self)
        self.deselect_param_checkboxes.clear()
        
        for name in PARAMETER_OPTIONS:
            action = QAction(name, self)
            action.setCheckable(True)
            action.triggered.connect(self._update_deselect_label)
            self.deselect_menu.addAction(action)
            self.deselect_param_checkboxes[name] = action
    
    def _toggle_deselect_menu(self, state_val: int) -> None:
        """Toggle the deselect parameters menu button."""
        self.deselect_btn.setEnabled(state_val == Qt.CheckState.Checked.value)
    
    def _show_deselect_menu(self) -> None:
        """Show the deselect parameters menu."""
        self.deselect_menu.exec(self.deselect_btn.mapToGlobal(self.deselect_btn.rect().bottomLeft()))
    
    def _update_deselect_label(self) -> None:
        """Update the deselect button label."""
        count = sum(1 for action in self.deselect_param_checkboxes.values() if action.isChecked())
        self.deselect_btn.setText("None" if count == 0 else f"{count} deselected")
    
    def _open_group_participants(self) -> None:
        """Open the group participants dialog."""
        if not state.participants_cache:
            QMessageBox.information(self, "No data", "Load a TSV file first.")
            return
        
        dialog = GroupParticipantsDialog(self)
        if dialog.exec() == GroupParticipantsDialog.DialogCode.Accepted:
            self._refresh_group_task_toggles()
    
    def _open_group_tasks(self) -> None:
        """Open the group tasks dialog."""
        if not state.tasks_cache:
            QMessageBox.information(self, "No data", "Load a TSV file first.")
            return
        
        dialog = GroupTasksDialog(self)
        if dialog.exec() == GroupTasksDialog.DialogCode.Accepted:
            self._refresh_tasks_listbox()
            self._refresh_group_task_toggles()

    def _on_normalize(self) -> None:
        """Normalize numeric data per participant by baseline task 0a (fallback 0b)."""
        if state.df is None:
            QMessageBox.information(self, "No data", "Load a TSV file first.")
            return

        try:
            state.normalized_df = normalize_by_participant_baseline(
                state.df,
                participant_col="Participant",
                task_col="TOI",
                baseline_primary="0a",
                baseline_fallback="0b",
            )
        except Exception as e:
            QMessageBox.critical(self, "Normalize failed", str(e))
            return

        QMessageBox.information(
            self,
            "Normalization complete",
            "Normalized data stored in state.normalized_df (baseline: 0a, fallback: 0b).",
        )
    
    def _on_show_results(self) -> None:
        """Handle Show Results button click."""
        if state.df is None:
            QMessageBox.information(self, "No data", "Load a TSV file first.")
            return
        
        selected_groups = [gid for gid, cb in self.result_group_checkboxes.items() if cb.isChecked()]
        selected_tasks = [tid for tid, cb in self.result_task_checkboxes.items() if cb.isChecked()]
        domains = [name for name, cb in self.result_domain_vars.items() if cb.isChecked()]
        mode = self.mode_combo.currentText()
        
        deselected = []
        if self.deselect_enabled_cb.isChecked():
            deselected = [name for name, action in self.deselect_param_checkboxes.items() if action.isChecked()]
        
        msg = (
            f"Mode: {mode}\n"
            f"Groups selected: {len(selected_groups)}\n"
            f"Tasks selected: {len(selected_tasks)}\n"
            f"Result domains: {', '.join(domains) if domains else '(none)'}\n"
            f"Deselected parameters: {', '.join(deselected) if deselected else '(none)'}"
        )
        QMessageBox.information(self, "Show Results (placeholder)", msg)
    
    def _on_print_exec_summary(self) -> None:
        """Handle Print Executive Summary button click."""
        if state.df is None:
            QMessageBox.information(self, "No data", "Load a TSV file first.")
            return
        QMessageBox.information(self, "Executive Summary (placeholder)", 
                                "This will generate the executive summary later.")
```

> Tokens: 13k sent, 5.4k received. Cost: $0.10 message, $0.92 session.  
> Applied edit to data_processor.py  
> Applied edit to main_window.py  
> Applied edit to state.py  
> Commit 3c3b6ff feat: Normalisierung pro Participant per Baseline hinzufügen und speichern  
> You can use /undo to undo and discard each aider commit.  

#### I want u to add another content box like deselect parameters called: Weighting Parameters. It should have a Toggle Switch with alabel: "Enable custom parameter weights" to the right. underneath is a drop/down menu where u can select one parameter. on the right next to it should be a slider which goes from 0 to 3 and is set by default at 1. if parameter is choosen and slider is adjusted spawn the same modules underneath so another parameter could be weighted. this should be possible as long as their is still a unweighted parameter in the list. selecting one parameter multiple times should not be possible.  

## Änderungen (nur das Nötige) – `main_window.py`

Ziel: Neue Box **“Weighting Parameters”** wie “Deselect Parameters”, mit
- Toggle: **“Enable custom parameter weights”** (Checkbox als Toggle) + Label rechts
- darunter dynamische Zeilen: **Parameter-Dropdown** + **Slider 0..3 (Default 1)**  
- sobald in einer Zeile ein Parameter gewählt und/oder Slider bewegt wird: **nächste Zeile erzeugen**
- keine Mehrfachauswahl desselben Parameters
- Zeilen nur solange erzeugen, wie es noch ungewichtete Parameter gibt

> Hinweis an Editor: Wir implementieren das rein in `MainWindow` (UI + Logik). Die Gewichte speichern wir zunächst in `self.parameter_weights: Dict[str, float]` (oder int). Später können andere Funktionen darauf zugreifen.

---

### 1) Imports ergänzen
In `main_window.py` bei den Qt-Imports `QSlider` ergänzen:

```diff
 from PyQt6.QtWidgets import (
@@
-    QFrame, QMessageBox, QFileDialog, QMenu, QMenuBar, QSplitter
+    QFrame, QMessageBox, QFileDialog, QMenu, QMenuBar, QSplitter, QSlider
 )
```

---

### 2) Neue Attribute in `__init__`
In `MainWindow.__init__` nach den bestehenden Dicts ergänzen:

```diff
 class MainWindow(QMainWindow):
@@
     def __init__(self) -> None:
@@
         # Deselect parameters
         self.deselect_param_checkboxes: Dict[str, QCheckBox] = {}
+
+        # Weighting parameters
+        self.weighting_enabled_cb: Optional[QCheckBox] = None
+        self.weight_rows: list[tuple[QComboBox, QSlider]] = []
+        self.parameter_weights: Dict[str, float] = {}
```

---

### 3) UI-Box “Weighting Parameters” in `_setup_ui()` hinzufügen
In `_setup_ui()` im Bereich **Bottom row** (wo `domain_group` und `deselect_group` gebaut werden) **nach** `deselect_group` (oder davor – aber “wie deselect parameters” ist am besten daneben) einfügen.

Suche diesen Block:
```python
# Deselect parameters
deselect_group = QGroupBox("Deselect Parameters")
...
bottom_layout.addWidget(deselect_group)
```

Direkt **danach** einfügen:

```diff
         bottom_layout.addWidget(deselect_group)
+
+        # Weighting parameters
+        weighting_group = QGroupBox("Weighting Parameters")
+        weighting_outer = QVBoxLayout(weighting_group)
+
+        # Toggle row: checkbox + label rechts
+        weighting_toggle_row = QHBoxLayout()
+        self.weighting_enabled_cb = QCheckBox()
+        self.weighting_enabled_cb.setChecked(False)
+        self.weighting_enabled_cb.stateChanged.connect(self._on_weighting_toggled)
+        weighting_toggle_row.addWidget(self.weighting_enabled_cb)
+        weighting_toggle_row.addWidget(QLabel("Enable custom parameter weights"))
+        weighting_toggle_row.addStretch()
+        weighting_outer.addLayout(weighting_toggle_row)
+
+        # Container für dynamische Zeilen
+        self.weighting_rows_container = QWidget()
+        self.weighting_rows_layout = QVBoxLayout(self.weighting_rows_container)
+        self.weighting_rows_layout.setContentsMargins(0, 0, 0, 0)
+        self.weighting_rows_layout.setSpacing(6)
+        weighting_outer.addWidget(self.weighting_rows_container)
+
+        bottom_layout.addWidget(weighting_group)
```

---

### 4) Initialisierung am Ende von `_setup_ui()`
Am Ende von `_setup_ui()` (wo du bereits `_build_deselect_menu()` und `_refresh_group_task_toggles()` aufrufst) ergänzen:

```diff
         # Initialize deselect menu
         self._build_deselect_menu()
+
+        # Initialize weighting UI (disabled by default)
+        self._reset_weighting_ui()
```

---

### 5) Neue Methoden in `MainWindow` hinzufügen
Füge **unterhalb** von `_build_deselect_menu` (oder irgendwo in der Klasse, aber zusammenhängend) folgende Methoden hinzu.

#### 5.1 `_reset_weighting_ui`
```diff
+    def _reset_weighting_ui(self) -> None:
+        """Clear all weighting rows and internal weights; keep toggle state."""
+        self.parameter_weights.clear()
+        self.weight_rows.clear()
+
+        # Clear UI rows
+        if hasattr(self, "weighting_rows_layout"):
+            while self.weighting_rows_layout.count():
+                item = self.weighting_rows_layout.takeAt(0)
+                if item.widget():
+                    item.widget().deleteLater()
+
+        # If enabled and we have parameters, create first row
+        if self.weighting_enabled_cb is not None and self.weighting_enabled_cb.isChecked():
+            self._ensure_next_weight_row()
```

#### 5.2 `_on_weighting_toggled`
```diff
+    def _on_weighting_toggled(self, state_val: int) -> None:
+        enabled = state_val == Qt.CheckState.Checked.value
+        if not enabled:
+            self._reset_weighting_ui()
+            return
+        self._reset_weighting_ui()
```

> Ja, das ruft zweimal reset auf (einmal “clear”, einmal “create first row”). Das ist ok, aber wenn du es sauberer willst: im `enabled`-Fall erst clear, dann ensure. Der Editor kann das minimal zusammenziehen.

#### 5.3 Hilfsfunktionen: verfügbare Parameter / bereits gewählt
```diff
+    def _selected_weight_params(self) -> set[str]:
+        selected: set[str] = set()
+        for combo, _slider in self.weight_rows:
+            val = combo.currentData()
+            if isinstance(val, str) and val:
+                selected.add(val)
+        return selected
+
+    def _available_weight_params(self) -> list[str]:
+        # PARAMETER_OPTIONS sind die “Parameter” im Tool
+        selected = self._selected_weight_params()
+        return [p for p in PARAMETER_OPTIONS if p not in selected]
```

#### 5.4 `_create_weight_row`
Erzeugt eine Zeile (Combo + Slider), füllt Combo nur mit noch nicht gewählten Parametern.

```diff
+    def _create_weight_row(self) -> None:
+        available = self._available_weight_params()
+        if not available:
+            return
+
+        row = QWidget()
+        row_layout = QHBoxLayout(row)
+        row_layout.setContentsMargins(0, 0, 0, 0)
+
+        combo = QComboBox()
+        combo.setFixedWidth(260)
+        combo.addItem("Select parameter...", None)
+        for p in available:
+            combo.addItem(p, p)
+
+        slider = QSlider(Qt.Orientation.Horizontal)
+        slider.setMinimum(0)
+        slider.setMaximum(3)
+        slider.setValue(1)
+        slider.setSingleStep(1)
+        slider.setPageStep(1)
+        slider.setFixedWidth(220)
+        slider.setEnabled(False)  # erst aktivieren, wenn Parameter gewählt
+
+        # Signals
+        combo.currentIndexChanged.connect(lambda _i, c=combo, s=slider: self._on_weight_row_changed(c, s))
+        slider.valueChanged.connect(lambda _v, c=combo, s=slider: self._on_weight_row_changed(c, s))
+
+        row_layout.addWidget(combo)
+        row_layout.addWidget(slider)
+        row_layout.addStretch()
+
+        self.weighting_rows_layout.addWidget(row)
+        self.weight_rows.append((combo, slider))
```

#### 5.5 `_on_weight_row_changed` (Kernlogik)
- Aktiviert Slider sobald Parameter gewählt
- Speichert Gewicht
- Erzwingt: keine Duplikate (durch Rebuild der Combos)
- Spawnt nächste Zeile, wenn diese “belegt” ist und noch Parameter übrig sind

```diff
+    def _on_weight_row_changed(self, combo: QComboBox, slider: QSlider) -> None:
+        # Wenn Toggle aus: ignorieren
+        if self.weighting_enabled_cb is None or not self.weighting_enabled_cb.isChecked():
+            return
+
+        param = combo.currentData()
+        if not isinstance(param, str) or not param:
+            slider.setEnabled(False)
+            return
+
+        slider.setEnabled(True)
+
+        # Gewicht speichern (int 0..3)
+        self.parameter_weights[param] = float(slider.value())
+
+        # Alle Combos neu aufbauen, damit keine Duplikate möglich sind
+        self._rebuild_weight_combos(keep_current=True)
+
+        # Wenn diese Zeile “aktiv” ist, nächste Zeile sicherstellen
+        self._ensure_next_weight_row()
```

#### 5.6 `_rebuild_weight_combos`
Rebuild aller Combos so, dass:
- bereits gewählte Parameter in ihrer Combo weiterhin auswählbar bleiben
- alle anderen Combos diese Parameter nicht mehr anbieten
- “Select parameter…” bleibt immer Option 0

```diff
+    def _rebuild_weight_combos(self, keep_current: bool = True) -> None:
+        selected = self._selected_weight_params()
+
+        for combo, slider in self.weight_rows:
+            current = combo.currentData() if keep_current else None
+
+            # Block signals während rebuild
+            combo.blockSignals(True)
+            combo.clear()
+            combo.addItem("Select parameter...", None)
+
+            # In dieser Combo darf current weiterhin drin sein
+            allowed = []
+            for p in PARAMETER_OPTIONS:
+                if p == current:
+                    allowed.append(p)
+                elif p not in selected:
+                    allowed.append(p)
+
+            for p in allowed:
+                combo.addItem(p, p)
+
+            # Restore selection
+            if isinstance(current, str) and current:
+                idx = combo.findData(current)
+                combo.setCurrentIndex(idx if idx >= 0 else 0)
+                slider.setEnabled(True)
+            else:
+                combo.setCurrentIndex(0)
+                slider.setEnabled(False)
+
+            combo.blockSignals(False)
```

#### 5.7 `_ensure_next_weight_row`
Erzeugt eine neue Zeile, wenn:
- Toggle an
- es noch ungewichtete Parameter gibt
- und die letzte Zeile bereits einen Parameter gewählt hat (oder es gibt noch gar keine Zeile)

```diff
+    def _ensure_next_weight_row(self) -> None:
+        if self.weighting_enabled_cb is None or not self.weighting_enabled_cb.isChecked():
+            return
+
+        available = self._available_weight_params()
+        if not available:
+            return
+
+        if not self.weight_rows:
+            self._create_weight_row()
+            return
+
+        last_combo, _last_slider = self.weight_rows[-1]
+        last_param = last_combo.currentData()
+        if isinstance(last_param, str) and last_param:
+            self._create_weight_row()
```

---

### 6) Beim TSV-Load Gewichte zurücksetzen
In `_load_tsv()` nach `state.normalized_df = None` (oder nach Cache reset) ergänzen:

```diff
         # Reset normalized data (must be recomputed for new file)
         state.normalized_df = None
+
+        # Reset weighting UI/weights (parameters list may change later)
+        if self.weighting_enabled_cb is not None:
+            self.weighting_enabled_cb.setChecked(False)
+        self._reset_weighting_ui()
```

---

### 7) Optional: Action-Buttons Enable/Disable
Du hast `_set_main_action_buttons_enabled` für die drei Buttons. Die Weighting-Box soll unabhängig davon funktionieren, aber sinnvoll ist: erst nach TSV-Load aktivieren.

Minimal: in `_load_tsv()` nach erfolgreichem Load:
- `weighting_enabled_cb` bleibt aus, aber nutzbar. Wenn du sie erst nach Load aktivieren willst, setze `setEnabled(bool(state.df is not None))`.

Füge in `_set_main_action_buttons_enabled` **nicht** rein; stattdessen in `_load_tsv()` nach erfolgreichem Extract:

```diff
         # Enable group buttons
         self.group_participants_btn.setEnabled(bool(state.participants_cache))
         self.group_tasks_btn.setEnabled(bool(state.tasks_cache))
+
+        if self.weighting_enabled_cb is not None:
+            self.weighting_enabled_cb.setEnabled(True)
```

Und in `_setup_ui()` direkt nach Erstellung der Checkbox:
```diff
         self.weighting_enabled_cb = QCheckBox()
         self.weighting_enabled_cb.setChecked(False)
+        self.weighting_enabled_cb.setEnabled(False)
```

---

## Verhalten (Abnahmekriterien)
- Toggle aus: keine Zeilen, `self.parameter_weights` leer.
- Toggle an: erste Zeile erscheint, Slider disabled bis Parameter gewählt.
- Parameter gewählt + Slider bewegt: Gewicht wird gespeichert, nächste Zeile erscheint (falls noch Parameter übrig).
- Ein Parameter kann nur in **einer** Zeile gewählt werden (Combos werden nach jeder Änderung rebuilt).
- Wenn alle Parameter vergeben sind: keine neue Zeile mehr.

---

Wenn du willst, kann ich als nächsten Schritt definieren, wie andere Auswertungsfunktionen diese Gewichte anwenden sollen (z.B. Multiplikation der Metriken vor Aggregation) – dafür müsste ich aber die Result-Berechnungslogik-Datei sehen (die aktuell in deinem `MainWindow` noch “placeholder” ist).

> Tokens: 17k sent, 3.0k received. Cost: $0.07 message, $0.99 session.  

#### ## Änderungen (nur das Nötige) – `main_window.py`  
####   
#### Ziel: Neue Box **“Weighting Parameters”** wie “Deselect Parameters”, mit  
#### - Toggle: **“Enable custom parameter weights”** (Checkbox als Toggle) + Label rechts  
#### - darunter dynamische Zeilen: **Parameter-Dropdown** + **Slider 0..3 (Default 1)**    
#### - sobald in einer Zeile ein Parameter gewählt und/oder Slider bewegt wird: **nächste Zeile erzeugen**  
#### - keine Mehrfachauswahl desselben Parameters  
#### - Zeilen nur solange erzeugen, wie es noch ungewichtete Parameter gibt  
####   
#### > Hinweis an Editor: Wir implementieren das rein in `MainWindow` (UI + Logik). Die Gewichte speichern wir zunächst in `self.parameter_weights: Dict[str, float]` (oder int). Später können andere Funktionen darauf zugreifen.  
####   
#### ---  
####   
#### ### 1) Imports ergänzen  
#### In `main_window.py` bei den Qt-Imports `QSlider` ergänzen:  
####   
#### ```diff  
####  from PyQt6.QtWidgets import (  
#### @@  
#### -    QFrame, QMessageBox, QFileDialog, QMenu, QMenuBar, QSplitter  
#### +    QFrame, QMessageBox, QFileDialog, QMenu, QMenuBar, QSplitter, QSlider  
####  )  
#### ```  
####   
#### ---  
####   
#### ### 2) Neue Attribute in `__init__`  
#### In `MainWindow.__init__` nach den bestehenden Dicts ergänzen:  
####   
#### ```diff  
####  class MainWindow(QMainWindow):  
#### @@  
####      def __init__(self) -> None:  
#### @@  
####          # Deselect parameters  
####          self.deselect_param_checkboxes: Dict[str, QCheckBox] = {}  
#### +  
#### +        # Weighting parameters  
#### +        self.weighting_enabled_cb: Optional[QCheckBox] = None  
#### +        self.weight_rows: list[tuple[QComboBox, QSlider]] = []  
#### +        self.parameter_weights: Dict[str, float] = {}  
#### ```  
####   
#### ---  
####   
#### ### 3) UI-Box “Weighting Parameters” in `_setup_ui()` hinzufügen  
#### In `_setup_ui()` im Bereich **Bottom row** (wo `domain_group` und `deselect_group` gebaut werden) **nach** `deselect_group` (oder davor – aber “wie deselect parameters” ist am besten daneben) einfügen.  
####   
#### Suche diesen Block:  
#### ```python  
#### # Deselect parameters  
#### deselect_group = QGroupBox("Deselect Parameters")  
#### ...  
#### bottom_layout.addWidget(deselect_group)  
#### ```  
####   
#### Direkt **danach** einfügen:  
####   
#### ```diff  
####          bottom_layout.addWidget(deselect_group)  
#### +  
#### +        # Weighting parameters  
#### +        weighting_group = QGroupBox("Weighting Parameters")  
#### +        weighting_outer = QVBoxLayout(weighting_group)  
#### +  
#### +        # Toggle row: checkbox + label rechts  
#### +        weighting_toggle_row = QHBoxLayout()  
#### +        self.weighting_enabled_cb = QCheckBox()  
#### +        self.weighting_enabled_cb.setChecked(False)  
#### +        self.weighting_enabled_cb.stateChanged.connect(self._on_weighting_toggled)  
#### +        weighting_toggle_row.addWidget(self.weighting_enabled_cb)  
#### +        weighting_toggle_row.addWidget(QLabel("Enable custom parameter weights"))  
#### +        weighting_toggle_row.addStretch()  
#### +        weighting_outer.addLayout(weighting_toggle_row)  
#### +  
#### +        # Container für dynamische Zeilen  
#### +        self.weighting_rows_container = QWidget()  
#### +        self.weighting_rows_layout = QVBoxLayout(self.weighting_rows_container)  
#### +        self.weighting_rows_layout.setContentsMargins(0, 0, 0, 0)  
#### +        self.weighting_rows_layout.setSpacing(6)  
#### +        weighting_outer.addWidget(self.weighting_rows_container)  
#### +  
#### +        bottom_layout.addWidget(weighting_group)  
#### ```  
####   
#### ---  
####   
#### ### 4) Initialisierung am Ende von `_setup_ui()`  
#### Am Ende von `_setup_ui()` (wo du bereits `_build_deselect_menu()` und `_refresh_group_task_toggles()` aufrufst) ergänzen:  
####   
#### ```diff  
####          # Initialize deselect menu  
####          self._build_deselect_menu()  
#### +  
#### +        # Initialize weighting UI (disabled by default)  
#### +        self._reset_weighting_ui()  
#### ```  
####   
#### ---  
####   
#### ### 5) Neue Methoden in `MainWindow` hinzufügen  
#### Füge **unterhalb** von `_build_deselect_menu` (oder irgendwo in der Klasse, aber zusammenhängend) folgende Methoden hinzu.  
####   
#### #### 5.1 `_reset_weighting_ui`  
#### ```diff  
#### +    def _reset_weighting_ui(self) -> None:  
#### +        """Clear all weighting rows and internal weights; keep toggle state."""  
#### +        self.parameter_weights.clear()  
#### +        self.weight_rows.clear()  
#### +  
#### +        # Clear UI rows  
#### +        if hasattr(self, "weighting_rows_layout"):  
#### +            while self.weighting_rows_layout.count():  
#### +                item = self.weighting_rows_layout.takeAt(0)  
#### +                if item.widget():  
#### +                    item.widget().deleteLater()  
#### +  
#### +        # If enabled and we have parameters, create first row  
#### +        if self.weighting_enabled_cb is not None and self.weighting_enabled_cb.isChecked():  
#### +            self._ensure_next_weight_row()  
#### ```  
####   
#### #### 5.2 `_on_weighting_toggled`  
#### ```diff  
#### +    def _on_weighting_toggled(self, state_val: int) -> None:  
#### +        enabled = state_val == Qt.CheckState.Checked.value  
#### +        if not enabled:  
#### +            self._reset_weighting_ui()  
#### +            return  
#### +        self._reset_weighting_ui()  
#### ```  
####   
#### > Ja, das ruft zweimal reset auf (einmal “clear”, einmal “create first row”). Das ist ok, aber wenn du es sauberer willst: im `enabled`-Fall erst clear, dann ensure. Der Editor kann das minimal zusammenziehen.  
####   
#### #### 5.3 Hilfsfunktionen: verfügbare Parameter / bereits gewählt  
#### ```diff  
#### +    def _selected_weight_params(self) -> set[str]:  
#### +        selected: set[str] = set()  
#### +        for combo, _slider in self.weight_rows:  
#### +            val = combo.currentData()  
#### +            if isinstance(val, str) and val:  
#### +                selected.add(val)  
#### +        return selected  
#### +  
#### +    def _available_weight_params(self) -> list[str]:  
#### +        # PARAMETER_OPTIONS sind die “Parameter” im Tool  
#### +        selected = self._selected_weight_params()  
#### +        return [p for p in PARAMETER_OPTIONS if p not in selected]  
#### ```  
####   
#### #### 5.4 `_create_weight_row`  
#### Erzeugt eine Zeile (Combo + Slider), füllt Combo nur mit noch nicht gewählten Parametern.  
####   
#### ```diff  
#### +    def _create_weight_row(self) -> None:  
#### +        available = self._available_weight_params()  
#### +        if not available:  
#### +            return  
#### +  
#### +        row = QWidget()  
#### +        row_layout = QHBoxLayout(row)  
#### +        row_layout.setContentsMargins(0, 0, 0, 0)  
#### +  
#### +        combo = QComboBox()  
#### +        combo.setFixedWidth(260)  
#### +        combo.addItem("Select parameter...", None)  
#### +        for p in available:  
#### +            combo.addItem(p, p)  
#### +  
#### +        slider = QSlider(Qt.Orientation.Horizontal)  
#### +        slider.setMinimum(0)  
#### +        slider.setMaximum(3)  
#### +        slider.setValue(1)  
#### +        slider.setSingleStep(1)  
#### +        slider.setPageStep(1)  
#### +        slider.setFixedWidth(220)  
#### +        slider.setEnabled(False)  # erst aktivieren, wenn Parameter gewählt  
#### +  
#### +        # Signals  
#### +        combo.currentIndexChanged.connect(lambda _i, c=combo, s=slider: self._on_weight_row_changed(c, s))  
#### +        slider.valueChanged.connect(lambda _v, c=combo, s=slider: self._on_weight_row_changed(c, s))  
#### +  
#### +        row_layout.addWidget(combo)  
#### +        row_layout.addWidget(slider)  
#### +        row_layout.addStretch()  
#### +  
#### +        self.weighting_rows_layout.addWidget(row)  
#### +        self.weight_rows.append((combo, slider))  
#### ```  
####   
#### #### 5.5 `_on_weight_row_changed` (Kernlogik)  
#### - Aktiviert Slider sobald Parameter gewählt  
#### - Speichert Gewicht  
#### - Erzwingt: keine Duplikate (durch Rebuild der Combos)  
#### - Spawnt nächste Zeile, wenn diese “belegt” ist und noch Parameter übrig sind  
####   
#### ```diff  
#### +    def _on_weight_row_changed(self, combo: QComboBox, slider: QSlider) -> None:  
#### +        # Wenn Toggle aus: ignorieren  
#### +        if self.weighting_enabled_cb is None or not self.weighting_enabled_cb.isChecked():  
#### +            return  
#### +  
#### +        param = combo.currentData()  
#### +        if not isinstance(param, str) or not param:  
#### +            slider.setEnabled(False)  
#### +            return  
#### +  
#### +        slider.setEnabled(True)  
#### +  
#### +        # Gewicht speichern (int 0..3)  
#### +        self.parameter_weights[param] = float(slider.value())  
#### +  
#### +        # Alle Combos neu aufbauen, damit keine Duplikate möglich sind  
#### +        self._rebuild_weight_combos(keep_current=True)  
#### +  
#### +        # Wenn diese Zeile “aktiv” ist, nächste Zeile sicherstellen  
#### +        self._ensure_next_weight_row()  
#### ```  
####   
#### #### 5.6 `_rebuild_weight_combos`  
#### Rebuild aller Combos so, dass:  
#### - bereits gewählte Parameter in ihrer Combo weiterhin auswählbar bleiben  
#### - alle anderen Combos diese Parameter nicht mehr anbieten  
#### - “Select parameter…” bleibt immer Option 0  
####   
#### ```diff  
#### +    def _rebuild_weight_combos(self, keep_current: bool = True) -> None:  
#### +        selected = self._selected_weight_params()  
#### +  
#### +        for combo, slider in self.weight_rows:  
#### +            current = combo.currentData() if keep_current else None  
#### +  
#### +            # Block signals während rebuild  
#### +            combo.blockSignals(True)  
#### +            combo.clear()  
#### +            combo.addItem("Select parameter...", None)  
#### +  
#### +            # In dieser Combo darf current weiterhin drin sein  
#### +            allowed = []  
#### +            for p in PARAMETER_OPTIONS:  
#### +                if p == current:  
#### +                    allowed.append(p)  
#### +                elif p not in selected:  
#### +                    allowed.append(p)  
#### +  
#### +            for p in allowed:  
#### +                combo.addItem(p, p)  
#### +  
#### +            # Restore selection  
#### +            if isinstance(current, str) and current:  
#### +                idx = combo.findData(current)  
#### +                combo.setCurrentIndex(idx if idx >= 0 else 0)  
#### +                slider.setEnabled(True)  
#### +            else:  
#### +                combo.setCurrentIndex(0)  
#### +                slider.setEnabled(False)  
#### +  
#### +            combo.blockSignals(False)  
#### ```  
####   
#### #### 5.7 `_ensure_next_weight_row`  
#### Erzeugt eine neue Zeile, wenn:  
#### - Toggle an  
#### - es noch ungewichtete Parameter gibt  
#### - und die letzte Zeile bereits einen Parameter gewählt hat (oder es gibt noch gar keine Zeile)  
####   
#### ```diff  
#### +    def _ensure_next_weight_row(self) -> None:  
#### +        if self.weighting_enabled_cb is None or not self.weighting_enabled_cb.isChecked():  
#### +            return  
#### +  
#### +        available = self._available_weight_params()  
#### +        if not available:  
#### +            return  
#### +  
#### +        if not self.weight_rows:  
#### +            self._create_weight_row()  
#### +            return  
#### +  
#### +        last_combo, _last_slider = self.weight_rows[-1]  
#### +        last_param = last_combo.currentData()  
#### +        if isinstance(last_param, str) and last_param:  
#### +            self._create_weight_row()  
#### ```  
####   
#### ---  
####   
#### ### 6) Beim TSV-Load Gewichte zurücksetzen  
#### In `_load_tsv()` nach `state.normalized_df = None` (oder nach Cache reset) ergänzen:  
####   
#### ```diff  
####          # Reset normalized data (must be recomputed for new file)  
####          state.normalized_df = None  
#### +  
#### +        # Reset weighting UI/weights (parameters list may change later)  
#### +        if self.weighting_enabled_cb is not None:  
#### +            self.weighting_enabled_cb.setChecked(False)  
#### +        self._reset_weighting_ui()  
#### ```  
####   
#### ---  
####   
#### ### 7) Optional: Action-Buttons Enable/Disable  
#### Du hast `_set_main_action_buttons_enabled` für die drei Buttons. Die Weighting-Box soll unabhängig davon funktionieren, aber sinnvoll ist: erst nach TSV-Load aktivieren.  
####   
#### Minimal: in `_load_tsv()` nach erfolgreichem Load:  
#### - `weighting_enabled_cb` bleibt aus, aber nutzbar. Wenn du sie erst nach Load aktivieren willst, setze `setEnabled(bool(state.df is not None))`.  
####   
#### Füge in `_set_main_action_buttons_enabled` **nicht** rein; stattdessen in `_load_tsv()` nach erfolgreichem Extract:  
####   
#### ```diff  
####          # Enable group buttons  
####          self.group_participants_btn.setEnabled(bool(state.participants_cache))  
####          self.group_tasks_btn.setEnabled(bool(state.tasks_cache))  
#### +  
#### +        if self.weighting_enabled_cb is not None:  
#### +            self.weighting_enabled_cb.setEnabled(True)  
#### ```  
####   
#### Und in `_setup_ui()` direkt nach Erstellung der Checkbox:  
#### ```diff  
####          self.weighting_enabled_cb = QCheckBox()  
####          self.weighting_enabled_cb.setChecked(False)  
#### +        self.weighting_enabled_cb.setEnabled(False)  
#### ```  
####   
#### ---  
####   
#### ## Verhalten (Abnahmekriterien)  
#### - Toggle aus: keine Zeilen, `self.parameter_weights` leer.  
#### - Toggle an: erste Zeile erscheint, Slider disabled bis Parameter gewählt.  
#### - Parameter gewählt + Slider bewegt: Gewicht wird gespeichert, nächste Zeile erscheint (falls noch Parameter übrig).  
#### - Ein Parameter kann nur in **einer** Zeile gewählt werden (Combos werden nach jeder Änderung rebuilt).  
#### - Wenn alle Parameter vergeben sind: keine neue Zeile mehr.  
####   
#### ---  
####   
#### Wenn du willst, kann ich als nächsten Schritt definieren, wie andere Auswertungsfunktionen diese Gewichte anwenden sollen (z.B. Multiplikation der Metriken vor Aggregation) – dafür müsste ich aber die Result-Berechnungslogik-Datei sehen (die aktuell in deinem `MainWindow` noch “placeholder” ist).  

main_window.py
```
"""
Main window for the Eye Tracking Tool using PyQt6.
"""
from __future__ import annotations

from typing import Dict, Optional
import pandas as pd

from PyQt6.QtWidgets import (
    QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, QLabel, QPushButton,
    QListWidget, QLineEdit, QComboBox, QCheckBox, QGroupBox, QGridLayout,
    QFrame, QMessageBox, QFileDialog, QMenu, QMenuBar, QSplitter, QSlider
)
from PyQt6.QtCore import Qt, QSize
from PyQt6.QtGui import QAction

from state import state
from models import EXPECTED_COLUMNS, PARAMETER_OPTIONS
from data_processor import (
    validate_tsv_format,
    extract_participants,
    extract_tasks_from_toi,
    normalize_by_participant_baseline,
)
from dialogs import GroupParticipantsDialog, GroupTasksDialog


class MainWindow(QMainWindow):
    """Main application window."""

    def __init__(self) -> None:
        super().__init__()
        self.setWindowTitle("Eye Tracking Analysis Tool")
        self.setMinimumSize(1200, 720)

        # Result domain checkboxes
        self.result_domain_vars: Dict[str, QCheckBox] = {}

        # Result group/task checkboxes
        self.result_group_checkboxes: Dict[str, QCheckBox] = {}
        self.result_task_checkboxes: Dict[str, QCheckBox] = {}

        # Deselect parameters
        self.deselect_param_checkboxes: Dict[str, QCheckBox] = {}

        # Weighting parameters
        self.weighting_enabled_cb: Optional[QCheckBox] = None
        self.weight_rows: list[tuple[QComboBox, QSlider]] = []
        self.parameter_weights: Dict[str, float] = {}

        self._setup_ui()

    def _setup_ui(self) -> None:
        central = QWidget()
        self.setCentralWidget(central)
        main_layout = QVBoxLayout(central)
        main_layout.setContentsMargins(10, 10, 10, 10)

        # Top bar
        topbar = QHBoxLayout()

        self.load_btn = QPushButton("Load TSV")
        self.load_btn.setFixedWidth(120)
        self.load_btn.clicked.connect(self._load_tsv)
        topbar.addWidget(self.load_btn)

        self.group_participants_btn = QPushButton("Group Participants")
        self.group_participants_btn.setFixedWidth(150)
        self.group_participants_btn.setEnabled(False)
        self.group_participants_btn.clicked.connect(self._open_group_participants)
        topbar.addWidget(self.group_participants_btn)

        # Button-Text wie gewünscht: "Name Tasks"
        self.group_tasks_btn = QPushButton("Name Tasks")
        self.group_tasks_btn.setFixedWidth(120)
        self.group_tasks_btn.setEnabled(False)
        self.group_tasks_btn.clicked.connect(self._open_group_tasks)
        topbar.addWidget(self.group_tasks_btn)

        self.file_path_edit = QLineEdit()
        self.file_path_edit.setReadOnly(True)
        self.file_path_edit.setPlaceholderText("No file loaded")
        topbar.addWidget(self.file_path_edit)

        main_layout.addLayout(topbar)

        # Listboxes section
        listbox_layout = QHBoxLayout()

        # Participants listbox
        left_widget = QWidget()
        left_layout = QVBoxLayout(left_widget)
        left_layout.setContentsMargins(0, 0, 0, 0)
        left_layout.addWidget(QLabel('Detected participants (from "Participant"):'))
        self.participants_list = QListWidget()
        self.participants_list.setMaximumHeight(120)
        left_layout.addWidget(self.participants_list)
        listbox_layout.addWidget(left_widget)

        # Tasks listbox
        right_widget = QWidget()
        right_layout = QVBoxLayout(right_widget)
        right_layout.setContentsMargins(0, 0, 0, 0)
        right_layout.addWidget(QLabel('Detected tasks (from "TOI" suffix):'))
        self.tasks_list = QListWidget()
        self.tasks_list.setMaximumHeight(120)
        right_layout.addWidget(self.tasks_list)
        listbox_layout.addWidget(right_widget)

        main_layout.addLayout(listbox_layout)

        # Separator
        separator = QFrame()
        separator.setFrameShape(QFrame.Shape.HLine)
        separator.setFrameShadow(QFrame.Shadow.Sunken)
        main_layout.addWidget(separator)

        # Results section
        results_label = QLabel("Results")
        results_label.setStyleSheet("font-weight: bold; font-size: 14px;")
        main_layout.addWidget(results_label)

        # Mode selection
        mode_layout = QHBoxLayout()
        mode_layout.addWidget(QLabel("Show results for:"))

        self.mode_combo = QComboBox()
        self.mode_combo.addItems([
            "Only group mean",
            "Each participant for selected groups",
            "Group mean and individual participants",
        ])
        self.mode_combo.setFixedWidth(350)
        mode_layout.addWidget(self.mode_combo)
        mode_layout.addStretch()
        main_layout.addLayout(mode_layout)

        # Groups and Tasks frames
        sel_layout = QHBoxLayout()

        self.groups_group = QGroupBox("Groups")
        self.groups_layout = QVBoxLayout(self.groups_group)
        sel_layout.addWidget(self.groups_group)

        self.tasks_group = QGroupBox("Tasks")
        self.tasks_layout = QGridLayout(self.tasks_group)
        sel_layout.addWidget(self.tasks_group)

        main_layout.addLayout(sel_layout)

        # Bottom row: Result domain and Deselect parameters
        bottom_layout = QHBoxLayout()

        # Result domain
        domain_group = QGroupBox("Result domain")
        domain_layout = QHBoxLayout(domain_group)

        for name in ["Rank", "Radar Chart", "Task Completion Time"]:
            cb = QCheckBox(name)
            cb.setChecked(True)
            self.result_domain_vars[name] = cb
            domain_layout.addWidget(cb)

        domain_layout.addStretch()
        bottom_layout.addWidget(domain_group)

        # Deselect parameters
        deselect_group = QGroupBox("Deselect Parameters")
        deselect_layout = QHBoxLayout(deselect_group)

        self.deselect_enabled_cb = QCheckBox("Enable Deselect")
        self.deselect_enabled_cb.stateChanged.connect(self._toggle_deselect_menu)
        deselect_layout.addWidget(self.deselect_enabled_cb)

        self.deselect_btn = QPushButton("None")
        self.deselect_btn.setEnabled(False)
        self.deselect_btn.clicked.connect(self._show_deselect_menu)
        deselect_layout.addWidget(self.deselect_btn)

        deselect_layout.addStretch()
        bottom_layout.addWidget(deselect_group)

        # Weighting parameters
        weighting_group = QGroupBox("Weighting Parameters")
        weighting_outer = QVBoxLayout(weighting_group)

        # Toggle row: checkbox + label rechts
        weighting_toggle_row = QHBoxLayout()
        self.weighting_enabled_cb = QCheckBox()
        self.weighting_enabled_cb.setChecked(False)
        self.weighting_enabled_cb.setEnabled(False)
        self.weighting_enabled_cb.stateChanged.connect(self._on_weighting_toggled)
        weighting_toggle_row.addWidget(self.weighting_enabled_cb)
        weighting_toggle_row.addWidget(QLabel("Enable custom parameter weights"))
        weighting_toggle_row.addStretch()
        weighting_outer.addLayout(weighting_toggle_row)

        # Container für dynamische Zeilen
        self.weighting_rows_container = QWidget()
        self.weighting_rows_layout = QVBoxLayout(self.weighting_rows_container)
        self.weighting_rows_layout.setContentsMargins(0, 0, 0, 0)
        self.weighting_rows_layout.setSpacing(6)
        weighting_outer.addWidget(self.weighting_rows_container)

        bottom_layout.addWidget(weighting_group)

        main_layout.addLayout(bottom_layout)

        # Action buttons
        action_layout = QHBoxLayout()

        self.show_results_btn = QPushButton("Show Results")
        self.show_results_btn.setFixedWidth(150)
        self.show_results_btn.setEnabled(False)
        self.show_results_btn.clicked.connect(self._on_show_results)
        action_layout.addWidget(self.show_results_btn)

        self.normalize_btn = QPushButton("Normalize")
        self.normalize_btn.setFixedWidth(150)
        self.normalize_btn.setEnabled(False)
        self.normalize_btn.clicked.connect(self._on_normalize)
        action_layout.addWidget(self.normalize_btn)

        self.exec_summary_btn = QPushButton("Print Executive Summary")
        self.exec_summary_btn.setFixedWidth(180)
        self.exec_summary_btn.setEnabled(False)
        self.exec_summary_btn.clicked.connect(self._on_print_exec_summary)
        action_layout.addWidget(self.exec_summary_btn)

        action_layout.addStretch()
        main_layout.addLayout(action_layout)

        main_layout.addStretch()

        # Initialize deselect menu
        self._build_deselect_menu()

        # Initialize weighting UI (disabled by default)
        self._reset_weighting_ui()

        # Initial population
        self._refresh_group_task_toggles()

    def _load_tsv(self) -> None:
        """Load and validate a TSV file."""
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            "Select TSV file",
            "",
            "TSV files (*.tsv);;All files (*.*)"
        )

        if not file_path:
            return

        # Validate format
        result = validate_tsv_format(file_path, EXPECTED_COLUMNS)
        if not result.ok:
            QMessageBox.critical(self, "Format error", result.message or "Unknown format error.")
            return

        # Load data
        try:
            state.df = pd.read_csv(file_path, sep="\t")
        except Exception as e:
            QMessageBox.critical(self, "Load error", str(e))
            return

        # Reset normalized data (must be recomputed for new file)
        state.normalized_df = None

        # Reset weighting UI/weights (parameters list may change later)
        if self.weighting_enabled_cb is not None:
            self.weighting_enabled_cb.setChecked(False)
        self._reset_weighting_ui()

        # Update UI with file path
        state.loaded_file_path = file_path
        self.file_path_edit.setText(file_path)

        # Reset caches
        state.participants_cache = []
        state.tasks_cache = []

        # Clear listboxes
        self.participants_list.clear()
        self.tasks_list.clear()

        # Disable action buttons during loading
        self.group_participants_btn.setEnabled(False)
        self.group_tasks_btn.setEnabled(False)
        self._set_main_action_buttons_enabled(False)

        # Extract participants
        try:
            state.participants_cache = extract_participants(state.df, column="Participant")
        except Exception as e:
            QMessageBox.critical(self, "Participant scan failed", str(e))
            state.df = None
            return

        # Extract tasks
        try:
            state.tasks_cache = extract_tasks_from_toi(state.df, column="TOI")
        except Exception as e:
            QMessageBox.critical(self, "Task scan failed", str(e))
            state.df = None
            return

        # Keep only labels for tasks that exist
        state.task_labels = {k: v for k, v in state.task_labels.items() if k in set(state.tasks_cache)}

        # Update listboxes
        for p in state.participants_cache:
            self.participants_list.addItem(p)

        self._refresh_tasks_listbox()

        # Enable group buttons
        self.group_participants_btn.setEnabled(bool(state.participants_cache))
        self.group_tasks_btn.setEnabled(bool(state.tasks_cache))

        if self.weighting_enabled_cb is not None:
            self.weighting_enabled_cb.setEnabled(True)

        self._set_main_action_buttons_enabled(True)
        self._refresh_group_task_toggles()

        QMessageBox.information(
            self,
            "Success",
            f"Loaded {len(state.df)} rows.\n"
            f"Found {len(state.participants_cache)} participants and {len(state.tasks_cache)} tasks."
        )

    def _refresh_tasks_listbox(self) -> None:
        """Refresh the tasks listbox with formatted task names."""
        self.tasks_list.clear()
        for t in state.tasks_cache:
            self.tasks_list.addItem(state.format_task(t))

    def _set_main_action_buttons_enabled(self, enabled: bool) -> None:
        """Enable or disable main action buttons."""
        self.show_results_btn.setEnabled(enabled)
        self.normalize_btn.setEnabled(enabled)
        self.exec_summary_btn.setEnabled(enabled)

    def _refresh_group_task_toggles(self) -> None:
        """Refresh the checkbox lists in the Results section."""
        # Clear existing group checkboxes
        while self.groups_layout.count():
            item = self.groups_layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()

        # Clear existing task checkboxes
        while self.tasks_layout.count():
            item = self.tasks_layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()

        self.result_group_checkboxes.clear()
        self.result_task_checkboxes.clear()

        # Groups toggles
        effective_groups = state.get_effective_participant_groups()
        effective_names = state.get_effective_group_names()

        if not effective_groups:
            label = QLabel("(Load a TSV file first)")
            label.setStyleSheet("color: #666;")
            self.groups_layout.addWidget(label)
        else:
            for gid in effective_groups.keys():
                name = effective_names.get(gid, gid)
                cb = QCheckBox(name)
                cb.setChecked(True)
                self.result_group_checkboxes[gid] = cb
                self.groups_layout.addWidget(cb)

        self.groups_layout.addStretch()

        # Tasks toggles
        if not state.tasks_cache:
            label = QLabel("(Load a TSV file first)")
            label.setStyleSheet("color: #666;")
            self.tasks_layout.addWidget(label, 0, 0)
            return

        cols = 8
        row = 0
        col = 0
        for tid in state.tasks_cache:
            cb = QCheckBox(state.format_task(tid))
            cb.setChecked(True)
            self.result_task_checkboxes[tid] = cb
            self.tasks_layout.addWidget(cb, row, col)
            col += 1
            if col >= cols:
                col = 0
                row += 1

    def _build_deselect_menu(self) -> None:
        """Build the deselect parameters menu."""
        self.deselect_menu = QMenu(self)
        self.deselect_param_checkboxes.clear()

        for name in PARAMETER_OPTIONS:
            action = QAction(name, self)
            action.setCheckable(True)
            action.triggered.connect(self._update_deselect_label)
            self.deselect_menu.addAction(action)
            self.deselect_param_checkboxes[name] = action

    def _reset_weighting_ui(self) -> None:
        """Clear all weighting rows and internal weights; keep toggle state."""
        self.parameter_weights.clear()
        self.weight_rows.clear()

        # Clear UI rows
        if hasattr(self, "weighting_rows_layout"):
            while self.weighting_rows_layout.count():
                item = self.weighting_rows_layout.takeAt(0)
                if item.widget():
                    item.widget().deleteLater()

        # If enabled and we have parameters, create first row
        if self.weighting_enabled_cb is not None and self.weighting_enabled_cb.isChecked():
            self._ensure_next_weight_row()

    def _on_weighting_toggled(self, state_val: int) -> None:
        enabled = state_val == Qt.CheckState.Checked.value
        if not enabled:
            self._reset_weighting_ui()
            return
        self._reset_weighting_ui()

    def _selected_weight_params(self) -> set[str]:
        selected: set[str] = set()
        for combo, _slider in self.weight_rows:
            val = combo.currentData()
            if isinstance(val, str) and val:
                selected.add(val)
        return selected

    def _available_weight_params(self) -> list[str]:
        # PARAMETER_OPTIONS sind die “Parameter” im Tool
        selected = self._selected_weight_params()
        return [p for p in PARAMETER_OPTIONS if p not in selected]

    def _create_weight_row(self) -> None:
        available = self._available_weight_params()
        if not available:
            return

        row = QWidget()
        row_layout = QHBoxLayout(row)
        row_layout.setContentsMargins(0, 0, 0, 0)

        combo = QComboBox()
        combo.setFixedWidth(260)
        combo.addItem("Select parameter...", None)
        for p in available:
            combo.addItem(p, p)

        slider = QSlider(Qt.Orientation.Horizontal)
        slider.setMinimum(0)
        slider.setMaximum(3)
        slider.setValue(1)
        slider.setSingleStep(1)
        slider.setPageStep(1)
        slider.setFixedWidth(220)
        slider.setEnabled(False)  # erst aktivieren, wenn Parameter gewählt

        # Signals
        combo.currentIndexChanged.connect(lambda _i, c=combo, s=slider: self._on_weight_row_changed(c, s))
        slider.valueChanged.connect(lambda _v, c=combo, s=slider: self._on_weight_row_changed(c, s))

        row_layout.addWidget(combo)
        row_layout.addWidget(slider)
        row_layout.addStretch()

        self.weighting_rows_layout.addWidget(row)
        self.weight_rows.append((combo, slider))

    def _on_weight_row_changed(self, combo: QComboBox, slider: QSlider) -> None:
        # Wenn Toggle aus: ignorieren
        if self.weighting_enabled_cb is None or not self.weighting_enabled_cb.isChecked():
            return

        param = combo.currentData()
        if not isinstance(param, str) or not param:
            slider.setEnabled(False)
            return

        slider.setEnabled(True)

        # Gewicht speichern (int 0..3)
        self.parameter_weights[param] = float(slider.value())

        # Alle Combos neu aufbauen, damit keine Duplikate möglich sind
        self._rebuild_weight_combos(keep_current=True)

        # Wenn diese Zeile “aktiv” ist, nächste Zeile sicherstellen
        self._ensure_next_weight_row()

    def _rebuild_weight_combos(self, keep_current: bool = True) -> None:
        selected = self._selected_weight_params()

        for combo, slider in self.weight_rows:
            current = combo.currentData() if keep_current else None

            # Block signals während rebuild
            combo.blockSignals(True)
            combo.clear()
            combo.addItem("Select parameter...", None)

            # In dieser Combo darf current weiterhin drin sein
            allowed: list[str] = []
            for p in PARAMETER_OPTIONS:
                if p == current:
                    allowed.append(p)
                elif p not in selected:
                    allowed.append(p)

            for p in allowed:
                combo.addItem(p, p)

            # Restore selection
            if isinstance(current, str) and current:
                idx = combo.findData(current)
                combo.setCurrentIndex(idx if idx >= 0 else 0)
                slider.setEnabled(True)
            else:
                combo.setCurrentIndex(0)
                slider.setEnabled(False)

            combo.blockSignals(False)

    def _ensure_next_weight_row(self) -> None:
        if self.weighting_enabled_cb is None or not self.weighting_enabled_cb.isChecked():
            return

        available = self._available_weight_params()
        if not available:
            return

        if not self.weight_rows:
            self._create_weight_row()
            return

        last_combo, _last_slider = self.weight_rows[-1]
        last_param = last_combo.currentData()
        if isinstance(last_param, str) and last_param:
            self._create_weight_row()

    def _toggle_deselect_menu(self, state_val: int) -> None:
        """Toggle the deselect parameters menu button."""
        self.deselect_btn.setEnabled(state_val == Qt.CheckState.Checked.value)

    def _show_deselect_menu(self) -> None:
        """Show the deselect parameters menu."""
        self.deselect_menu.exec(self.deselect_btn.mapToGlobal(self.deselect_btn.rect().bottomLeft()))

    def _update_deselect_label(self) -> None:
        """Update the deselect button label."""
        count = sum(1 for action in self.deselect_param_checkboxes.values() if action.isChecked())
        self.deselect_btn.setText("None" if count == 0 else f"{count} deselected")

    def _open_group_participants(self) -> None:
        """Open the group participants dialog."""
        if not state.participants_cache:
            QMessageBox.information(self, "No data", "Load a TSV file first.")
            return

        dialog = GroupParticipantsDialog(self)
        if dialog.exec() == GroupParticipantsDialog.DialogCode.Accepted:
            self._refresh_group_task_toggles()

    def _open_group_tasks(self) -> None:
        """Open the group tasks dialog."""
        if not state.tasks_cache:
            QMessageBox.information(self, "No data", "Load a TSV file first.")
            return

        dialog = GroupTasksDialog(self)
        if dialog.exec() == GroupTasksDialog.DialogCode.Accepted:
            self._refresh_tasks_listbox()
            self._refresh_group_task_toggles()

    def _on_normalize(self) -> None:
        """Normalize numeric data per participant by baseline task 0a (fallback 0b)."""
        if state.df is None:
            QMessageBox.information(self, "No data", "Load a TSV file first.")
            return

        try:
            state.normalized_df = normalize_by_participant_baseline(
                state.df,
                participant_col="Participant",
                task_col="TOI",
                baseline_primary="0a",
                baseline_fallback="0b",
            )
        except Exception as e:
            QMessageBox.critical(self, "Normalize failed", str(e))
            return

        QMessageBox.information(
            self,
            "Normalization complete",
            "Normalized data stored in state.normalized_df (baseline: 0a, fallback: 0b).",
        )

    def _on_show_results(self) -> None:
        """Handle Show Results button click."""
        if state.df is None:
            QMessageBox.information(self, "No data", "Load a TSV file first.")
            return

        selected_groups = [gid for gid, cb in self.result_group_checkboxes.items() if cb.isChecked()]
        selected_tasks = [tid for tid, cb in self.result_task_checkboxes.items() if cb.isChecked()]
        domains = [name for name, cb in self.result_domain_vars.items() if cb.isChecked()]
        mode = self.mode_combo.currentText()

        deselected = []
        if self.deselect_enabled_cb.isChecked():
            deselected = [name for name, action in self.deselect_param_checkboxes.items() if action.isChecked()]

        msg = (
            f"Mode: {mode}\n"
            f"Groups selected: {len(selected_groups)}\n"
            f"Tasks selected: {len(selected_tasks)}\n"
            f"Result domains: {', '.join(domains) if domains else '(none)'}\n"
            f"Deselected parameters: {', '.join(deselected) if deselected else '(none)'}"
        )
        QMessageBox.information(self, "Show Results (placeholder)", msg)

    def _on_print_exec_summary(self) -> None:
        """Handle Print Executive Summary button click."""
        if state.df is None:
            QMessageBox.information(self, "No data", "Load a TSV file first.")
            return
        QMessageBox.information(
            self,
            "Executive Summary (placeholder)",
            "This will generate the executive summary later.",
        )
```

> Tokens: 15k sent, 4.8k received. Cost: $0.09 message, $1.09 session.  
> Applied edit to main_window.py  
> Commit f2490a4 feat: UI für Parametergewichtung mit dynamischen Zeilen hinzufügen  
> You can use /undo to undo and discard each aider commit.  

#### /code  
> Aider v0.86.1  
> Model: gpt-5.2 with whole edit format  
> Git repo: .git with 25 files  
> Repo-map: using 4096 tokens, auto refresh  
> Added data_processor.py to the chat.  
> Added dialogs.py to the chat.  
> Added eye_tracking_tool\dialogs.py to the chat.  
> Added main_window.py to the chat.  
> Added state.py to the chat.  
> Restored previous conversation history.  

#### in the weighting parameter box: all the sliders should move in 0.25 steps. also please add labels so one can see the choosen parameteer weight  

Ja, dafür sind Code-Änderungen nötig (nur in `main_window.py`).

## Benötigte Änderungen
1. **Slider-Schrittweite 0,25**: `QSlider` arbeitet intern mit Integer-Werten. Daher mappe ich den Bereich **0..3** auf **0..12** (12 Schritte à 0,25).  
   - `minimum=0`, `maximum=12`, `singleStep=1`, `pageStep=1`
   - Anzeige-/Speicherwert = `slider.value() / 4.0`
2. **Gewichts-Label pro Zeile**: Neben jedem Slider kommt ein `QLabel`, das den aktuellen Wert (z.B. `1.25`) anzeigt und bei Änderungen aktualisiert wird.
3. **Interne Speicherung**: `self.parameter_weights[param]` speichert jetzt den Float in 0,25er Schritten.

main_window.py
```
"""
Main window for the Eye Tracking Tool using PyQt6.
"""
from __future__ import annotations

from typing import Dict, Optional
import pandas as pd

from PyQt6.QtWidgets import (
    QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, QLabel, QPushButton,
    QListWidget, QLineEdit, QComboBox, QCheckBox, QGroupBox, QGridLayout,
    QFrame, QMessageBox, QFileDialog, QMenu, QMenuBar, QSplitter, QSlider
)
from PyQt6.QtCore import Qt, QSize
from PyQt6.QtGui import QAction

from state import state
from models import EXPECTED_COLUMNS, PARAMETER_OPTIONS
from data_processor import (
    validate_tsv_format,
    extract_participants,
    extract_tasks_from_toi,
    normalize_by_participant_baseline,
)
from dialogs import GroupParticipantsDialog, GroupTasksDialog


class MainWindow(QMainWindow):
    """Main application window."""

    def __init__(self) -> None:
        super().__init__()
        self.setWindowTitle("Eye Tracking Analysis Tool")
        self.setMinimumSize(1200, 720)

        # Result domain checkboxes
        self.result_domain_vars: Dict[str, QCheckBox] = {}

        # Result group/task checkboxes
        self.result_group_checkboxes: Dict[str, QCheckBox] = {}
        self.result_task_checkboxes: Dict[str, QCheckBox] = {}

        # Deselect parameters
        self.deselect_param_checkboxes: Dict[str, QCheckBox] = {}

        # Weighting parameters
        self.weighting_enabled_cb: Optional[QCheckBox] = None
        self.weight_rows: list[tuple[QComboBox, QSlider, QLabel]] = []
        self.parameter_weights: Dict[str, float] = {}

        self._setup_ui()

    # --- Weighting slider mapping (QSlider is int-based) ---
    def _weight_slider_to_float(self, slider_val: int) -> float:
        # 0..12 -> 0.00..3.00 in 0.25 steps
        return float(slider_val) / 4.0

    def _weight_float_to_slider(self, weight: float) -> int:
        # clamp + round to nearest 0.25 step
        w = max(0.0, min(3.0, float(weight)))
        return int(round(w * 4.0))

    def _format_weight(self, weight: float) -> str:
        return f"{weight:.2f}".rstrip("0").rstrip(".")

    def _setup_ui(self) -> None:
        central = QWidget()
        self.setCentralWidget(central)
        main_layout = QVBoxLayout(central)
        main_layout.setContentsMargins(10, 10, 10, 10)

        # Top bar
        topbar = QHBoxLayout()

        self.load_btn = QPushButton("Load TSV")
        self.load_btn.setFixedWidth(120)
        self.load_btn.clicked.connect(self._load_tsv)
        topbar.addWidget(self.load_btn)

        self.group_participants_btn = QPushButton("Group Participants")
        self.group_participants_btn.setFixedWidth(150)
        self.group_participants_btn.setEnabled(False)
        self.group_participants_btn.clicked.connect(self._open_group_participants)
        topbar.addWidget(self.group_participants_btn)

        # Button-Text wie gewünscht: "Name Tasks"
        self.group_tasks_btn = QPushButton("Name Tasks")
        self.group_tasks_btn.setFixedWidth(120)
        self.group_tasks_btn.setEnabled(False)
        self.group_tasks_btn.clicked.connect(self._open_group_tasks)
        topbar.addWidget(self.group_tasks_btn)

        self.file_path_edit = QLineEdit()
        self.file_path_edit.setReadOnly(True)
        self.file_path_edit.setPlaceholderText("No file loaded")
        topbar.addWidget(self.file_path_edit)

        main_layout.addLayout(topbar)

        # Listboxes section
        listbox_layout = QHBoxLayout()

        # Participants listbox
        left_widget = QWidget()
        left_layout = QVBoxLayout(left_widget)
        left_layout.setContentsMargins(0, 0, 0, 0)
        left_layout.addWidget(QLabel('Detected participants (from "Participant"):'))
        self.participants_list = QListWidget()
        self.participants_list.setMaximumHeight(120)
        left_layout.addWidget(self.participants_list)
        listbox_layout.addWidget(left_widget)

        # Tasks listbox
        right_widget = QWidget()
        right_layout = QVBoxLayout(right_widget)
        right_layout.setContentsMargins(0, 0, 0, 0)
        right_layout.addWidget(QLabel('Detected tasks (from "TOI" suffix):'))
        self.tasks_list = QListWidget()
        self.tasks_list.setMaximumHeight(120)
        right_layout.addWidget(self.tasks_list)
        listbox_layout.addWidget(right_widget)

        main_layout.addLayout(listbox_layout)

        # Separator
        separator = QFrame()
        separator.setFrameShape(QFrame.Shape.HLine)
        separator.setFrameShadow(QFrame.Shadow.Sunken)
        main_layout.addWidget(separator)

        # Results section
        results_label = QLabel("Results")
        results_label.setStyleSheet("font-weight: bold; font-size: 14px;")
        main_layout.addWidget(results_label)

        # Mode selection
        mode_layout = QHBoxLayout()
        mode_layout.addWidget(QLabel("Show results for:"))

        self.mode_combo = QComboBox()
        self.mode_combo.addItems([
            "Only group mean",
            "Each participant for selected groups",
            "Group mean and individual participants",
        ])
        self.mode_combo.setFixedWidth(350)
        mode_layout.addWidget(self.mode_combo)
        mode_layout.addStretch()
        main_layout.addLayout(mode_layout)

        # Groups and Tasks frames
        sel_layout = QHBoxLayout()

        self.groups_group = QGroupBox("Groups")
        self.groups_layout = QVBoxLayout(self.groups_group)
        sel_layout.addWidget(self.groups_group)

        self.tasks_group = QGroupBox("Tasks")
        self.tasks_layout = QGridLayout(self.tasks_group)
        sel_layout.addWidget(self.tasks_group)

        main_layout.addLayout(sel_layout)

        # Bottom row: Result domain and Deselect parameters
        bottom_layout = QHBoxLayout()

        # Result domain
        domain_group = QGroupBox("Result domain")
        domain_layout = QHBoxLayout(domain_group)

        for name in ["Rank", "Radar Chart", "Task Completion Time"]:
            cb = QCheckBox(name)
            cb.setChecked(True)
            self.result_domain_vars[name] = cb
            domain_layout.addWidget(cb)

        domain_layout.addStretch()
        bottom_layout.addWidget(domain_group)

        # Deselect parameters
        deselect_group = QGroupBox("Deselect Parameters")
        deselect_layout = QHBoxLayout(deselect_group)

        self.deselect_enabled_cb = QCheckBox("Enable Deselect")
        self.deselect_enabled_cb.stateChanged.connect(self._toggle_deselect_menu)
        deselect_layout.addWidget(self.deselect_enabled_cb)

        self.deselect_btn = QPushButton("None")
        self.deselect_btn.setEnabled(False)
        self.deselect_btn.clicked.connect(self._show_deselect_menu)
        deselect_layout.addWidget(self.deselect_btn)

        deselect_layout.addStretch()
        bottom_layout.addWidget(deselect_group)

        # Weighting parameters
        weighting_group = QGroupBox("Weighting Parameters")
        weighting_outer = QVBoxLayout(weighting_group)

        # Toggle row: checkbox + label rechts
        weighting_toggle_row = QHBoxLayout()
        self.weighting_enabled_cb = QCheckBox()
        self.weighting_enabled_cb.setChecked(False)
        self.weighting_enabled_cb.setEnabled(False)
        self.weighting_enabled_cb.stateChanged.connect(self._on_weighting_toggled)
        weighting_toggle_row.addWidget(self.weighting_enabled_cb)
        weighting_toggle_row.addWidget(QLabel("Enable custom parameter weights"))
        weighting_toggle_row.addStretch()
        weighting_outer.addLayout(weighting_toggle_row)

        # Container für dynamische Zeilen
        self.weighting_rows_container = QWidget()
        self.weighting_rows_layout = QVBoxLayout(self.weighting_rows_container)
        self.weighting_rows_layout.setContentsMargins(0, 0, 0, 0)
        self.weighting_rows_layout.setSpacing(6)
        weighting_outer.addWidget(self.weighting_rows_container)

        bottom_layout.addWidget(weighting_group)

        main_layout.addLayout(bottom_layout)

        # Action buttons
        action_layout = QHBoxLayout()

        self.show_results_btn = QPushButton("Show Results")
        self.show_results_btn.setFixedWidth(150)
        self.show_results_btn.setEnabled(False)
        self.show_results_btn.clicked.connect(self._on_show_results)
        action_layout.addWidget(self.show_results_btn)

        self.normalize_btn = QPushButton("Normalize")
        self.normalize_btn.setFixedWidth(150)
        self.normalize_btn.setEnabled(False)
        self.normalize_btn.clicked.connect(self._on_normalize)
        action_layout.addWidget(self.normalize_btn)

        self.exec_summary_btn = QPushButton("Print Executive Summary")
        self.exec_summary_btn.setFixedWidth(180)
        self.exec_summary_btn.setEnabled(False)
        self.exec_summary_btn.clicked.connect(self._on_print_exec_summary)
        action_layout.addWidget(self.exec_summary_btn)

        action_layout.addStretch()
        main_layout.addLayout(action_layout)

        main_layout.addStretch()

        # Initialize deselect menu
        self._build_deselect_menu()

        # Initialize weighting UI (disabled by default)
        self._reset_weighting_ui()

        # Initial population
        self._refresh_group_task_toggles()

    def _load_tsv(self) -> None:
        """Load and validate a TSV file."""
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            "Select TSV file",
            "",
            "TSV files (*.tsv);;All files (*.*)"
        )

        if not file_path:
            return

        # Validate format
        result = validate_tsv_format(file_path, EXPECTED_COLUMNS)
        if not result.ok:
            QMessageBox.critical(self, "Format error", result.message or "Unknown format error.")
            return

        # Load data
        try:
            state.df = pd.read_csv(file_path, sep="\t")
        except Exception as e:
            QMessageBox.critical(self, "Load error", str(e))
            return

        # Reset normalized data (must be recomputed for new file)
        state.normalized_df = None

        # Reset weighting UI/weights (parameters list may change later)
        if self.weighting_enabled_cb is not None:
            self.weighting_enabled_cb.setChecked(False)
        self._reset_weighting_ui()

        # Update UI with file path
        state.loaded_file_path = file_path
        self.file_path_edit.setText(file_path)

        # Reset caches
        state.participants_cache = []
        state.tasks_cache = []

        # Clear listboxes
        self.participants_list.clear()
        self.tasks_list.clear()

        # Disable action buttons during loading
        self.group_participants_btn.setEnabled(False)
        self.group_tasks_btn.setEnabled(False)
        self._set_main_action_buttons_enabled(False)

        # Extract participants
        try:
            state.participants_cache = extract_participants(state.df, column="Participant")
        except Exception as e:
            QMessageBox.critical(self, "Participant scan failed", str(e))
            state.df = None
            return

        # Extract tasks
        try:
            state.tasks_cache = extract_tasks_from_toi(state.df, column="TOI")
        except Exception as e:
            QMessageBox.critical(self, "Task scan failed", str(e))
            state.df = None
            return

        # Keep only labels for tasks that exist
        state.task_labels = {k: v for k, v in state.task_labels.items() if k in set(state.tasks_cache)}

        # Update listboxes
        for p in state.participants_cache:
            self.participants_list.addItem(p)

        self._refresh_tasks_listbox()

        # Enable group buttons
        self.group_participants_btn.setEnabled(bool(state.participants_cache))
        self.group_tasks_btn.setEnabled(bool(state.tasks_cache))

        if self.weighting_enabled_cb is not None:
            self.weighting_enabled_cb.setEnabled(True)

        self._set_main_action_buttons_enabled(True)
        self._refresh_group_task_toggles()

        QMessageBox.information(
            self,
            "Success",
            f"Loaded {len(state.df)} rows.\n"
            f"Found {len(state.participants_cache)} participants and {len(state.tasks_cache)} tasks."
        )

    def _refresh_tasks_listbox(self) -> None:
        """Refresh the tasks listbox with formatted task names."""
        self.tasks_list.clear()
        for t in state.tasks_cache:
            self.tasks_list.addItem(state.format_task(t))

    def _set_main_action_buttons_enabled(self, enabled: bool) -> None:
        """Enable or disable main action buttons."""
        self.show_results_btn.setEnabled(enabled)
        self.normalize_btn.setEnabled(enabled)
        self.exec_summary_btn.setEnabled(enabled)

    def _refresh_group_task_toggles(self) -> None:
        """Refresh the checkbox lists in the Results section."""
        # Clear existing group checkboxes
        while self.groups_layout.count():
            item = self.groups_layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()

        # Clear existing task checkboxes
        while self.tasks_layout.count():
            item = self.tasks_layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()

        self.result_group_checkboxes.clear()
        self.result_task_checkboxes.clear()

        # Groups toggles
        effective_groups = state.get_effective_participant_groups()
        effective_names = state.get_effective_group_names()

        if not effective_groups:
            label = QLabel("(Load a TSV file first)")
            label.setStyleSheet("color: #666;")
            self.groups_layout.addWidget(label)
        else:
            for gid in effective_groups.keys():
                name = effective_names.get(gid, gid)
                cb = QCheckBox(name)
                cb.setChecked(True)
                self.result_group_checkboxes[gid] = cb
                self.groups_layout.addWidget(cb)

        self.groups_layout.addStretch()

        # Tasks toggles
        if not state.tasks_cache:
            label = QLabel("(Load a TSV file first)")
            label.setStyleSheet("color: #666;")
            self.tasks_layout.addWidget(label, 0, 0)
            return

        cols = 8
        row = 0
        col = 0
        for tid in state.tasks_cache:
            cb = QCheckBox(state.format_task(tid))
            cb.setChecked(True)
            self.result_task_checkboxes[tid] = cb
            self.tasks_layout.addWidget(cb, row, col)
            col += 1
            if col >= cols:
                col = 0
                row += 1

    def _build_deselect_menu(self) -> None:
        """Build the deselect parameters menu."""
        self.deselect_menu = QMenu(self)
        self.deselect_param_checkboxes.clear()

        for name in PARAMETER_OPTIONS:
            action = QAction(name, self)
            action.setCheckable(True)
            action.triggered.connect(self._update_deselect_label)
            self.deselect_menu.addAction(action)
            self.deselect_param_checkboxes[name] = action

    def _reset_weighting_ui(self) -> None:
        """Clear all weighting rows and internal weights; keep toggle state."""
        self.parameter_weights.clear()
        self.weight_rows.clear()

        # Clear UI rows
        if hasattr(self, "weighting_rows_layout"):
            while self.weighting_rows_layout.count():
                item = self.weighting_rows_layout.takeAt(0)
                if item.widget():
                    item.widget().deleteLater()

        # If enabled and we have parameters, create first row
        if self.weighting_enabled_cb is not None and self.weighting_enabled_cb.isChecked():
            self._ensure_next_weight_row()

    def _on_weighting_toggled(self, state_val: int) -> None:
        enabled = state_val == Qt.CheckState.Checked.value
        if not enabled:
            self._reset_weighting_ui()
            return
        self._reset_weighting_ui()

    def _selected_weight_params(self) -> set[str]:
        selected: set[str] = set()
        for combo, _slider, _lbl in self.weight_rows:
            val = combo.currentData()
            if isinstance(val, str) and val:
                selected.add(val)
        return selected

    def _available_weight_params(self) -> list[str]:
        # PARAMETER_OPTIONS sind die “Parameter” im Tool
        selected = self._selected_weight_params()
        return [p for p in PARAMETER_OPTIONS if p not in selected]

    def _create_weight_row(self) -> None:
        available = self._available_weight_params()
        if not available:
            return

        row = QWidget()
        row_layout = QHBoxLayout(row)
        row_layout.setContentsMargins(0, 0, 0, 0)

        combo = QComboBox()
        combo.setFixedWidth(260)
        combo.addItem("Select parameter...", None)
        for p in available:
            combo.addItem(p, p)

        slider = QSlider(Qt.Orientation.Horizontal)
        # 0..3 in 0.25 steps => 0..12
        slider.setMinimum(0)
        slider.setMaximum(12)
        slider.setValue(self._weight_float_to_slider(1.0))
        slider.setSingleStep(1)
        slider.setPageStep(1)
        slider.setFixedWidth(220)
        slider.setEnabled(False)  # erst aktivieren, wenn Parameter gewählt

        value_lbl = QLabel(self._format_weight(1.0))
        value_lbl.setFixedWidth(44)
        value_lbl.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        value_lbl.setEnabled(False)

        # Signals
        combo.currentIndexChanged.connect(
            lambda _i, c=combo, s=slider, l=value_lbl: self._on_weight_row_changed(c, s, l)
        )
        slider.valueChanged.connect(
            lambda _v, c=combo, s=slider, l=value_lbl: self._on_weight_row_changed(c, s, l)
        )

        row_layout.addWidget(combo)
        row_layout.addWidget(slider)
        row_layout.addWidget(value_lbl)
        row_layout.addStretch()

        self.weighting_rows_layout.addWidget(row)
        self.weight_rows.append((combo, slider, value_lbl))

    def _on_weight_row_changed(self, combo: QComboBox, slider: QSlider, value_lbl: QLabel) -> None:
        # Wenn Toggle aus: ignorieren
        if self.weighting_enabled_cb is None or not self.weighting_enabled_cb.isChecked():
            return

        param = combo.currentData()
        if not isinstance(param, str) or not param:
            slider.setEnabled(False)
            value_lbl.setEnabled(False)
            return

        slider.setEnabled(True)
        value_lbl.setEnabled(True)

        weight = self._weight_slider_to_float(slider.value())
        value_lbl.setText(self._format_weight(weight))

        # Gewicht speichern (0.00..3.00 in 0.25er Schritten)
        self.parameter_weights[param] = float(weight)

        # Alle Combos neu aufbauen, damit keine Duplikate möglich sind
        self._rebuild_weight_combos(keep_current=True)

        # Wenn diese Zeile “aktiv” ist, nächste Zeile sicherstellen
        self._ensure_next_weight_row()

    def _rebuild_weight_combos(self, keep_current: bool = True) -> None:
        selected = self._selected_weight_params()

        for combo, slider, value_lbl in self.weight_rows:
            current = combo.currentData() if keep_current else None

            # Block signals während rebuild
            combo.blockSignals(True)
            combo.clear()
            combo.addItem("Select parameter...", None)

            # In dieser Combo darf current weiterhin drin sein
            allowed: list[str] = []
            for p in PARAMETER_OPTIONS:
                if p == current:
                    allowed.append(p)
                elif p not in selected:
                    allowed.append(p)

            for p in allowed:
                combo.addItem(p, p)

            # Restore selection
            if isinstance(current, str) and current:
                idx = combo.findData(current)
                combo.setCurrentIndex(idx if idx >= 0 else 0)
                slider.setEnabled(True)
                value_lbl.setEnabled(True)

                # Label/weight sync
                weight = self._weight_slider_to_float(slider.value())
                value_lbl.setText(self._format_weight(weight))
                self.parameter_weights[current] = float(weight)
            else:
                combo.setCurrentIndex(0)
                slider.setEnabled(False)
                value_lbl.setEnabled(False)

            combo.blockSignals(False)

    def _ensure_next_weight_row(self) -> None:
        if self.weighting_enabled_cb is None or not self.weighting_enabled_cb.isChecked():
            return

        available = self._available_weight_params()
        if not available:
            return

        if not self.weight_rows:
            self._create_weight_row()
            return

        last_combo, _last_slider, _last_lbl = self.weight_rows[-1]
        last_param = last_combo.currentData()
        if isinstance(last_param, str) and last_param:
            self._create_weight_row()

    def _toggle_deselect_menu(self, state_val: int) -> None:
        """Toggle the deselect parameters menu button."""
        self.deselect_btn.setEnabled(state_val == Qt.CheckState.Checked.value)

    def _show_deselect_menu(self) -> None:
        """Show the deselect parameters menu."""
        self.deselect_menu.exec(self.deselect_btn.mapToGlobal(self.deselect_btn.rect().bottomLeft()))

    def _update_deselect_label(self) -> None:
        """Update the deselect button label."""
        count = sum(1 for action in self.deselect_param_checkboxes.values() if action.isChecked())
        self.deselect_btn.setText("None" if count == 0 else f"{count} deselected")

    def _open_group_participants(self) -> None:
        """Open the group participants dialog."""
        if not state.participants_cache:
            QMessageBox.information(self, "No data", "Load a TSV file first.")
            return

        dialog = GroupParticipantsDialog(self)
        if dialog.exec() == GroupParticipantsDialog.DialogCode.Accepted:
            self._refresh_group_task_toggles()

    def _open_group_tasks(self) -> None:
        """Open the group tasks dialog."""
        if not state.tasks_cache:
            QMessageBox.information(self, "No data", "Load a TSV file first.")
            return

        dialog = GroupTasksDialog(self)
        if dialog.exec() == GroupTasksDialog.DialogCode.Accepted:
            self._refresh_tasks_listbox()
            self._refresh_group_task_toggles()

    def _on_normalize(self) -> None:
        """Normalize numeric data per participant by baseline task 0a (fallback 0b)."""
        if state.df is None:
            QMessageBox.information(self, "No data", "Load a TSV file first.")
            return

        try:
            state.normalized_df = normalize_by_participant_baseline(
                state.df,
                participant_col="Participant",
                task_col="TOI",
                baseline_primary="0a",
                baseline_fallback="0b",
            )
        except Exception as e:
            QMessageBox.critical(self, "Normalize failed", str(e))
            return

        QMessageBox.information(
            self,
            "Normalization complete",
            "Normalized data stored in state.normalized_df (baseline: 0a, fallback: 0b).",
        )

    def _on_show_results(self) -> None:
        """Handle Show Results button click."""
        if state.df is None:
            QMessageBox.information(self, "No data", "Load a TSV file first.")
            return

        selected_groups = [gid for gid, cb in self.result_group_checkboxes.items() if cb.isChecked()]
        selected_tasks = [tid for tid, cb in self.result_task_checkboxes.items() if cb.isChecked()]
        domains = [name for name, cb in self.result_domain_vars.items() if cb.isChecked()]
        mode = self.mode_combo.currentText()

        deselected = []
        if self.deselect_enabled_cb.isChecked():
            deselected = [name for name, action in self.deselect_param_checkboxes.items() if action.isChecked()]

        msg = (
            f"Mode: {mode}\n"
            f"Groups selected: {len(selected_groups)}\n"
            f"Tasks selected: {len(selected_tasks)}\n"
            f"Result domains: {', '.join(domains) if domains else '(none)'}\n"
            f"Deselected parameters: {', '.join(deselected) if deselected else '(none)'}"
        )
        QMessageBox.information(self, "Show Results (placeholder)", msg)

    def _on_print_exec_summary(self) -> None:
        """Handle Print Executive Summary button click."""
        if state.df is None:
            QMessageBox.information(self, "No data", "Load a TSV file first.")
            return
        QMessageBox.information(
            self,
            "Executive Summary (placeholder)",
            "This will generate the executive summary later.",
        )
```

> Tokens: 16k sent, 5.3k received. Cost: $0.10 message, $1.19 session.  
> Applied edit to main_window.py  
> Commit 877b917 feat: Gewichtungs-Slider in 0,25er Schritten mit Wert-Labels anzeigen  
> You can use /undo to undo and discard each aider commit.  

#### when `show_results_btn` is pressed include the values of `parameter_weights`  

Ja, dafür sind Code-Änderungen nötig.

## Benötigte Änderung
In `main_window.py` muss in `_on_show_results()` die aktuell gesetzten `parameter_weights` (nur wenn „Enable custom parameter weights“ aktiv ist) in die angezeigte MessageBox aufgenommen werden. Dabei ist sinnvoll:
- Wenn Weighting deaktiviert ist: `(disabled)`
- Wenn aktiviert, aber keine Parameter gewählt: `(none)`
- Sonst: Liste `Parameter = Gewicht` (sortiert, gut lesbar)

main_window.py
```
"""
Main window for the Eye Tracking Tool using PyQt6.
"""
from __future__ import annotations

from typing import Dict, Optional
import pandas as pd

from PyQt6.QtWidgets import (
    QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, QLabel, QPushButton,
    QListWidget, QLineEdit, QComboBox, QCheckBox, QGroupBox, QGridLayout,
    QFrame, QMessageBox, QFileDialog, QMenu, QMenuBar, QSplitter, QSlider
)
from PyQt6.QtCore import Qt, QSize
from PyQt6.QtGui import QAction

from state import state
from models import EXPECTED_COLUMNS, PARAMETER_OPTIONS
from data_processor import (
    validate_tsv_format,
    extract_participants,
    extract_tasks_from_toi,
    normalize_by_participant_baseline,
)
from dialogs import GroupParticipantsDialog, GroupTasksDialog


class MainWindow(QMainWindow):
    """Main application window."""

    def __init__(self) -> None:
        super().__init__()
        self.setWindowTitle("Eye Tracking Analysis Tool")
        self.setMinimumSize(1200, 720)

        # Result domain checkboxes
        self.result_domain_vars: Dict[str, QCheckBox] = {}

        # Result group/task checkboxes
        self.result_group_checkboxes: Dict[str, QCheckBox] = {}
        self.result_task_checkboxes: Dict[str, QCheckBox] = {}

        # Deselect parameters
        self.deselect_param_checkboxes: Dict[str, QCheckBox] = {}

        # Weighting parameters
        self.weighting_enabled_cb: Optional[QCheckBox] = None
        self.weight_rows: list[tuple[QComboBox, QSlider, QLabel]] = []
        self.parameter_weights: Dict[str, float] = {}

        self._setup_ui()

    # --- Weighting slider mapping (QSlider is int-based) ---
    def _weight_slider_to_float(self, slider_val: int) -> float:
        # 0..12 -> 0.00..3.00 in 0.25 steps
        return float(slider_val) / 4.0

    def _weight_float_to_slider(self, weight: float) -> int:
        # clamp + round to nearest 0.25 step
        w = max(0.0, min(3.0, float(weight)))
        return int(round(w * 4.0))

    def _format_weight(self, weight: float) -> str:
        return f"{weight:.2f}".rstrip("0").rstrip(".")

    def _setup_ui(self) -> None:
        central = QWidget()
        self.setCentralWidget(central)
        main_layout = QVBoxLayout(central)
        main_layout.setContentsMargins(10, 10, 10, 10)

        # Top bar
        topbar = QHBoxLayout()

        self.load_btn = QPushButton("Load TSV")
        self.load_btn.setFixedWidth(120)
        self.load_btn.clicked.connect(self._load_tsv)
        topbar.addWidget(self.load_btn)

        self.group_participants_btn = QPushButton("Group Participants")
        self.group_participants_btn.setFixedWidth(150)
        self.group_participants_btn.setEnabled(False)
        self.group_participants_btn.clicked.connect(self._open_group_participants)
        topbar.addWidget(self.group_participants_btn)

        # Button-Text wie gewünscht: "Name Tasks"
        self.group_tasks_btn = QPushButton("Name Tasks")
        self.group_tasks_btn.setFixedWidth(120)
        self.group_tasks_btn.setEnabled(False)
        self.group_tasks_btn.clicked.connect(self._open_group_tasks)
        topbar.addWidget(self.group_tasks_btn)

        self.file_path_edit = QLineEdit()
        self.file_path_edit.setReadOnly(True)
        self.file_path_edit.setPlaceholderText("No file loaded")
        topbar.addWidget(self.file_path_edit)

        main_layout.addLayout(topbar)

        # Listboxes section
        listbox_layout = QHBoxLayout()

        # Participants listbox
        left_widget = QWidget()
        left_layout = QVBoxLayout(left_widget)
        left_layout.setContentsMargins(0, 0, 0, 0)
        left_layout.addWidget(QLabel('Detected participants (from "Participant"):'))
        self.participants_list = QListWidget()
        self.participants_list.setMaximumHeight(120)
        left_layout.addWidget(self.participants_list)
        listbox_layout.addWidget(left_widget)

        # Tasks listbox
        right_widget = QWidget()
        right_layout = QVBoxLayout(right_widget)
        right_layout.setContentsMargins(0, 0, 0, 0)
        right_layout.addWidget(QLabel('Detected tasks (from "TOI" suffix):'))
        self.tasks_list = QListWidget()
        self.tasks_list.setMaximumHeight(120)
        right_layout.addWidget(self.tasks_list)
        listbox_layout.addWidget(right_widget)

        main_layout.addLayout(listbox_layout)

        # Separator
        separator = QFrame()
        separator.setFrameShape(QFrame.Shape.HLine)
        separator.setFrameShadow(QFrame.Shadow.Sunken)
        main_layout.addWidget(separator)

        # Results section
        results_label = QLabel("Results")
        results_label.setStyleSheet("font-weight: bold; font-size: 14px;")
        main_layout.addWidget(results_label)

        # Mode selection
        mode_layout = QHBoxLayout()
        mode_layout.addWidget(QLabel("Show results for:"))

        self.mode_combo = QComboBox()
        self.mode_combo.addItems([
            "Only group mean",
            "Each participant for selected groups",
            "Group mean and individual participants",
        ])
        self.mode_combo.setFixedWidth(350)
        mode_layout.addWidget(self.mode_combo)
        mode_layout.addStretch()
        main_layout.addLayout(mode_layout)

        # Groups and Tasks frames
        sel_layout = QHBoxLayout()

        self.groups_group = QGroupBox("Groups")
        self.groups_layout = QVBoxLayout(self.groups_group)
        sel_layout.addWidget(self.groups_group)

        self.tasks_group = QGroupBox("Tasks")
        self.tasks_layout = QGridLayout(self.tasks_group)
        sel_layout.addWidget(self.tasks_group)

        main_layout.addLayout(sel_layout)

        # Bottom row: Result domain and Deselect parameters
        bottom_layout = QHBoxLayout()

        # Result domain
        domain_group = QGroupBox("Result domain")
        domain_layout = QHBoxLayout(domain_group)

        for name in ["Rank", "Radar Chart", "Task Completion Time"]:
            cb = QCheckBox(name)
            cb.setChecked(True)
            self.result_domain_vars[name] = cb
            domain_layout.addWidget(cb)

        domain_layout.addStretch()
        bottom_layout.addWidget(domain_group)

        # Deselect parameters
        deselect_group = QGroupBox("Deselect Parameters")
        deselect_layout = QHBoxLayout(deselect_group)

        self.deselect_enabled_cb = QCheckBox("Enable Deselect")
        self.deselect_enabled_cb.stateChanged.connect(self._toggle_deselect_menu)
        deselect_layout.addWidget(self.deselect_enabled_cb)

        self.deselect_btn = QPushButton("None")
        self.deselect_btn.setEnabled(False)
        self.deselect_btn.clicked.connect(self._show_deselect_menu)
        deselect_layout.addWidget(self.deselect_btn)

        deselect_layout.addStretch()
        bottom_layout.addWidget(deselect_group)

        # Weighting parameters
        weighting_group = QGroupBox("Weighting Parameters")
        weighting_outer = QVBoxLayout(weighting_group)

        # Toggle row: checkbox + label rechts
        weighting_toggle_row = QHBoxLayout()
        self.weighting_enabled_cb = QCheckBox()
        self.weighting_enabled_cb.setChecked(False)
        self.weighting_enabled_cb.setEnabled(False)
        self.weighting_enabled_cb.stateChanged.connect(self._on_weighting_toggled)
        weighting_toggle_row.addWidget(self.weighting_enabled_cb)
        weighting_toggle_row.addWidget(QLabel("Enable custom parameter weights"))
        weighting_toggle_row.addStretch()
        weighting_outer.addLayout(weighting_toggle_row)

        # Container für dynamische Zeilen
        self.weighting_rows_container = QWidget()
        self.weighting_rows_layout = QVBoxLayout(self.weighting_rows_container)
        self.weighting_rows_layout.setContentsMargins(0, 0, 0, 0)
        self.weighting_rows_layout.setSpacing(6)
        weighting_outer.addWidget(self.weighting_rows_container)

        bottom_layout.addWidget(weighting_group)

        main_layout.addLayout(bottom_layout)

        # Action buttons
        action_layout = QHBoxLayout()

        self.show_results_btn = QPushButton("Show Results")
        self.show_results_btn.setFixedWidth(150)
        self.show_results_btn.setEnabled(False)
        self.show_results_btn.clicked.connect(self._on_show_results)
        action_layout.addWidget(self.show_results_btn)

        self.normalize_btn = QPushButton("Normalize")
        self.normalize_btn.setFixedWidth(150)
        self.normalize_btn.setEnabled(False)
        self.normalize_btn.clicked.connect(self._on_normalize)
        action_layout.addWidget(self.normalize_btn)

        self.exec_summary_btn = QPushButton("Print Executive Summary")
        self.exec_summary_btn.setFixedWidth(180)
        self.exec_summary_btn.setEnabled(False)
        self.exec_summary_btn.clicked.connect(self._on_print_exec_summary)
        action_layout.addWidget(self.exec_summary_btn)

        action_layout.addStretch()
        main_layout.addLayout(action_layout)

        main_layout.addStretch()

        # Initialize deselect menu
        self._build_deselect_menu()

        # Initialize weighting UI (disabled by default)
        self._reset_weighting_ui()

        # Initial population
        self._refresh_group_task_toggles()

    def _load_tsv(self) -> None:
        """Load and validate a TSV file."""
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            "Select TSV file",
            "",
            "TSV files (*.tsv);;All files (*.*)"
        )

        if not file_path:
            return

        # Validate format
        result = validate_tsv_format(file_path, EXPECTED_COLUMNS)
        if not result.ok:
            QMessageBox.critical(self, "Format error", result.message or "Unknown format error.")
            return

        # Load data
        try:
            state.df = pd.read_csv(file_path, sep="\t")
        except Exception as e:
            QMessageBox.critical(self, "Load error", str(e))
            return

        # Reset normalized data (must be recomputed for new file)
        state.normalized_df = None

        # Reset weighting UI/weights (parameters list may change later)
        if self.weighting_enabled_cb is not None:
            self.weighting_enabled_cb.setChecked(False)
        self._reset_weighting_ui()

        # Update UI with file path
        state.loaded_file_path = file_path
        self.file_path_edit.setText(file_path)

        # Reset caches
        state.participants_cache = []
        state.tasks_cache = []

        # Clear listboxes
        self.participants_list.clear()
        self.tasks_list.clear()

        # Disable action buttons during loading
        self.group_participants_btn.setEnabled(False)
        self.group_tasks_btn.setEnabled(False)
        self._set_main_action_buttons_enabled(False)

        # Extract participants
        try:
            state.participants_cache = extract_participants(state.df, column="Participant")
        except Exception as e:
            QMessageBox.critical(self, "Participant scan failed", str(e))
            state.df = None
            return

        # Extract tasks
        try:
            state.tasks_cache = extract_tasks_from_toi(state.df, column="TOI")
        except Exception as e:
            QMessageBox.critical(self, "Task scan failed", str(e))
            state.df = None
            return

        # Keep only labels for tasks that exist
        state.task_labels = {k: v for k, v in state.task_labels.items() if k in set(state.tasks_cache)}

        # Update listboxes
        for p in state.participants_cache:
            self.participants_list.addItem(p)

        self._refresh_tasks_listbox()

        # Enable group buttons
        self.group_participants_btn.setEnabled(bool(state.participants_cache))
        self.group_tasks_btn.setEnabled(bool(state.tasks_cache))

        if self.weighting_enabled_cb is not None:
            self.weighting_enabled_cb.setEnabled(True)

        self._set_main_action_buttons_enabled(True)
        self._refresh_group_task_toggles()

        QMessageBox.information(
            self,
            "Success",
            f"Loaded {len(state.df)} rows.\n"
            f"Found {len(state.participants_cache)} participants and {len(state.tasks_cache)} tasks."
        )

    def _refresh_tasks_listbox(self) -> None:
        """Refresh the tasks listbox with formatted task names."""
        self.tasks_list.clear()
        for t in state.tasks_cache:
            self.tasks_list.addItem(state.format_task(t))

    def _set_main_action_buttons_enabled(self, enabled: bool) -> None:
        """Enable or disable main action buttons."""
        self.show_results_btn.setEnabled(enabled)
        self.normalize_btn.setEnabled(enabled)
        self.exec_summary_btn.setEnabled(enabled)

    def _refresh_group_task_toggles(self) -> None:
        """Refresh the checkbox lists in the Results section."""
        # Clear existing group checkboxes
        while self.groups_layout.count():
            item = self.groups_layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()

        # Clear existing task checkboxes
        while self.tasks_layout.count():
            item = self.tasks_layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()

        self.result_group_checkboxes.clear()
        self.result_task_checkboxes.clear()

        # Groups toggles
        effective_groups = state.get_effective_participant_groups()
        effective_names = state.get_effective_group_names()

        if not effective_groups:
            label = QLabel("(Load a TSV file first)")
            label.setStyleSheet("color: #666;")
            self.groups_layout.addWidget(label)
        else:
            for gid in effective_groups.keys():
                name = effective_names.get(gid, gid)
                cb = QCheckBox(name)
                cb.setChecked(True)
                self.result_group_checkboxes[gid] = cb
                self.groups_layout.addWidget(cb)

        self.groups_layout.addStretch()

        # Tasks toggles
        if not state.tasks_cache:
            label = QLabel("(Load a TSV file first)")
            label.setStyleSheet("color: #666;")
            self.tasks_layout.addWidget(label, 0, 0)
            return

        cols = 8
        row = 0
        col = 0
        for tid in state.tasks_cache:
            cb = QCheckBox(state.format_task(tid))
            cb.setChecked(True)
            self.result_task_checkboxes[tid] = cb
            self.tasks_layout.addWidget(cb, row, col)
            col += 1
            if col >= cols:
                col = 0
                row += 1

    def _build_deselect_menu(self) -> None:
        """Build the deselect parameters menu."""
        self.deselect_menu = QMenu(self)
        self.deselect_param_checkboxes.clear()

        for name in PARAMETER_OPTIONS:
            action = QAction(name, self)
            action.setCheckable(True)
            action.triggered.connect(self._update_deselect_label)
            self.deselect_menu.addAction(action)
            self.deselect_param_checkboxes[name] = action

    def _reset_weighting_ui(self) -> None:
        """Clear all weighting rows and internal weights; keep toggle state."""
        self.parameter_weights.clear()
        self.weight_rows.clear()

        # Clear UI rows
        if hasattr(self, "weighting_rows_layout"):
            while self.weighting_rows_layout.count():
                item = self.weighting_rows_layout.takeAt(0)
                if item.widget():
                    item.widget().deleteLater()

        # If enabled and we have parameters, create first row
        if self.weighting_enabled_cb is not None and self.weighting_enabled_cb.isChecked():
            self._ensure_next_weight_row()

    def _on_weighting_toggled(self, state_val: int) -> None:
        enabled = state_val == Qt.CheckState.Checked.value
        if not enabled:
            self._reset_weighting_ui()
            return
        self._reset_weighting_ui()

    def _selected_weight_params(self) -> set[str]:
        selected: set[str] = set()
        for combo, _slider, _lbl in self.weight_rows:
            val = combo.currentData()
            if isinstance(val, str) and val:
                selected.add(val)
        return selected

    def _available_weight_params(self) -> list[str]:
        # PARAMETER_OPTIONS sind die “Parameter” im Tool
        selected = self._selected_weight_params()
        return [p for p in PARAMETER_OPTIONS if p not in selected]

    def _create_weight_row(self) -> None:
        available = self._available_weight_params()
        if not available:
            return

        row = QWidget()
        row_layout = QHBoxLayout(row)
        row_layout.setContentsMargins(0, 0, 0, 0)

        combo = QComboBox()
        combo.setFixedWidth(260)
        combo.addItem("Select parameter...", None)
        for p in available:
            combo.addItem(p, p)

        slider = QSlider(Qt.Orientation.Horizontal)
        # 0..3 in 0.25 steps => 0..12
        slider.setMinimum(0)
        slider.setMaximum(12)
        slider.setValue(self._weight_float_to_slider(1.0))
        slider.setSingleStep(1)
        slider.setPageStep(1)
        slider.setFixedWidth(220)
        slider.setEnabled(False)  # erst aktivieren, wenn Parameter gewählt

        value_lbl = QLabel(self._format_weight(1.0))
        value_lbl.setFixedWidth(44)
        value_lbl.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        value_lbl.setEnabled(False)

        # Signals
        combo.currentIndexChanged.connect(
            lambda _i, c=combo, s=slider, l=value_lbl: self._on_weight_row_changed(c, s, l)
        )
        slider.valueChanged.connect(
            lambda _v, c=combo, s=slider, l=value_lbl: self._on_weight_row_changed(c, s, l)
        )

        row_layout.addWidget(combo)
        row_layout.addWidget(slider)
        row_layout.addWidget(value_lbl)
        row_layout.addStretch()

        self.weighting_rows_layout.addWidget(row)
        self.weight_rows.append((combo, slider, value_lbl))

    def _on_weight_row_changed(self, combo: QComboBox, slider: QSlider, value_lbl: QLabel) -> None:
        # Wenn Toggle aus: ignorieren
        if self.weighting_enabled_cb is None or not self.weighting_enabled_cb.isChecked():
            return

        param = combo.currentData()
        if not isinstance(param, str) or not param:
            slider.setEnabled(False)
            value_lbl.setEnabled(False)
            return

        slider.setEnabled(True)
        value_lbl.setEnabled(True)

        weight = self._weight_slider_to_float(slider.value())
        value_lbl.setText(self._format_weight(weight))

        # Gewicht speichern (0.00..3.00 in 0.25er Schritten)
        self.parameter_weights[param] = float(weight)

        # Alle Combos neu aufbauen, damit keine Duplikate möglich sind
        self._rebuild_weight_combos(keep_current=True)

        # Wenn diese Zeile “aktiv” ist, nächste Zeile sicherstellen
        self._ensure_next_weight_row()

    def _rebuild_weight_combos(self, keep_current: bool = True) -> None:
        selected = self._selected_weight_params()

        for combo, slider, value_lbl in self.weight_rows:
            current = combo.currentData() if keep_current else None

            # Block signals während rebuild
            combo.blockSignals(True)
            combo.clear()
            combo.addItem("Select parameter...", None)

            # In dieser Combo darf current weiterhin drin sein
            allowed: list[str] = []
            for p in PARAMETER_OPTIONS:
                if p == current:
                    allowed.append(p)
                elif p not in selected:
                    allowed.append(p)

            for p in allowed:
                combo.addItem(p, p)

            # Restore selection
            if isinstance(current, str) and current:
                idx = combo.findData(current)
                combo.setCurrentIndex(idx if idx >= 0 else 0)
                slider.setEnabled(True)
                value_lbl.setEnabled(True)

                # Label/weight sync
                weight = self._weight_slider_to_float(slider.value())
                value_lbl.setText(self._format_weight(weight))
                self.parameter_weights[current] = float(weight)
            else:
                combo.setCurrentIndex(0)
                slider.setEnabled(False)
                value_lbl.setEnabled(False)

            combo.blockSignals(False)

    def _ensure_next_weight_row(self) -> None:
        if self.weighting_enabled_cb is None or not self.weighting_enabled_cb.isChecked():
            return

        available = self._available_weight_params()
        if not available:
            return

        if not self.weight_rows:
            self._create_weight_row()
            return

        last_combo, _last_slider, _last_lbl = self.weight_rows[-1]
        last_param = last_combo.currentData()
        if isinstance(last_param, str) and last_param:
            self._create_weight_row()

    def _toggle_deselect_menu(self, state_val: int) -> None:
        """Toggle the deselect parameters menu button."""
        self.deselect_btn.setEnabled(state_val == Qt.CheckState.Checked.value)

    def _show_deselect_menu(self) -> None:
        """Show the deselect parameters menu."""
        self.deselect_menu.exec(self.deselect_btn.mapToGlobal(self.deselect_btn.rect().bottomLeft()))

    def _update_deselect_label(self) -> None:
        """Update the deselect button label."""
        count = sum(1 for action in self.deselect_param_checkboxes.values() if action.isChecked())
        self.deselect_btn.setText("None" if count == 0 else f"{count} deselected")

    def _open_group_participants(self) -> None:
        """Open the group participants dialog."""
        if not state.participants_cache:
            QMessageBox.information(self, "No data", "Load a TSV file first.")
            return

        dialog = GroupParticipantsDialog(self)
        if dialog.exec() == GroupParticipantsDialog.DialogCode.Accepted:
            self._refresh_group_task_toggles()

    def _open_group_tasks(self) -> None:
        """Open the group tasks dialog."""
        if not state.tasks_cache:
            QMessageBox.information(self, "No data", "Load a TSV file first.")
            return

        dialog = GroupTasksDialog(self)
        if dialog.exec() == GroupTasksDialog.DialogCode.Accepted:
            self._refresh_tasks_listbox()
            self._refresh_group_task_toggles()

    def _on_normalize(self) -> None:
        """Normalize numeric data per participant by baseline task 0a (fallback 0b)."""
        if state.df is None:
            QMessageBox.information(self, "No data", "Load a TSV file first.")
            return

        try:
            state.normalized_df = normalize_by_participant_baseline(
                state.df,
                participant_col="Participant",
                task_col="TOI",
                baseline_primary="0a",
                baseline_fallback="0b",
            )
        except Exception as e:
            QMessageBox.critical(self, "Normalize failed", str(e))
            return

        QMessageBox.information(
            self,
            "Normalization complete",
            "Normalized data stored in state.normalized_df (baseline: 0a, fallback: 0b).",
        )

    def _on_show_results(self) -> None:
        """Handle Show Results button click."""
        if state.df is None:
            QMessageBox.information(self, "No data", "Load a TSV file first.")
            return

        selected_groups = [gid for gid, cb in self.result_group_checkboxes.items() if cb.isChecked()]
        selected_tasks = [tid for tid, cb in self.result_task_checkboxes.items() if cb.isChecked()]
        domains = [name for name, cb in self.result_domain_vars.items() if cb.isChecked()]
        mode = self.mode_combo.currentText()

        deselected = []
        if self.deselect_enabled_cb.isChecked():
            deselected = [name for name, action in self.deselect_param_checkboxes.items() if action.isChecked()]

        # Parameter weights (nur anzeigen, wenn aktiviert)
        weights_text = "(disabled)"
        if self.weighting_enabled_cb is not None and self.weighting_enabled_cb.isChecked():
            if not self.parameter_weights:
                weights_text = "(none)"
            else:
                parts = [f"{k} = {self._format_weight(v)}" for k, v in sorted(self.parameter_weights.items())]
                weights_text = ", ".join(parts)

        msg = (
            f"Mode: {mode}\n"
            f"Groups selected: {len(selected_groups)}\n"
            f"Tasks selected: {len(selected_tasks)}\n"
            f"Result domains: {', '.join(domains) if domains else '(none)'}\n"
            f"Deselected parameters: {', '.join(deselected) if deselected else '(none)'}\n"
            f"Parameter weights: {weights_text}"
        )
        QMessageBox.information(self, "Show Results (placeholder)", msg)

    def _on_print_exec_summary(self) -> None:
        """Handle Print Executive Summary button click."""
        if state.df is None:
            QMessageBox.information(self, "No data", "Load a TSV file first.")
            return
        QMessageBox.information(
            self,
            "Executive Summary (placeholder)",
            "This will generate the executive summary later.",
        )
```

> Tokens: 21k sent, 5.4k received. Cost: $0.11 message, $1.30 session.  
> Applied edit to main_window.py  
> Commit 76d5560 feat: Parametergewichte beim Anzeigen der Ergebnisse ausgeben  
> You can use /undo to undo and discard each aider commit.  

#### /architect  
> Aider v0.86.1  
> Model: gpt-5.2 with architect edit format  
> Editor model: gpt-5.2 with editor-whole edit format  
> Git repo: .git with 25 files  
> Repo-map: using 4096 tokens, auto refresh  
> Added data_processor.py to the chat.  
> Added dialogs.py to the chat.  
> Added eye_tracking_tool\dialogs.py to the chat.  
> Added main_window.py to the chat.  
> Added state.py to the chat.  
> Restored previous conversation history.  

#### create a button next to `normalize_btn` called :"calculate metric averages". when it is pressed a function is called that takes the dataframe `normalized_df` and calculates the averages and standard deviation for each participant for each task and store it in a new dataframe  

### Änderungen (nur das Nötige) – neue Schaltfläche + Berechnungsfunktion + State

#### 1) `state.py` – neues Feld für Ergebnis-DataFrame
Füge in `AppState.reset()` **ein neues Attribut** hinzu, damit die berechneten Kennzahlen global verfügbar sind.

**Änderung in `state.py` → `AppState.reset()`**
```py
self.metric_averages_df: Optional[pd.DataFrame] = None
```

---

#### 2) `main_window.py` – neuen Button neben `normalize_btn` + Handler + Reset beim Laden
##### 2.1 Button in `_setup_ui()` direkt neben `normalize_btn`
Im Block **“Action buttons”** (wo `show_results_btn`, `normalize_btn`, `exec_summary_btn` angelegt werden) füge **direkt nach** `self.normalize_btn` Folgendes ein:

```py
self.calc_metric_averages_btn = QPushButton("Calculate metric averages")
self.calc_metric_averages_btn.setFixedWidth(200)
self.calc_metric_averages_btn.setEnabled(False)
self.calc_metric_averages_btn.clicked.connect(self._on_calculate_metric_averages)
action_layout.addWidget(self.calc_metric_averages_btn)
```

##### 2.2 Button-Enable/Disable zentral steuern
In `_set_main_action_buttons_enabled()` ergänzen:

```py
self.calc_metric_averages_btn.setEnabled(enabled)
```

##### 2.3 Beim Laden einer neuen TSV alles zurücksetzen
In `_load_tsv()` nach `state.normalized_df = None` zusätzlich:

```py
state.metric_averages_df = None
```

(Optional, aber sinnvoll: Button bleibt zwar enabled, aber die Funktion prüft unten ohnehin `normalized_df`.)

##### 2.4 Neue Slot-Methode in `MainWindow`: `_on_calculate_metric_averages`
Füge **als neue Methode** in `MainWindow` (z.B. direkt nach `_on_normalize`) ein:

```py
def _on_calculate_metric_averages(self) -> None:
    """Berechnet Mittelwert und Standardabweichung je Participant und Task aus state.normalized_df."""
    if state.normalized_df is None:
        QMessageBox.information(
            self,
            "No normalized data",
            "Bitte zuerst 'Normalize' ausführen (state.normalized_df ist leer).",
        )
        return

    df = state.normalized_df

    # Spalten prüfen
    if "Participant" not in df.columns or "TOI" not in df.columns:
        QMessageBox.critical(self, "Missing columns", "normalized_df benötigt Spalten 'Participant' und 'TOI'.")
        return

    # Task-ID wie beim Task-Scan: Suffix nach letztem '_' (oder kompletter String)
    toi = df["TOI"].astype(str).str.strip()
    task_id = toi.str.rsplit("_", n=1).str[-1].str.strip()

    # Nur numerische Metriken aggregieren
    metric_cols = df.select_dtypes(include="number").columns.tolist()
    metric_cols = [c for c in metric_cols if c not in {"Participant", "TOI"}]

    if not metric_cols:
        QMessageBox.information(self, "No numeric metrics", "Keine numerischen Spalten zum Aggregieren gefunden.")
        return

    tmp = df.copy()
    tmp["_task_id"] = task_id

    # Aggregation: mean + std je Participant x Task
    grouped = tmp.groupby(["Participant", "_task_id"], dropna=False)[metric_cols].agg(["mean", "std"])

    # Spaltennamen flach machen: "<metric>_mean", "<metric>_std"
    grouped.columns = [f"{metric}_{stat}" for (metric, stat) in grouped.columns.to_list()]

    # Index zurück in Spalten
    result = grouped.reset_index().rename(columns={"_task_id": "Task"})

    state.metric_averages_df = result

    QMessageBox.information(
        self,
        "Metric averages calculated",
        f"Fertig. Ergebnis in state.metric_averages_df gespeichert.\n"
        f"Zeilen: {len(result)} | Spalten: {len(result.columns)}",
    )
```

---

#### 3) (Optional aber empfohlen) Button nur aktivieren, wenn `normalized_df` existiert
Wenn du UX-seitig willst, dass der Button erst nach Normalize aktiv wird:

- In `_on_normalize()` nach erfolgreichem Setzen von `state.normalized_df = ...` ergänzen:
```py
self.calc_metric_averages_btn.setEnabled(True)
```

- In `_load_tsv()` nach `state.normalized_df = None` ergänzen:
```py
self.calc_metric_averages_btn.setEnabled(False)
```

(Die Funktion selbst prüft es zwar, aber so ist es klarer für Nutzer.)

---

Damit hast du:
- neuen Button **“Calculate metric averages”** neben **Normalize**
- Berechnung aus `state.normalized_df`
- Ergebnis als neuer DataFrame in `state.metric_averages_df` mit Mean/Std je Participant und Task.

> Tokens: 16k sent, 1.1k received. Cost: $0.04 message, $1.34 session.  

#### ### Änderungen (nur das Nötige) – neue Schaltfläche + Berechnungsfunktion + State  
####   
#### #### 1) `state.py` – neues Feld für Ergebnis-DataFrame  
#### Füge in `AppState.reset()` **ein neues Attribut** hinzu, damit die berechneten Kennzahlen global verfügbar sind.  
####   
#### **Änderung in `state.py` → `AppState.reset()`**  
#### ```py  
#### self.metric_averages_df: Optional[pd.DataFrame] = None  
#### ```  
####   
#### ---  
####   
#### #### 2) `main_window.py` – neuen Button neben `normalize_btn` + Handler + Reset beim Laden  
#### ##### 2.1 Button in `_setup_ui()` direkt neben `normalize_btn`  
#### Im Block **“Action buttons”** (wo `show_results_btn`, `normalize_btn`, `exec_summary_btn` angelegt werden) füge **direkt nach** `self.normalize_btn` Folgendes ein:  
####   
#### ```py  
#### self.calc_metric_averages_btn = QPushButton("Calculate metric averages")  
#### self.calc_metric_averages_btn.setFixedWidth(200)  
#### self.calc_metric_averages_btn.setEnabled(False)  
#### self.calc_metric_averages_btn.clicked.connect(self._on_calculate_metric_averages)  
#### action_layout.addWidget(self.calc_metric_averages_btn)  
#### ```  
####   
#### ##### 2.2 Button-Enable/Disable zentral steuern  
#### In `_set_main_action_buttons_enabled()` ergänzen:  
####   
#### ```py  
#### self.calc_metric_averages_btn.setEnabled(enabled)  
#### ```  
####   
#### ##### 2.3 Beim Laden einer neuen TSV alles zurücksetzen  
#### In `_load_tsv()` nach `state.normalized_df = None` zusätzlich:  
####   
#### ```py  
#### state.metric_averages_df = None  
#### ```  
####   
#### (Optional, aber sinnvoll: Button bleibt zwar enabled, aber die Funktion prüft unten ohnehin `normalized_df`.)  
####   
#### ##### 2.4 Neue Slot-Methode in `MainWindow`: `_on_calculate_metric_averages`  
#### Füge **als neue Methode** in `MainWindow` (z.B. direkt nach `_on_normalize`) ein:  
####   
#### ```py  
#### def _on_calculate_metric_averages(self) -> None:  
####     """Berechnet Mittelwert und Standardabweichung je Participant und Task aus state.normalized_df."""  
####     if state.normalized_df is None:  
####         QMessageBox.information(  
####             self,  
####             "No normalized data",  
####             "Bitte zuerst 'Normalize' ausführen (state.normalized_df ist leer).",  
####         )  
####         return  
####   
####     df = state.normalized_df  
####   
####     # Spalten prüfen  
####     if "Participant" not in df.columns or "TOI" not in df.columns:  
####         QMessageBox.critical(self, "Missing columns", "normalized_df benötigt Spalten 'Participant' und 'TOI'.")  
####         return  
####   
####     # Task-ID wie beim Task-Scan: Suffix nach letztem '_' (oder kompletter String)  
####     toi = df["TOI"].astype(str).str.strip()  
####     task_id = toi.str.rsplit("_", n=1).str[-1].str.strip()  
####   
####     # Nur numerische Metriken aggregieren  
####     metric_cols = df.select_dtypes(include="number").columns.tolist()  
####     metric_cols = [c for c in metric_cols if c not in {"Participant", "TOI"}]  
####   
####     if not metric_cols:  
####         QMessageBox.information(self, "No numeric metrics", "Keine numerischen Spalten zum Aggregieren gefunden.")  
####         return  
####   
####     tmp = df.copy()  
####     tmp["_task_id"] = task_id  
####   
####     # Aggregation: mean + std je Participant x Task  
####     grouped = tmp.groupby(["Participant", "_task_id"], dropna=False)[metric_cols].agg(["mean", "std"])  
####   
####     # Spaltennamen flach machen: "<metric>_mean", "<metric>_std"  
####     grouped.columns = [f"{metric}_{stat}" for (metric, stat) in grouped.columns.to_list()]  
####   
####     # Index zurück in Spalten  
####     result = grouped.reset_index().rename(columns={"_task_id": "Task"})  
####   
####     state.metric_averages_df = result  
####   
####     QMessageBox.information(  
####         self,  
####         "Metric averages calculated",  
####         f"Fertig. Ergebnis in state.metric_averages_df gespeichert.\n"  
####         f"Zeilen: {len(result)} | Spalten: {len(result.columns)}",  
####     )  
#### ```  
####   
#### ---  
####   
#### #### 3) (Optional aber empfohlen) Button nur aktivieren, wenn `normalized_df` existiert  
#### Wenn du UX-seitig willst, dass der Button erst nach Normalize aktiv wird:  
####   
#### - In `_on_normalize()` nach erfolgreichem Setzen von `state.normalized_df = ...` ergänzen:  
#### ```py  
#### self.calc_metric_averages_btn.setEnabled(True)  
#### ```  
####   
#### - In `_load_tsv()` nach `state.normalized_df = None` ergänzen:  
#### ```py  
#### self.calc_metric_averages_btn.setEnabled(False)  
#### ```  
####   
#### (Die Funktion selbst prüft es zwar, aber so ist es klarer für Nutzer.)  
####   
#### ---  
####   
#### Damit hast du:  
#### - neuen Button **“Calculate metric averages”** neben **Normalize**  
#### - Berechnung aus `state.normalized_df`  
#### - Ergebnis als neuer DataFrame in `state.metric_averages_df` mit Mean/Std je Participant und Task.  

state.py
```
"""
Global application state manager.
This class centralizes all state management to avoid global variable issues.
"""
from __future__ import annotations

from typing import Optional, List, Dict
import pandas as pd


class AppState:
    """Singleton class to manage application state."""
    
    _instance: Optional['AppState'] = None
    
    def __new__(cls) -> 'AppState':
        if cls._instance is None:
            cls._instance = super().__new__(cls)
            cls._instance._initialized = False
        return cls._instance
    
    def __init__(self) -> None:
        if self._initialized:
            return
        self._initialized = True
        self.reset()
    
    def reset(self) -> None:
        """Reset all state to initial values."""
        # Data
        self.df: Optional[pd.DataFrame] = None
        self.normalized_df: Optional[pd.DataFrame] = None
        self.metric_averages_df: Optional[pd.DataFrame] = None
        self.loaded_file_path: str = ""
        
        # Caches
        self.participants_cache: List[str] = []
        self.tasks_cache: List[str] = []
        
        # Grouping (participants)
        self.participant_groups: Dict[str, List[str]] = {}  # group_id -> participants
        self.group_names: Dict[str, str] = {}  # group_id -> group name
        
        # Grouping (tasks)
        self.task_groups: Dict[str, List[str]] = {}  # group_id -> task_ids
        self.task_group_names: Dict[str, str] = {}  # group_id -> group name
        
        # Task labels
        self.task_labels: Dict[str, str] = {}  # task_id -> human label
    
    def format_task(self, task_id: str) -> str:
        """Format task ID with optional label."""
        label = (self.task_labels.get(task_id, "") or "").strip()
        return f"{task_id} {label}".strip() if label else task_id
    
    def get_effective_participant_groups(self) -> Dict[str, List[str]]:
        """
        If no participant groups are defined, treat all participants as one implicit group.
        """
        if self.participant_groups:
            return self.participant_groups
        if self.participants_cache:
            return {"ALL": self.participants_cache.copy()}
        return {}
    
    def get_effective_group_names(self) -> Dict[str, str]:
        """Get group names, defaulting to 'All participants' if no groups defined."""
        if self.group_names:
            return self.group_names
        return {"ALL": "All participants"}


# Global instance
state = AppState()
```

main_window.py
```
"""
Main window for the Eye Tracking Tool using PyQt6.
"""
from __future__ import annotations

from typing import Dict, Optional
import pandas as pd

from PyQt6.QtWidgets import (
    QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, QLabel, QPushButton,
    QListWidget, QLineEdit, QComboBox, QCheckBox, QGroupBox, QGridLayout,
    QFrame, QMessageBox, QFileDialog, QMenu, QMenuBar, QSplitter, QSlider
)
from PyQt6.QtCore import Qt, QSize
from PyQt6.QtGui import QAction

from state import state
from models import EXPECTED_COLUMNS, PARAMETER_OPTIONS
from data_processor import (
    validate_tsv_format,
    extract_participants,
    extract_tasks_from_toi,
    normalize_by_participant_baseline,
)
from dialogs import GroupParticipantsDialog, GroupTasksDialog


class MainWindow(QMainWindow):
    """Main application window."""

    def __init__(self) -> None:
        super().__init__()
        self.setWindowTitle("Eye Tracking Analysis Tool")
        self.setMinimumSize(1200, 720)

        # Result domain checkboxes
        self.result_domain_vars: Dict[str, QCheckBox] = {}

        # Result group/task checkboxes
        self.result_group_checkboxes: Dict[str, QCheckBox] = {}
        self.result_task_checkboxes: Dict[str, QCheckBox] = {}

        # Deselect parameters
        self.deselect_param_checkboxes: Dict[str, QCheckBox] = {}

        # Weighting parameters
        self.weighting_enabled_cb: Optional[QCheckBox] = None
        self.weight_rows: list[tuple[QComboBox, QSlider, QLabel]] = []
        self.parameter_weights: Dict[str, float] = {}

        self._setup_ui()

    # --- Weighting slider mapping (QSlider is int-based) ---
    def _weight_slider_to_float(self, slider_val: int) -> float:
        # 0..12 -> 0.00..3.00 in 0.25 steps
        return float(slider_val) / 4.0

    def _weight_float_to_slider(self, weight: float) -> int:
        # clamp + round to nearest 0.25 step
        w = max(0.0, min(3.0, float(weight)))
        return int(round(w * 4.0))

    def _format_weight(self, weight: float) -> str:
        return f"{weight:.2f}".rstrip("0").rstrip(".")

    def _setup_ui(self) -> None:
        central = QWidget()
        self.setCentralWidget(central)
        main_layout = QVBoxLayout(central)
        main_layout.setContentsMargins(10, 10, 10, 10)

        # Top bar
        topbar = QHBoxLayout()

        self.load_btn = QPushButton("Load TSV")
        self.load_btn.setFixedWidth(120)
        self.load_btn.clicked.connect(self._load_tsv)
        topbar.addWidget(self.load_btn)

        self.group_participants_btn = QPushButton("Group Participants")
        self.group_participants_btn.setFixedWidth(150)
        self.group_participants_btn.setEnabled(False)
        self.group_participants_btn.clicked.connect(self._open_group_participants)
        topbar.addWidget(self.group_participants_btn)

        # Button-Text wie gewünscht: "Name Tasks"
        self.group_tasks_btn = QPushButton("Name Tasks")
        self.group_tasks_btn.setFixedWidth(120)
        self.group_tasks_btn.setEnabled(False)
        self.group_tasks_btn.clicked.connect(self._open_group_tasks)
        topbar.addWidget(self.group_tasks_btn)

        self.file_path_edit = QLineEdit()
        self.file_path_edit.setReadOnly(True)
        self.file_path_edit.setPlaceholderText("No file loaded")
        topbar.addWidget(self.file_path_edit)

        main_layout.addLayout(topbar)

        # Listboxes section
        listbox_layout = QHBoxLayout()

        # Participants listbox
        left_widget = QWidget()
        left_layout = QVBoxLayout(left_widget)
        left_layout.setContentsMargins(0, 0, 0, 0)
        left_layout.addWidget(QLabel('Detected participants (from "Participant"):'))
        self.participants_list = QListWidget()
        self.participants_list.setMaximumHeight(120)
        left_layout.addWidget(self.participants_list)
        listbox_layout.addWidget(left_widget)

        # Tasks listbox
        right_widget = QWidget()
        right_layout = QVBoxLayout(right_widget)
        right_layout.setContentsMargins(0, 0, 0, 0)
        right_layout.addWidget(QLabel('Detected tasks (from "TOI" suffix):'))
        self.tasks_list = QListWidget()
        self.tasks_list.setMaximumHeight(120)
        right_layout.addWidget(self.tasks_list)
        listbox_layout.addWidget(right_widget)

        main_layout.addLayout(listbox_layout)

        # Separator
        separator = QFrame()
        separator.setFrameShape(QFrame.Shape.HLine)
        separator.setFrameShadow(QFrame.Shadow.Sunken)
        main_layout.addWidget(separator)

        # Results section
        results_label = QLabel("Results")
        results_label.setStyleSheet("font-weight: bold; font-size: 14px;")
        main_layout.addWidget(results_label)

        # Mode selection
        mode_layout = QHBoxLayout()
        mode_layout.addWidget(QLabel("Show results for:"))

        self.mode_combo = QComboBox()
        self.mode_combo.addItems([
            "Only group mean",
            "Each participant for selected groups",
            "Group mean and individual participants",
        ])
        self.mode_combo.setFixedWidth(350)
        mode_layout.addWidget(self.mode_combo)
        mode_layout.addStretch()
        main_layout.addLayout(mode_layout)

        # Groups and Tasks frames
        sel_layout = QHBoxLayout()

        self.groups_group = QGroupBox("Groups")
        self.groups_layout = QVBoxLayout(self.groups_group)
        sel_layout.addWidget(self.groups_group)

        self.tasks_group = QGroupBox("Tasks")
        self.tasks_layout = QGridLayout(self.tasks_group)
        sel_layout.addWidget(self.tasks_group)

        main_layout.addLayout(sel_layout)

        # Bottom row: Result domain and Deselect parameters
        bottom_layout = QHBoxLayout()

        # Result domain
        domain_group = QGroupBox("Result domain")
        domain_layout = QHBoxLayout(domain_group)

        for name in ["Rank", "Radar Chart", "Task Completion Time"]:
            cb = QCheckBox(name)
            cb.setChecked(True)
            self.result_domain_vars[name] = cb
            domain_layout.addWidget(cb)

        domain_layout.addStretch()
        bottom_layout.addWidget(domain_group)

        # Deselect parameters
        deselect_group = QGroupBox("Deselect Parameters")
        deselect_layout = QHBoxLayout(deselect_group)

        self.deselect_enabled_cb = QCheckBox("Enable Deselect")
        self.deselect_enabled_cb.stateChanged.connect(self._toggle_deselect_menu)
        deselect_layout.addWidget(self.deselect_enabled_cb)

        self.deselect_btn = QPushButton("None")
        self.deselect_btn.setEnabled(False)
        self.deselect_btn.clicked.connect(self._show_deselect_menu)
        deselect_layout.addWidget(self.deselect_btn)

        deselect_layout.addStretch()
        bottom_layout.addWidget(deselect_group)

        # Weighting parameters
        weighting_group = QGroupBox("Weighting Parameters")
        weighting_outer = QVBoxLayout(weighting_group)

        # Toggle row: checkbox + label rechts
        weighting_toggle_row = QHBoxLayout()
        self.weighting_enabled_cb = QCheckBox()
        self.weighting_enabled_cb.setChecked(False)
        self.weighting_enabled_cb.setEnabled(False)
        self.weighting_enabled_cb.stateChanged.connect(self._on_weighting_toggled)
        weighting_toggle_row.addWidget(self.weighting_enabled_cb)
        weighting_toggle_row.addWidget(QLabel("Enable custom parameter weights"))
        weighting_toggle_row.addStretch()
        weighting_outer.addLayout(weighting_toggle_row)

        # Container für dynamische Zeilen
        self.weighting_rows_container = QWidget()
        self.weighting_rows_layout = QVBoxLayout(self.weighting_rows_container)
        self.weighting_rows_layout.setContentsMargins(0, 0, 0, 0)
        self.weighting_rows_layout.setSpacing(6)
        weighting_outer.addWidget(self.weighting_rows_container)

        bottom_layout.addWidget(weighting_group)

        main_layout.addLayout(bottom_layout)

        # Action buttons
        action_layout = QHBoxLayout()

        self.show_results_btn = QPushButton("Show Results")
        self.show_results_btn.setFixedWidth(150)
        self.show_results_btn.setEnabled(False)
        self.show_results_btn.clicked.connect(self._on_show_results)
        action_layout.addWidget(self.show_results_btn)

        self.normalize_btn = QPushButton("Normalize")
        self.normalize_btn.setFixedWidth(150)
        self.normalize_btn.setEnabled(False)
        self.normalize_btn.clicked.connect(self._on_normalize)
        action_layout.addWidget(self.normalize_btn)

        self.calc_metric_averages_btn = QPushButton("Calculate metric averages")
        self.calc_metric_averages_btn.setFixedWidth(200)
        self.calc_metric_averages_btn.setEnabled(False)
        self.calc_metric_averages_btn.clicked.connect(self._on_calculate_metric_averages)
        action_layout.addWidget(self.calc_metric_averages_btn)

        self.exec_summary_btn = QPushButton("Print Executive Summary")
        self.exec_summary_btn.setFixedWidth(180)
        self.exec_summary_btn.setEnabled(False)
        self.exec_summary_btn.clicked.connect(self._on_print_exec_summary)
        action_layout.addWidget(self.exec_summary_btn)

        action_layout.addStretch()
        main_layout.addLayout(action_layout)

        main_layout.addStretch()

        # Initialize deselect menu
        self._build_deselect_menu()

        # Initialize weighting UI (disabled by default)
        self._reset_weighting_ui()

        # Initial population
        self._refresh_group_task_toggles()

    def _load_tsv(self) -> None:
        """Load and validate a TSV file."""
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            "Select TSV file",
            "",
            "TSV files (*.tsv);;All files (*.*)"
        )

        if not file_path:
            return

        # Validate format
        result = validate_tsv_format(file_path, EXPECTED_COLUMNS)
        if not result.ok:
            QMessageBox.critical(self, "Format error", result.message or "Unknown format error.")
            return

        # Load data
        try:
            state.df = pd.read_csv(file_path, sep="\t")
        except Exception as e:
            QMessageBox.critical(self, "Load error", str(e))
            return

        # Reset normalized data (must be recomputed for new file)
        state.normalized_df = None
        state.metric_averages_df = None
        if hasattr(self, "calc_metric_averages_btn"):
            self.calc_metric_averages_btn.setEnabled(False)

        # Reset weighting UI/weights (parameters list may change later)
        if self.weighting_enabled_cb is not None:
            self.weighting_enabled_cb.setChecked(False)
        self._reset_weighting_ui()

        # Update UI with file path
        state.loaded_file_path = file_path
        self.file_path_edit.setText(file_path)

        # Reset caches
        state.participants_cache = []
        state.tasks_cache = []

        # Clear listboxes
        self.participants_list.clear()
        self.tasks_list.clear()

        # Disable action buttons during loading
        self.group_participants_btn.setEnabled(False)
        self.group_tasks_btn.setEnabled(False)
        self._set_main_action_buttons_enabled(False)

        # Extract participants
        try:
            state.participants_cache = extract_participants(state.df, column="Participant")
        except Exception as e:
            QMessageBox.critical(self, "Participant scan failed", str(e))
            state.df = None
            return

        # Extract tasks
        try:
            state.tasks_cache = extract_tasks_from_toi(state.df, column="TOI")
        except Exception as e:
            QMessageBox.critical(self, "Task scan failed", str(e))
            state.df = None
            return

        # Keep only labels for tasks that exist
        state.task_labels = {k: v for k, v in state.task_labels.items() if k in set(state.tasks_cache)}

        # Update listboxes
        for p in state.participants_cache:
            self.participants_list.addItem(p)

        self._refresh_tasks_listbox()

        # Enable group buttons
        self.group_participants_btn.setEnabled(bool(state.participants_cache))
        self.group_tasks_btn.setEnabled(bool(state.tasks_cache))

        if self.weighting_enabled_cb is not None:
            self.weighting_enabled_cb.setEnabled(True)

        self._set_main_action_buttons_enabled(True)
        self._refresh_group_task_toggles()

        QMessageBox.information(
            self,
            "Success",
            f"Loaded {len(state.df)} rows.\n"
            f"Found {len(state.participants_cache)} participants and {len(state.tasks_cache)} tasks."
        )

    def _refresh_tasks_listbox(self) -> None:
        """Refresh the tasks listbox with formatted task names."""
        self.tasks_list.clear()
        for t in state.tasks_cache:
            self.tasks_list.addItem(state.format_task(t))

    def _set_main_action_buttons_enabled(self, enabled: bool) -> None:
        """Enable or disable main action buttons."""
        self.show_results_btn.setEnabled(enabled)
        self.normalize_btn.setEnabled(enabled)
        self.calc_metric_averages_btn.setEnabled(enabled)
        self.exec_summary_btn.setEnabled(enabled)

    def _refresh_group_task_toggles(self) -> None:
        """Refresh the checkbox lists in the Results section."""
        # Clear existing group checkboxes
        while self.groups_layout.count():
            item = self.groups_layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()

        # Clear existing task checkboxes
        while self.tasks_layout.count():
            item = self.tasks_layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()

        self.result_group_checkboxes.clear()
        self.result_task_checkboxes.clear()

        # Groups toggles
        effective_groups = state.get_effective_participant_groups()
        effective_names = state.get_effective_group_names()

        if not effective_groups:
            label = QLabel("(Load a TSV file first)")
            label.setStyleSheet("color: #666;")
            self.groups_layout.addWidget(label)
        else:
            for gid in effective_groups.keys():
                name = effective_names.get(gid, gid)
                cb = QCheckBox(name)
                cb.setChecked(True)
                self.result_group_checkboxes[gid] = cb
                self.groups_layout.addWidget(cb)

        self.groups_layout.addStretch()

        # Tasks toggles
        if not state.tasks_cache:
            label = QLabel("(Load a TSV file first)")
            label.setStyleSheet("color: #666;")
            self.tasks_layout.addWidget(label, 0, 0)
            return

        cols = 8
        row = 0
        col = 0
        for tid in state.tasks_cache:
            cb = QCheckBox(state.format_task(tid))
            cb.setChecked(True)
            self.result_task_checkboxes[tid] = cb
            self.tasks_layout.addWidget(cb, row, col)
            col += 1
            if col >= cols:
                col = 0
                row += 1

    def _build_deselect_menu(self) -> None:
        """Build the deselect parameters menu."""
        self.deselect_menu = QMenu(self)
        self.deselect_param_checkboxes.clear()

        for name in PARAMETER_OPTIONS:
            action = QAction(name, self)
            action.setCheckable(True)
            action.triggered.connect(self._update_deselect_label)
            self.deselect_menu.addAction(action)
            self.deselect_param_checkboxes[name] = action

    def _reset_weighting_ui(self) -> None:
        """Clear all weighting rows and internal weights; keep toggle state."""
        self.parameter_weights.clear()
        self.weight_rows.clear()

        # Clear UI rows
        if hasattr(self, "weighting_rows_layout"):
            while self.weighting_rows_layout.count():
                item = self.weighting_rows_layout.takeAt(0)
                if item.widget():
                    item.widget().deleteLater()

        # If enabled and we have parameters, create first row
        if self.weighting_enabled_cb is not None and self.weighting_enabled_cb.isChecked():
            self._ensure_next_weight_row()

    def _on_weighting_toggled(self, state_val: int) -> None:
        enabled = state_val == Qt.CheckState.Checked.value
        if not enabled:
            self._reset_weighting_ui()
            return
        self._reset_weighting_ui()

    def _selected_weight_params(self) -> set[str]:
        selected: set[str] = set()
        for combo, _slider, _lbl in self.weight_rows:
            val = combo.currentData()
            if isinstance(val, str) and val:
                selected.add(val)
        return selected

    def _available_weight_params(self) -> list[str]:
        # PARAMETER_OPTIONS sind die “Parameter” im Tool
        selected = self._selected_weight_params()
        return [p for p in PARAMETER_OPTIONS if p not in selected]

    def _create_weight_row(self) -> None:
        available = self._available_weight_params()
        if not available:
            return

        row = QWidget()
        row_layout = QHBoxLayout(row)
        row_layout.setContentsMargins(0, 0, 0, 0)

        combo = QComboBox()
        combo.setFixedWidth(260)
        combo.addItem("Select parameter...", None)
        for p in available:
            combo.addItem(p, p)

        slider = QSlider(Qt.Orientation.Horizontal)
        # 0..3 in 0.25 steps => 0..12
        slider.setMinimum(0)
        slider.setMaximum(12)
        slider.setValue(self._weight_float_to_slider(1.0))
        slider.setSingleStep(1)
        slider.setPageStep(1)
        slider.setFixedWidth(220)
        slider.setEnabled(False)  # erst aktivieren, wenn Parameter gewählt

        value_lbl = QLabel(self._format_weight(1.0))
        value_lbl.setFixedWidth(44)
        value_lbl.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        value_lbl.setEnabled(False)

        # Signals
        combo.currentIndexChanged.connect(
            lambda _i, c=combo, s=slider, l=value_lbl: self._on_weight_row_changed(c, s, l)
        )
        slider.valueChanged.connect(
            lambda _v, c=combo, s=slider, l=value_lbl: self._on_weight_row_changed(c, s, l)
        )

        row_layout.addWidget(combo)
        row_layout.addWidget(slider)
        row_layout.addWidget(value_lbl)
        row_layout.addStretch()

        self.weighting_rows_layout.addWidget(row)
        self.weight_rows.append((combo, slider, value_lbl))

    def _on_weight_row_changed(self, combo: QComboBox, slider: QSlider, value_lbl: QLabel) -> None:
        # Wenn Toggle aus: ignorieren
        if self.weighting_enabled_cb is None or not self.weighting_enabled_cb.isChecked():
            return

        param = combo.currentData()
        if not isinstance(param, str) or not param:
            slider.setEnabled(False)
            value_lbl.setEnabled(False)
            return

        slider.setEnabled(True)
        value_lbl.setEnabled(True)

        weight = self._weight_slider_to_float(slider.value())
        value_lbl.setText(self._format_weight(weight))

        # Gewicht speichern (0.00..3.00 in 0.25er Schritten)
        self.parameter_weights[param] = float(weight)

        # Alle Combos neu aufbauen, damit keine Duplikate möglich sind
        self._rebuild_weight_combos(keep_current=True)

        # Wenn diese Zeile “aktiv” ist, nächste Zeile sicherstellen
        self._ensure_next_weight_row()

    def _rebuild_weight_combos(self, keep_current: bool = True) -> None:
        selected = self._selected_weight_params()

        for combo, slider, value_lbl in self.weight_rows:
            current = combo.currentData() if keep_current else None

            # Block signals während rebuild
            combo.blockSignals(True)
            combo.clear()
            combo.addItem("Select parameter...", None)

            # In dieser Combo darf current weiterhin drin sein
            allowed: list[str] = []
            for p in PARAMETER_OPTIONS:
                if p == current:
                    allowed.append(p)
                elif p not in selected:
                    allowed.append(p)

            for p in allowed:
                combo.addItem(p, p)

            # Restore selection
            if isinstance(current, str) and current:
                idx = combo.findData(current)
                combo.setCurrentIndex(idx if idx >= 0 else 0)
                slider.setEnabled(True)
                value_lbl.setEnabled(True)

                # Label/weight sync
                weight = self._weight_slider_to_float(slider.value())
                value_lbl.setText(self._format_weight(weight))
                self.parameter_weights[current] = float(weight)
            else:
                combo.setCurrentIndex(0)
                slider.setEnabled(False)
                value_lbl.setEnabled(False)

            combo.blockSignals(False)

    def _ensure_next_weight_row(self) -> None:
        if self.weighting_enabled_cb is None or not self.weighting_enabled_cb.isChecked():
            return

        available = self._available_weight_params()
        if not available:
            return

        if not self.weight_rows:
            self._create_weight_row()
            return

        last_combo, _last_slider, _last_lbl = self.weight_rows[-1]
        last_param = last_combo.currentData()
        if isinstance(last_param, str) and last_param:
            self._create_weight_row()

    def _toggle_deselect_menu(self, state_val: int) -> None:
        """Toggle the deselect parameters menu button."""
        self.deselect_btn.setEnabled(state_val == Qt.CheckState.Checked.value)

    def _show_deselect_menu(self) -> None:
        """Show the deselect parameters menu."""
        self.deselect_menu.exec(self.deselect_btn.mapToGlobal(self.deselect_btn.rect().bottomLeft()))

    def _update_deselect_label(self) -> None:
        """Update the deselect button label."""
        count = sum(1 for action in self.deselect_param_checkboxes.values() if action.isChecked())
        self.deselect_btn.setText("None" if count == 0 else f"{count} deselected")

    def _open_group_participants(self) -> None:
        """Open the group participants dialog."""
        if not state.participants_cache:
            QMessageBox.information(self, "No data", "Load a TSV file first.")
            return

        dialog = GroupParticipantsDialog(self)
        if dialog.exec() == GroupParticipantsDialog.DialogCode.Accepted:
            self._refresh_group_task_toggles()

    def _open_group_tasks(self) -> None:
        """Open the group tasks dialog."""
        if not state.tasks_cache:
            QMessageBox.information(self, "No data", "Load a TSV file first.")
            return

        dialog = GroupTasksDialog(self)
        if dialog.exec() == GroupTasksDialog.DialogCode.Accepted:
            self._refresh_tasks_listbox()
            self._refresh_group_task_toggles()

    def _on_normalize(self) -> None:
        """Normalize numeric data per participant by baseline task 0a (fallback 0b)."""
        if state.df is None:
            QMessageBox.information(self, "No data", "Load a TSV file first.")
            return

        try:
            state.normalized_df = normalize_by_participant_baseline(
                state.df,
                participant_col="Participant",
                task_col="TOI",
                baseline_primary="0a",
                baseline_fallback="0b",
            )
        except Exception as e:
            QMessageBox.critical(self, "Normalize failed", str(e))
            return

        if hasattr(self, "calc_metric_averages_btn"):
            self.calc_metric_averages_btn.setEnabled(True)

        QMessageBox.information(
            self,
            "Normalization complete",
            "Normalized data stored in state.normalized_df (baseline: 0a, fallback: 0b).",
        )

    def _on_calculate_metric_averages(self) -> None:
        """Berechnet Mittelwert und Standardabweichung je Participant und Task aus state.normalized_df."""
        if state.normalized_df is None:
            QMessageBox.information(
                self,
                "No normalized data",
                "Bitte zuerst 'Normalize' ausführen (state.normalized_df ist leer).",
            )
            return

        df = state.normalized_df

        # Spalten prüfen
        if "Participant" not in df.columns or "TOI" not in df.columns:
            QMessageBox.critical(self, "Missing columns", "normalized_df benötigt Spalten 'Participant' und 'TOI'.")
            return

        # Task-ID wie beim Task-Scan: Suffix nach letztem '_' (oder kompletter String)
        toi = df["TOI"].astype(str).str.strip()
        task_id = toi.str.rsplit("_", n=1).str[-1].str.strip()

        # Nur numerische Metriken aggregieren
        metric_cols = df.select_dtypes(include="number").columns.tolist()
        metric_cols = [c for c in metric_cols if c not in {"Participant", "TOI"}]

        if not metric_cols:
            QMessageBox.information(self, "No numeric metrics", "Keine numerischen Spalten zum Aggregieren gefunden.")
            return

        tmp = df.copy()
        tmp["_task_id"] = task_id

        # Aggregation: mean + std je Participant x Task
        grouped = tmp.groupby(["Participant", "_task_id"], dropna=False)[metric_cols].agg(["mean", "std"])

        # Spaltennamen flach machen: "<metric>_mean", "<metric>_std"
        grouped.columns = [f"{metric}_{stat}" for (metric, stat) in grouped.columns.to_list()]

        # Index zurück in Spalten
        result = grouped.reset_index().rename(columns={"_task_id": "Task"})

        state.metric_averages_df = result

        QMessageBox.information(
            self,
            "Metric averages calculated",
            f"Fertig. Ergebnis in state.metric_averages_df gespeichert.\n"
            f"Zeilen: {len(result)} | Spalten: {len(result.columns)}",
        )

    def _on_show_results(self) -> None:
        """Handle Show Results button click."""
        if state.df is None:
            QMessageBox.information(self, "No data", "Load a TSV file first.")
            return

        selected_groups = [gid for gid, cb in self.result_group_checkboxes.items() if cb.isChecked()]
        selected_tasks = [tid for tid, cb in self.result_task_checkboxes.items() if cb.isChecked()]
        domains = [name for name, cb in self.result_domain_vars.items() if cb.isChecked()]
        mode = self.mode_combo.currentText()

        deselected = []
        if self.deselect_enabled_cb.isChecked():
            deselected = [name for name, action in self.deselect_param_checkboxes.items() if action.isChecked()]

        # Parameter weights (nur anzeigen, wenn aktiviert)
        weights_text = "(disabled)"
        if self.weighting_enabled_cb is not None and self.weighting_enabled_cb.isChecked():
            if not self.parameter_weights:
                weights_text = "(none)"
            else:
                parts = [f"{k} = {self._format_weight(v)}" for k, v in sorted(self.parameter_weights.items())]
                weights_text = ", ".join(parts)

        msg = (
            f"Mode: {mode}\n"
            f"Groups selected: {len(selected_groups)}\n"
            f"Tasks selected: {len(selected_tasks)}\n"
            f"Result domains: {', '.join(domains) if domains else '(none)'}\n"
            f"Deselected parameters: {', '.join(deselected) if deselected else '(none)'}\n"
            f"Parameter weights: {weights_text}"
        )
        QMessageBox.information(self, "Show Results (placeholder)", msg)

    def _on_print_exec_summary(self) -> None:
        """Handle Print Executive Summary button click."""
        if state.df is None:
            QMessageBox.information(self, "No data", "Load a TSV file first.")
            return
        QMessageBox.information(
            self,
            "Executive Summary (placeholder)",
            "This will generate the executive summary later.",
        )
```

> Tokens: 15k sent, 6.4k received. Cost: $0.12 message, $1.46 session.  
> Applied edit to main_window.py  
> Applied edit to state.py  
> Commit 6e2e53c feat: Button zum Berechnen von Metrik-Mittelwerten hinzufügen  
> You can use /undo to undo and discard each aider commit.  

#### /code  
> Aider v0.86.1  
> Model: gpt-5.2 with whole edit format  
> Git repo: .git with 25 files  
> Repo-map: using 4096 tokens, auto refresh  
> Added data_processor.py to the chat.  
> Added dialogs.py to the chat.  
> Added eye_tracking_tool\dialogs.py to the chat.  
> Added main_window.py to the chat.  
> Added state.py to the chat.  
> Restored previous conversation history.  

#### when `calc_metric_averages_btn` is pressed: calculate the task completion time(tct) and the standard deviation of the tct for each task for each participant and add it to the dataframe state.metric_averages_df  

Ja, dafür sind Codeänderungen nötig.

## Benötigte Änderungen
- In `MainWindow._on_calculate_metric_averages()` wird aktuell **für alle numerischen Spalten** Mean/Std je `Participant` und Task berechnet.
- Du willst stattdessen (bzw. zusätzlich) explizit **Task Completion Time (TCT)** und **Standardabweichung der TCT** je `Participant` und Task berechnen und in `state.metric_averages_df` ablegen.
- Dafür muss klar sein, **welche Spalte** im DataFrame die TCT repräsentiert. In den von dir geteilten Dateien gibt es keine eindeutige TCT-Spalte; typischerweise wäre das z.B. `Duration` (oder `TaskCompletionTime`, o.ä.).

Ich implementiere daher eine robuste Logik:
- Wenn eine Spalte `Duration` existiert, wird sie als TCT verwendet.
- Sonst wird nach einer plausiblen TCT-Spalte gesucht (case-insensitive Kandidaten wie `tct`, `task completion time`, `task_completion_time`, `completion_time`).
- Wenn keine gefunden wird: Fehlermeldung.

Ergebnis-DF:
- Spalten: `Participant`, `Task`, `tct_mean`, `tct_std`
- (Optional könntest du später wieder weitere Metriken ergänzen; hier fokussiere ich exakt auf TCT wie gewünscht.)

main_window.py
```
"""
Main window for the Eye Tracking Tool using PyQt6.
"""
from __future__ import annotations

from typing import Dict, Optional
import pandas as pd

from PyQt6.QtWidgets import (
    QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, QLabel, QPushButton,
    QListWidget, QLineEdit, QComboBox, QCheckBox, QGroupBox, QGridLayout,
    QFrame, QMessageBox, QFileDialog, QMenu, QMenuBar, QSplitter, QSlider
)
from PyQt6.QtCore import Qt, QSize
from PyQt6.QtGui import QAction

from state import state
from models import EXPECTED_COLUMNS, PARAMETER_OPTIONS
from data_processor import (
    validate_tsv_format,
    extract_participants,
    extract_tasks_from_toi,
    normalize_by_participant_baseline,
)
from dialogs import GroupParticipantsDialog, GroupTasksDialog


class MainWindow(QMainWindow):
    """Main application window."""

    def __init__(self) -> None:
        super().__init__()
        self.setWindowTitle("Eye Tracking Analysis Tool")
        self.setMinimumSize(1200, 720)

        # Result domain checkboxes
        self.result_domain_vars: Dict[str, QCheckBox] = {}

        # Result group/task checkboxes
        self.result_group_checkboxes: Dict[str, QCheckBox] = {}
        self.result_task_checkboxes: Dict[str, QCheckBox] = {}

        # Deselect parameters
        self.deselect_param_checkboxes: Dict[str, QCheckBox] = {}

        # Weighting parameters
        self.weighting_enabled_cb: Optional[QCheckBox] = None
        self.weight_rows: list[tuple[QComboBox, QSlider, QLabel]] = []
        self.parameter_weights: Dict[str, float] = {}

        self._setup_ui()

    # --- Weighting slider mapping (QSlider is int-based) ---
    def _weight_slider_to_float(self, slider_val: int) -> float:
        # 0..12 -> 0.00..3.00 in 0.25 steps
        return float(slider_val) / 4.0

    def _weight_float_to_slider(self, weight: float) -> int:
        # clamp + round to nearest 0.25 step
        w = max(0.0, min(3.0, float(weight)))
        return int(round(w * 4.0))

    def _format_weight(self, weight: float) -> str:
        return f"{weight:.2f}".rstrip("0").rstrip(".")

    def _setup_ui(self) -> None:
        central = QWidget()
        self.setCentralWidget(central)
        main_layout = QVBoxLayout(central)
        main_layout.setContentsMargins(10, 10, 10, 10)

        # Top bar
        topbar = QHBoxLayout()

        self.load_btn = QPushButton("Load TSV")
        self.load_btn.setFixedWidth(120)
        self.load_btn.clicked.connect(self._load_tsv)
        topbar.addWidget(self.load_btn)

        self.group_participants_btn = QPushButton("Group Participants")
        self.group_participants_btn.setFixedWidth(150)
        self.group_participants_btn.setEnabled(False)
        self.group_participants_btn.clicked.connect(self._open_group_participants)
        topbar.addWidget(self.group_participants_btn)

        # Button-Text wie gewünscht: "Name Tasks"
        self.group_tasks_btn = QPushButton("Name Tasks")
        self.group_tasks_btn.setFixedWidth(120)
        self.group_tasks_btn.setEnabled(False)
        self.group_tasks_btn.clicked.connect(self._open_group_tasks)
        topbar.addWidget(self.group_tasks_btn)

        self.file_path_edit = QLineEdit()
        self.file_path_edit.setReadOnly(True)
        self.file_path_edit.setPlaceholderText("No file loaded")
        topbar.addWidget(self.file_path_edit)

        main_layout.addLayout(topbar)

        # Listboxes section
        listbox_layout = QHBoxLayout()

        # Participants listbox
        left_widget = QWidget()
        left_layout = QVBoxLayout(left_widget)
        left_layout.setContentsMargins(0, 0, 0, 0)
        left_layout.addWidget(QLabel('Detected participants (from "Participant"):'))
        self.participants_list = QListWidget()
        self.participants_list.setMaximumHeight(120)
        left_layout.addWidget(self.participants_list)
        listbox_layout.addWidget(left_widget)

        # Tasks listbox
        right_widget = QWidget()
        right_layout = QVBoxLayout(right_widget)
        right_layout.setContentsMargins(0, 0, 0, 0)
        right_layout.addWidget(QLabel('Detected tasks (from "TOI" suffix):'))
        self.tasks_list = QListWidget()
        self.tasks_list.setMaximumHeight(120)
        right_layout.addWidget(self.tasks_list)
        listbox_layout.addWidget(right_widget)

        main_layout.addLayout(listbox_layout)

        # Separator
        separator = QFrame()
        separator.setFrameShape(QFrame.Shape.HLine)
        separator.setFrameShadow(QFrame.Shadow.Sunken)
        main_layout.addWidget(separator)

        # Results section
        results_label = QLabel("Results")
        results_label.setStyleSheet("font-weight: bold; font-size: 14px;")
        main_layout.addWidget(results_label)

        # Mode selection
        mode_layout = QHBoxLayout()
        mode_layout.addWidget(QLabel("Show results for:"))

        self.mode_combo = QComboBox()
        self.mode_combo.addItems([
            "Only group mean",
            "Each participant for selected groups",
            "Group mean and individual participants",
        ])
        self.mode_combo.setFixedWidth(350)
        mode_layout.addWidget(self.mode_combo)
        mode_layout.addStretch()
        main_layout.addLayout(mode_layout)

        # Groups and Tasks frames
        sel_layout = QHBoxLayout()

        self.groups_group = QGroupBox("Groups")
        self.groups_layout = QVBoxLayout(self.groups_group)
        sel_layout.addWidget(self.groups_group)

        self.tasks_group = QGroupBox("Tasks")
        self.tasks_layout = QGridLayout(self.tasks_group)
        sel_layout.addWidget(self.tasks_group)

        main_layout.addLayout(sel_layout)

        # Bottom row: Result domain and Deselect parameters
        bottom_layout = QHBoxLayout()

        # Result domain
        domain_group = QGroupBox("Result domain")
        domain_layout = QHBoxLayout(domain_group)

        for name in ["Rank", "Radar Chart", "Task Completion Time"]:
            cb = QCheckBox(name)
            cb.setChecked(True)
            self.result_domain_vars[name] = cb
            domain_layout.addWidget(cb)

        domain_layout.addStretch()
        bottom_layout.addWidget(domain_group)

        # Deselect parameters
        deselect_group = QGroupBox("Deselect Parameters")
        deselect_layout = QHBoxLayout(deselect_group)

        self.deselect_enabled_cb = QCheckBox("Enable Deselect")
        self.deselect_enabled_cb.stateChanged.connect(self._toggle_deselect_menu)
        deselect_layout.addWidget(self.deselect_enabled_cb)

        self.deselect_btn = QPushButton("None")
        self.deselect_btn.setEnabled(False)
        self.deselect_btn.clicked.connect(self._show_deselect_menu)
        deselect_layout.addWidget(self.deselect_btn)

        deselect_layout.addStretch()
        bottom_layout.addWidget(deselect_group)

        # Weighting parameters
        weighting_group = QGroupBox("Weighting Parameters")
        weighting_outer = QVBoxLayout(weighting_group)

        # Toggle row: checkbox + label rechts
        weighting_toggle_row = QHBoxLayout()
        self.weighting_enabled_cb = QCheckBox()
        self.weighting_enabled_cb.setChecked(False)
        self.weighting_enabled_cb.setEnabled(False)
        self.weighting_enabled_cb.stateChanged.connect(self._on_weighting_toggled)
        weighting_toggle_row.addWidget(self.weighting_enabled_cb)
        weighting_toggle_row.addWidget(QLabel("Enable custom parameter weights"))
        weighting_toggle_row.addStretch()
        weighting_outer.addLayout(weighting_toggle_row)

        # Container für dynamische Zeilen
        self.weighting_rows_container = QWidget()
        self.weighting_rows_layout = QVBoxLayout(self.weighting_rows_container)
        self.weighting_rows_layout.setContentsMargins(0, 0, 0, 0)
        self.weighting_rows_layout.setSpacing(6)
        weighting_outer.addWidget(self.weighting_rows_container)

        bottom_layout.addWidget(weighting_group)

        main_layout.addLayout(bottom_layout)

        # Action buttons
        action_layout = QHBoxLayout()

        self.show_results_btn = QPushButton("Show Results")
        self.show_results_btn.setFixedWidth(150)
        self.show_results_btn.setEnabled(False)
        self.show_results_btn.clicked.connect(self._on_show_results)
        action_layout.addWidget(self.show_results_btn)

        self.normalize_btn = QPushButton("Normalize")
        self.normalize_btn.setFixedWidth(150)
        self.normalize_btn.setEnabled(False)
        self.normalize_btn.clicked.connect(self._on_normalize)
        action_layout.addWidget(self.normalize_btn)

        self.calc_metric_averages_btn = QPushButton("Calculate metric averages")
        self.calc_metric_averages_btn.setFixedWidth(200)
        self.calc_metric_averages_btn.setEnabled(False)
        self.calc_metric_averages_btn.clicked.connect(self._on_calculate_metric_averages)
        action_layout.addWidget(self.calc_metric_averages_btn)

        self.exec_summary_btn = QPushButton("Print Executive Summary")
        self.exec_summary_btn.setFixedWidth(180)
        self.exec_summary_btn.setEnabled(False)
        self.exec_summary_btn.clicked.connect(self._on_print_exec_summary)
        action_layout.addWidget(self.exec_summary_btn)

        action_layout.addStretch()
        main_layout.addLayout(action_layout)

        main_layout.addStretch()

        # Initialize deselect menu
        self._build_deselect_menu()

        # Initialize weighting UI (disabled by default)
        self._reset_weighting_ui()

        # Initial population
        self._refresh_group_task_toggles()

    def _load_tsv(self) -> None:
        """Load and validate a TSV file."""
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            "Select TSV file",
            "",
            "TSV files (*.tsv);;All files (*.*)"
        )

        if not file_path:
            return

        # Validate format
        result = validate_tsv_format(file_path, EXPECTED_COLUMNS)
        if not result.ok:
            QMessageBox.critical(self, "Format error", result.message or "Unknown format error.")
            return

        # Load data
        try:
            state.df = pd.read_csv(file_path, sep="\t")
        except Exception as e:
            QMessageBox.critical(self, "Load error", str(e))
            return

        # Reset normalized data (must be recomputed for new file)
        state.normalized_df = None
        state.metric_averages_df = None
        if hasattr(self, "calc_metric_averages_btn"):
            self.calc_metric_averages_btn.setEnabled(False)

        # Reset weighting UI/weights (parameters list may change later)
        if self.weighting_enabled_cb is not None:
            self.weighting_enabled_cb.setChecked(False)
        self._reset_weighting_ui()

        # Update UI with file path
        state.loaded_file_path = file_path
        self.file_path_edit.setText(file_path)

        # Reset caches
        state.participants_cache = []
        state.tasks_cache = []

        # Clear listboxes
        self.participants_list.clear()
        self.tasks_list.clear()

        # Disable action buttons during loading
        self.group_participants_btn.setEnabled(False)
        self.group_tasks_btn.setEnabled(False)
        self._set_main_action_buttons_enabled(False)

        # Extract participants
        try:
            state.participants_cache = extract_participants(state.df, column="Participant")
        except Exception as e:
            QMessageBox.critical(self, "Participant scan failed", str(e))
            state.df = None
            return

        # Extract tasks
        try:
            state.tasks_cache = extract_tasks_from_toi(state.df, column="TOI")
        except Exception as e:
            QMessageBox.critical(self, "Task scan failed", str(e))
            state.df = None
            return

        # Keep only labels for tasks that exist
        state.task_labels = {k: v for k, v in state.task_labels.items() if k in set(state.tasks_cache)}

        # Update listboxes
        for p in state.participants_cache:
            self.participants_list.addItem(p)

        self._refresh_tasks_listbox()

        # Enable group buttons
        self.group_participants_btn.setEnabled(bool(state.participants_cache))
        self.group_tasks_btn.setEnabled(bool(state.tasks_cache))

        if self.weighting_enabled_cb is not None:
            self.weighting_enabled_cb.setEnabled(True)

        self._set_main_action_buttons_enabled(True)
        self._refresh_group_task_toggles()

        QMessageBox.information(
            self,
            "Success",
            f"Loaded {len(state.df)} rows.\n"
            f"Found {len(state.participants_cache)} participants and {len(state.tasks_cache)} tasks."
        )

    def _refresh_tasks_listbox(self) -> None:
        """Refresh the tasks listbox with formatted task names."""
        self.tasks_list.clear()
        for t in state.tasks_cache:
            self.tasks_list.addItem(state.format_task(t))

    def _set_main_action_buttons_enabled(self, enabled: bool) -> None:
        """Enable or disable main action buttons."""
        self.show_results_btn.setEnabled(enabled)
        self.normalize_btn.setEnabled(enabled)
        self.calc_metric_averages_btn.setEnabled(enabled)
        self.exec_summary_btn.setEnabled(enabled)
    def _refresh_group_task_toggles(self) -> None:
        """Refresh the checkbox lists in the Results section."""
        # Clear existing group checkboxes
        while self.groups_layout.count():
            item = self.groups_layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()

        # Clear existing task checkboxes
        while self.tasks_layout.count():
            item = self.tasks_layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()

        self.result_group_checkboxes.clear()
        self.result_task_checkboxes.clear()

        # Groups toggles
        effective_groups = state.get_effective_participant_groups()
        effective_names = state.get_effective_group_names()

        if not effective_groups:
            label = QLabel("(Load a TSV file first)")
            label.setStyleSheet("color: #666;")
            self.groups_layout.addWidget(label)
        else:
            for gid in effective_groups.keys():
                name = effective_names.get(gid, gid)
                cb = QCheckBox(name)
                cb.setChecked(True)
                self.result_group_checkboxes[gid] = cb
                self.groups_layout.addWidget(cb)

        self.groups_layout.addStretch()

        # Tasks toggles
        if not state.tasks_cache:
            label = QLabel("(Load a TSV file first)")
            label.setStyleSheet("color: #666;")
            self.tasks_layout.addWidget(label, 0, 0)
            return

        cols = 8
        row = 0
        col = 0
        for tid in state.tasks_cache:
            cb = QCheckBox(state.format_task(tid))
            cb.setChecked(True)
            self.result_task_checkboxes[tid] = cb
            self.tasks_layout.addWidget(cb, row, col)
            col += 1
            if col >= cols:
                col = 0
                row += 1

    def _build_deselect_menu(self) -> None:
        """Build the deselect parameters menu."""
        self.deselect_menu = QMenu(self)
        self.deselect_param_checkboxes.clear()

        for name in PARAMETER_OPTIONS:
            action = QAction(name, self)
            action.setCheckable(True)
            action.triggered.connect(self._update_deselect_label)
            self.deselect_menu.addAction(action)
            self.deselect_param_checkboxes[name] = action

    def _reset_weighting_ui(self) -> None:
        """Clear all weighting rows and internal weights; keep toggle state."""
        self.parameter_weights.clear()
        self.weight_rows.clear()

        # Clear UI rows
        if hasattr(self, "weighting_rows_layout"):
            while self.weighting_rows_layout.count():
                item = self.weighting_rows_layout.takeAt(0)
                if item.widget():
                    item.widget().deleteLater()

        # If enabled and we have parameters, create first row
        if self.weighting_enabled_cb is not None and self.weighting_enabled_cb.isChecked():
            self._ensure_next_weight_row()

    def _on_weighting_toggled(self, state_val: int) -> None:
        enabled = state_val == Qt.CheckState.Checked.value
        if not enabled:
            self._reset_weighting_ui()
            return
        self._reset_weighting_ui()

    def _selected_weight_params(self) -> set[str]:
        selected: set[str] = set()
        for combo, _slider, _lbl in self.weight_rows:
            val = combo.currentData()
            if isinstance(val, str) and val:
                selected.add(val)
        return selected

    def _available_weight_params(self) -> list[str]:
        # PARAMETER_OPTIONS sind die “Parameter” im Tool
        selected = self._selected_weight_params()
        return [p for p in PARAMETER_OPTIONS if p not in selected]

    def _create_weight_row(self) -> None:
        available = self._available_weight_params()
        if not available:
            return

        row = QWidget()
        row_layout = QHBoxLayout(row)
        row_layout.setContentsMargins(0, 0, 0, 0)

        combo = QComboBox()
        combo.setFixedWidth(260)
        combo.addItem("Select parameter...", None)
        for p in available:
            combo.addItem(p, p)

        slider = QSlider(Qt.Orientation.Horizontal)
        # 0..3 in 0.25 steps => 0..12
        slider.setMinimum(0)
        slider.setMaximum(12)
        slider.setValue(self._weight_float_to_slider(1.0))
        slider.setSingleStep(1)
        slider.setPageStep(1)
        slider.setFixedWidth(220)
        slider.setEnabled(False)  # erst aktivieren, wenn Parameter gewählt

        value_lbl = QLabel(self._format_weight(1.0))
        value_lbl.setFixedWidth(44)
        value_lbl.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        value_lbl.setEnabled(False)

        # Signals
        combo.currentIndexChanged.connect(
            lambda _i, c=combo, s=slider, l=value_lbl: self._on_weight_row_changed(c, s, l)
        )
        slider.valueChanged.connect(
            lambda _v, c=combo, s=slider, l=value_lbl: self._on_weight_row_changed(c, s, l)
        )

        row_layout.addWidget(combo)
        row_layout.addWidget(slider)
        row_layout.addWidget(value_lbl)
        row_layout.addStretch()

        self.weighting_rows_layout.addWidget(row)
        self.weight_rows.append((combo, slider, value_lbl))

    def _on_weight_row_changed(self, combo: QComboBox, slider: QSlider, value_lbl: QLabel) -> None:
        # Wenn Toggle aus: ignorieren
        if self.weighting_enabled_cb is None or not self.weighting_enabled_cb.isChecked():
            return

        param = combo.currentData()
        if not isinstance(param, str) or not param:
            slider.setEnabled(False)
            value_lbl.setEnabled(False)
            return

        slider.setEnabled(True)
        value_lbl.setEnabled(True)

        weight = self._weight_slider_to_float(slider.value())
        value_lbl.setText(self._format_weight(weight))

        # Gewicht speichern (0.00..3.00 in 0.25er Schritten)
        self.parameter_weights[param] = float(weight)

        # Alle Combos neu aufbauen, damit keine Duplikate möglich sind
        self._rebuild_weight_combos(keep_current=True)

        # Wenn diese Zeile “aktiv” ist, nächste Zeile sicherstellen
        self._ensure_next_weight_row()

    def _rebuild_weight_combos(self, keep_current: bool = True) -> None:
        selected = self._selected_weight_params()

        for combo, slider, value_lbl in self.weight_rows:
            current = combo.currentData() if keep_current else None

            # Block signals während rebuild
            combo.blockSignals(True)
            combo.clear()
            combo.addItem("Select parameter...", None)

            # In dieser Combo darf current weiterhin drin sein
            allowed: list[str] = []
            for p in PARAMETER_OPTIONS:
                if p == current:
                    allowed.append(p)
                elif p not in selected:
                    allowed.append(p)

            for p in allowed:
                combo.addItem(p, p)

            # Restore selection
            if isinstance(current, str) and current:
                idx = combo.findData(current)
                combo.setCurrentIndex(idx if idx >= 0 else 0)
                slider.setEnabled(True)
                value_lbl.setEnabled(True)

                # Label/weight sync
                weight = self._weight_slider_to_float(slider.value())
                value_lbl.setText(self._format_weight(weight))
                self.parameter_weights[current] = float(weight)
            else:
                combo.setCurrentIndex(0)
                slider.setEnabled(False)
                value_lbl.setEnabled(False)

            combo.blockSignals(False)

    def _ensure_next_weight_row(self) -> None:
        if self.weighting_enabled_cb is None or not self.weighting_enabled_cb.isChecked():
            return

        available = self._available_weight_params()
        if not available:
            return

        if not self.weight_rows:
            self._create_weight_row()
            return

        last_combo, _last_slider, _last_lbl = self.weight_rows[-1]
        last_param = last_combo.currentData()
        if isinstance(last_param, str) and last_param:
            self._create_weight_row()

    def _toggle_deselect_menu(self, state_val: int) -> None:
        """Toggle the deselect parameters menu button."""
        self.deselect_btn.setEnabled(state_val == Qt.CheckState.Checked.value)

    def _show_deselect_menu(self) -> None:
        """Show the deselect parameters menu."""
        self.deselect_menu.exec(self.deselect_btn.mapToGlobal(self.deselect_btn.rect().bottomLeft()))

    def _update_deselect_label(self) -> None:
        """Update the deselect button label."""
        count = sum(1 for action in self.deselect_param_checkboxes.values() if action.isChecked())
        self.deselect_btn.setText("None" if count == 0 else f"{count} deselected")

    def _open_group_participants(self) -> None:
        """Open the group participants dialog."""
        if not state.participants_cache:
            QMessageBox.information(self, "No data", "Load a TSV file first.")
            return

        dialog = GroupParticipantsDialog(self)
        if dialog.exec() == GroupParticipantsDialog.DialogCode.Accepted:
            self._refresh_group_task_toggles()

    def _open_group_tasks(self) -> None:
        """Open the group tasks dialog."""
        if not state.tasks_cache:
            QMessageBox.information(self, "No data", "Load a TSV file first.")
            return

        dialog = GroupTasksDialog(self)
        if dialog.exec() == GroupTasksDialog.DialogCode.Accepted:
            self._refresh_tasks_listbox()
            self._refresh_group_task_toggles()

    def _on_normalize(self) -> None:
        """Normalize numeric data per participant by baseline task 0a (fallback 0b)."""
        if state.df is None:
            QMessageBox.information(self, "No data", "Load a TSV file first.")
            return

        try:
            state.normalized_df = normalize_by_participant_baseline(
                state.df,
                participant_col="Participant",
                task_col="TOI",
                baseline_primary="0a",
                baseline_fallback="0b",
            )
        except Exception as e:
            QMessageBox.critical(self, "Normalize failed", str(e))
            return

        if hasattr(self, "calc_metric_averages_btn"):
            self.calc_metric_averages_btn.setEnabled(True)

        QMessageBox.information(
            self,
            "Normalization complete",
            "Normalized data stored in state.normalized_df (baseline: 0a, fallback: 0b).",
        )

    def _on_calculate_metric_averages(self) -> None:
        """Berechnet TCT (Mean) und Standardabweichung der TCT je Participant und Task aus state.normalized_df."""
        if state.normalized_df is None:
            QMessageBox.information(
                self,
                "No normalized data",
                "Bitte zuerst 'Normalize' ausführen (state.normalized_df ist leer).",
            )
            return

        df = state.normalized_df

        # Spalten prüfen
        if "Participant" not in df.columns or "TOI" not in df.columns:
            QMessageBox.critical(self, "Missing columns", "normalized_df benötigt Spalten 'Participant' und 'TOI'.")
            return

        # Task-ID wie beim Task-Scan: Suffix nach letztem '_' (oder kompletter String)
        toi = df["TOI"].astype(str).str.strip()
        task_id = toi.str.rsplit("_", n=1).str[-1].str.strip()

        # TCT-Spalte bestimmen
        tct_col: Optional[str] = None
        if "Duration" in df.columns:
            tct_col = "Duration"
        else:
            # Fallback: heuristische Suche
            candidates = {
                "tct",
                "task completion time",
                "task_completion_time",
                "taskcompletiontime",
                "completion_time",
                "task time",
                "task_time",
            }
            lower_map = {c.lower(): c for c in df.columns}
            for key in candidates:
                if key in lower_map:
                    tct_col = lower_map[key]
                    break

        if tct_col is None:
            QMessageBox.critical(
                self,
                "TCT column not found",
                "Konnte keine TCT-Spalte finden. Erwartet z.B. 'Duration' oder eine Spalte wie 'TCT'/'Task Completion Time'.",
            )
            return

        if not pd.api.types.is_numeric_dtype(df[tct_col]):
            QMessageBox.critical(
                self,
                "TCT column not numeric",
                f"Die gefundene TCT-Spalte '{tct_col}' ist nicht numerisch.",
            )
            return

        tmp = df[["Participant", "TOI", tct_col]].copy()
        tmp["_task_id"] = task_id

        # Aggregation: mean + std je Participant x Task
        grouped = tmp.groupby(["Participant", "_task_id"], dropna=False)[tct_col].agg(["mean", "std"]).reset_index()
        grouped = grouped.rename(
            columns={
                "_task_id": "Task",
                "mean": "tct_mean",
                "std": "tct_std",
            }
        )

        state.metric_averages_df = grouped

        QMessageBox.information(
            self,
            "Metric averages calculated",
            f"Fertig. TCT-Mean/Std in state.metric_averages_df gespeichert.\n"
            f"Quelle: Spalte '{tct_col}'.\n"
            f"Zeilen: {len(grouped)} | Spalten: {len(grouped.columns)}",
        )

    def _on_show_results(self) -> None:
        """Handle Show Results button click."""
        if state.df is None:
            QMessageBox.information(self, "No data", "Load a TSV file first.")
            return

        selected_groups = [gid for gid, cb in self.result_group_checkboxes.items() if cb.isChecked()]
        selected_tasks = [tid for tid, cb in self.result_task_checkboxes.items() if cb.isChecked()]
        domains = [name for name, cb in self.result_domain_vars.items() if cb.isChecked()]
        mode = self.mode_combo.currentText()

        deselected = []
        if self.deselect_enabled_cb.isChecked():
            deselected = [name for name, action in self.deselect_param_checkboxes.items() if action.isChecked()]

        # Parameter weights (nur anzeigen, wenn aktiviert)
        weights_text = "(disabled)"
        if self.weighting_enabled_cb is not None and self.weighting_enabled_cb.isChecked():
            if not self.parameter_weights:
                weights_text = "(none)"
            else:
                parts = [f"{k} = {self._format_weight(v)}" for k, v in sorted(self.parameter_weights.items())]
                weights_text = ", ".join(parts)

        msg = (
            f"Mode: {mode}\n"
            f"Groups selected: {len(selected_groups)}\n"
            f"Tasks selected: {len(selected_tasks)}\n"
            f"Result domains: {', '.join(domains) if domains else '(none)'}\n"
            f"Deselected parameters: {', '.join(deselected) if deselected else '(none)'}\n"
            f"Parameter weights: {weights_text}"
        )
        QMessageBox.information(self, "Show Results (placeholder)", msg)

    def _on_print_exec_summary(self) -> None:
        """Handle Print Executive Summary button click."""
        if state.df is None:
            QMessageBox.information(self, "No data", "Load a TSV file first.")
            return
        QMessageBox.information(
            self,
            "Executive Summary (placeholder)",
            "This will generate the executive summary later.",
        )
```

> Tokens: 17k sent, 6.4k received. Cost: $0.12 message, $1.58 session.  
> Applied edit to main_window.py  
> Commit 2c56bb2 fix: Berechne TCT-Mittelwert und -Std je Teilnehmer und Task  
> You can use /undo to undo and discard each aider commit.  

#### /undo  
> Removed: 2c56bb2 fix: Berechne TCT-Mittelwert und -Std je Teilnehmer und Task  
> Now at:  6e2e53c feat: Button zum Berechnen von Metrik-Mittelwerten hinzufügen  
> You can use /undo to undo and discard each aider commit.  

#### In MainWindow._on_calculate_metric_averages() wird aktuell für alle  
####    numerischen Spalten Mean/Std je Participant und Task berechnet.  
####  • Ich will zusätzlich die Task Completion Time  
####    (TCT) und Standardabweichung der TCT je Participant und Task berechnen  
####    und in state.metric_averages_df ablegen, ohne  Mean/Std je Participant und Task zu überschreiben.  

Ja, dafür sind Codeänderungen nötig.

## Was geändert werden muss
- `MainWindow._on_calculate_metric_averages()` soll **weiterhin** Mean/Std für **alle numerischen Spalten** je `Participant` und Task berechnen (wie aktuell).
- Zusätzlich sollen **TCT-Mittelwert** und **TCT-Standardabweichung** je `Participant` und Task berechnet werden.
- Diese TCT-Ergebnisse dürfen die bestehenden Mean/Std-Spalten **nicht überschreiben**. Daher werden sie als **zusätzliche Spalten** an das Ergebnis-DataFrame angehängt (Merge auf `Participant` + `Task`).
- Damit es keine Namenskollisionen gibt, verwende ich eindeutige Spaltennamen: `tct_mean` und `tct_std`.
- TCT-Spalte wird robust ermittelt: bevorzugt `Duration`, sonst heuristische Kandidaten (case-insensitive). Falls keine gefunden wird, wird nur die bisherige Aggregation gespeichert und eine Info angezeigt.

main_window.py
```
"""
Main window for the Eye Tracking Tool using PyQt6.
"""
from __future__ import annotations

from typing import Dict, Optional
import pandas as pd

from PyQt6.QtWidgets import (
    QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, QLabel, QPushButton,
    QListWidget, QLineEdit, QComboBox, QCheckBox, QGroupBox, QGridLayout,
    QFrame, QMessageBox, QFileDialog, QMenu, QMenuBar, QSplitter, QSlider
)
from PyQt6.QtCore import Qt, QSize
from PyQt6.QtGui import QAction

from state import state
from models import EXPECTED_COLUMNS, PARAMETER_OPTIONS
from data_processor import (
    validate_tsv_format,
    extract_participants,
    extract_tasks_from_toi,
    normalize_by_participant_baseline,
)
from dialogs import GroupParticipantsDialog, GroupTasksDialog


class MainWindow(QMainWindow):
    """Main application window."""

    def __init__(self) -> None:
        super().__init__()
        self.setWindowTitle("Eye Tracking Analysis Tool")
        self.setMinimumSize(1200, 720)

        # Result domain checkboxes
        self.result_domain_vars: Dict[str, QCheckBox] = {}

        # Result group/task checkboxes
        self.result_group_checkboxes: Dict[str, QCheckBox] = {}
        self.result_task_checkboxes: Dict[str, QCheckBox] = {}

        # Deselect parameters
        self.deselect_param_checkboxes: Dict[str, QCheckBox] = {}

        # Weighting parameters
        self.weighting_enabled_cb: Optional[QCheckBox] = None
        self.weight_rows: list[tuple[QComboBox, QSlider, QLabel]] = []
        self.parameter_weights: Dict[str, float] = {}

        self._setup_ui()

    # --- Weighting slider mapping (QSlider is int-based) ---
    def _weight_slider_to_float(self, slider_val: int) -> float:
        # 0..12 -> 0.00..3.00 in 0.25 steps
        return float(slider_val) / 4.0

    def _weight_float_to_slider(self, weight: float) -> int:
        # clamp + round to nearest 0.25 step
        w = max(0.0, min(3.0, float(weight)))
        return int(round(w * 4.0))

    def _format_weight(self, weight: float) -> str:
        return f"{weight:.2f}".rstrip("0").rstrip(".")

    def _setup_ui(self) -> None:
        central = QWidget()
        self.setCentralWidget(central)
        main_layout = QVBoxLayout(central)
        main_layout.setContentsMargins(10, 10, 10, 10)

        # Top bar
        topbar = QHBoxLayout()

        self.load_btn = QPushButton("Load TSV")
        self.load_btn.setFixedWidth(120)
        self.load_btn.clicked.connect(self._load_tsv)
        topbar.addWidget(self.load_btn)

        self.group_participants_btn = QPushButton("Group Participants")
        self.group_participants_btn.setFixedWidth(150)
        self.group_participants_btn.setEnabled(False)
        self.group_participants_btn.clicked.connect(self._open_group_participants)
        topbar.addWidget(self.group_participants_btn)

        # Button-Text wie gewünscht: "Name Tasks"
        self.group_tasks_btn = QPushButton("Name Tasks")
        self.group_tasks_btn.setFixedWidth(120)
        self.group_tasks_btn.setEnabled(False)
        self.group_tasks_btn.clicked.connect(self._open_group_tasks)
        topbar.addWidget(self.group_tasks_btn)

        self.file_path_edit = QLineEdit()
        self.file_path_edit.setReadOnly(True)
        self.file_path_edit.setPlaceholderText("No file loaded")
        topbar.addWidget(self.file_path_edit)

        main_layout.addLayout(topbar)

        # Listboxes section
        listbox_layout = QHBoxLayout()

        # Participants listbox
        left_widget = QWidget()
        left_layout = QVBoxLayout(left_widget)
        left_layout.setContentsMargins(0, 0, 0, 0)
        left_layout.addWidget(QLabel('Detected participants (from "Participant"):'))
        self.participants_list = QListWidget()
        self.participants_list.setMaximumHeight(120)
        left_layout.addWidget(self.participants_list)
        listbox_layout.addWidget(left_widget)

        # Tasks listbox
        right_widget = QWidget()
        right_layout = QVBoxLayout(right_widget)
        right_layout.setContentsMargins(0, 0, 0, 0)
        right_layout.addWidget(QLabel('Detected tasks (from "TOI" suffix):'))
        self.tasks_list = QListWidget()
        self.tasks_list.setMaximumHeight(120)
        right_layout.addWidget(self.tasks_list)
        listbox_layout.addWidget(right_widget)

        main_layout.addLayout(listbox_layout)

        # Separator
        separator = QFrame()
        separator.setFrameShape(QFrame.Shape.HLine)
        separator.setFrameShadow(QFrame.Shadow.Sunken)
        main_layout.addWidget(separator)

        # Results section
        results_label = QLabel("Results")
        results_label.setStyleSheet("font-weight: bold; font-size: 14px;")
        main_layout.addWidget(results_label)

        # Mode selection
        mode_layout = QHBoxLayout()
        mode_layout.addWidget(QLabel("Show results for:"))

        self.mode_combo = QComboBox()
        self.mode_combo.addItems([
            "Only group mean",
            "Each participant for selected groups",
            "Group mean and individual participants",
        ])
        self.mode_combo.setFixedWidth(350)
        mode_layout.addWidget(self.mode_combo)
        mode_layout.addStretch()
        main_layout.addLayout(mode_layout)

        # Groups and Tasks frames
        sel_layout = QHBoxLayout()

        self.groups_group = QGroupBox("Groups")
        self.groups_layout = QVBoxLayout(self.groups_group)
        sel_layout.addWidget(self.groups_group)

        self.tasks_group = QGroupBox("Tasks")
        self.tasks_layout = QGridLayout(self.tasks_group)
        sel_layout.addWidget(self.tasks_group)

        main_layout.addLayout(sel_layout)

        # Bottom row: Result domain and Deselect parameters
        bottom_layout = QHBoxLayout()

        # Result domain
        domain_group = QGroupBox("Result domain")
        domain_layout = QHBoxLayout(domain_group)

        for name in ["Rank", "Radar Chart", "Task Completion Time"]:
            cb = QCheckBox(name)
            cb.setChecked(True)
            self.result_domain_vars[name] = cb
            domain_layout.addWidget(cb)

        domain_layout.addStretch()
        bottom_layout.addWidget(domain_group)

        # Deselect parameters
        deselect_group = QGroupBox("Deselect Parameters")
        deselect_layout = QHBoxLayout(deselect_group)

        self.deselect_enabled_cb = QCheckBox("Enable Deselect")
        self.deselect_enabled_cb.stateChanged.connect(self._toggle_deselect_menu)
        deselect_layout.addWidget(self.deselect_enabled_cb)

        self.deselect_btn = QPushButton("None")
        self.deselect_btn.setEnabled(False)
        self.deselect_btn.clicked.connect(self._show_deselect_menu)
        deselect_layout.addWidget(self.deselect_btn)

        deselect_layout.addStretch()
        bottom_layout.addWidget(deselect_group)

        # Weighting parameters
        weighting_group = QGroupBox("Weighting Parameters")
        weighting_outer = QVBoxLayout(weighting_group)

        # Toggle row: checkbox + label rechts
        weighting_toggle_row = QHBoxLayout()
        self.weighting_enabled_cb = QCheckBox()
        self.weighting_enabled_cb.setChecked(False)
        self.weighting_enabled_cb.setEnabled(False)
        self.weighting_enabled_cb.stateChanged.connect(self._on_weighting_toggled)
        weighting_toggle_row.addWidget(self.weighting_enabled_cb)
        weighting_toggle_row.addWidget(QLabel("Enable custom parameter weights"))
        weighting_toggle_row.addStretch()
        weighting_outer.addLayout(weighting_toggle_row)

        # Container für dynamische Zeilen
        self.weighting_rows_container = QWidget()
        self.weighting_rows_layout = QVBoxLayout(self.weighting_rows_container)
        self.weighting_rows_layout.setContentsMargins(0, 0, 0, 0)
        self.weighting_rows_layout.setSpacing(6)
        weighting_outer.addWidget(self.weighting_rows_container)

        bottom_layout.addWidget(weighting_group)

        main_layout.addLayout(bottom_layout)

        # Action buttons
        action_layout = QHBoxLayout()

        self.show_results_btn = QPushButton("Show Results")
        self.show_results_btn.setFixedWidth(150)
        self.show_results_btn.setEnabled(False)
        self.show_results_btn.clicked.connect(self._on_show_results)
        action_layout.addWidget(self.show_results_btn)

        self.normalize_btn = QPushButton("Normalize")
        self.normalize_btn.setFixedWidth(150)
        self.normalize_btn.setEnabled(False)
        self.normalize_btn.clicked.connect(self._on_normalize)
        action_layout.addWidget(self.normalize_btn)

        self.calc_metric_averages_btn = QPushButton("Calculate metric averages")
        self.calc_metric_averages_btn.setFixedWidth(200)
        self.calc_metric_averages_btn.setEnabled(False)
        self.calc_metric_averages_btn.clicked.connect(self._on_calculate_metric_averages)
        action_layout.addWidget(self.calc_metric_averages_btn)

        self.exec_summary_btn = QPushButton("Print Executive Summary")
        self.exec_summary_btn.setFixedWidth(180)
        self.exec_summary_btn.setEnabled(False)
        self.exec_summary_btn.clicked.connect(self._on_print_exec_summary)
        action_layout.addWidget(self.exec_summary_btn)

        action_layout.addStretch()
        main_layout.addLayout(action_layout)

        main_layout.addStretch()

        # Initialize deselect menu
        self._build_deselect_menu()

        # Initialize weighting UI (disabled by default)
        self._reset_weighting_ui()

        # Initial population
        self._refresh_group_task_toggles()

    def _load_tsv(self) -> None:
        """Load and validate a TSV file."""
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            "Select TSV file",
            "",
            "TSV files (*.tsv);;All files (*.*)"
        )

        if not file_path:
            return

        # Validate format
        result = validate_tsv_format(file_path, EXPECTED_COLUMNS)
        if not result.ok:
            QMessageBox.critical(self, "Format error", result.message or "Unknown format error.")
            return

        # Load data
        try:
            state.df = pd.read_csv(file_path, sep="\t")
        except Exception as e:
            QMessageBox.critical(self, "Load error", str(e))
            return

        # Reset normalized data (must be recomputed for new file)
        state.normalized_df = None
        state.metric_averages_df = None
        if hasattr(self, "calc_metric_averages_btn"):
            self.calc_metric_averages_btn.setEnabled(False)

        # Reset weighting UI/weights (parameters list may change later)
        if self.weighting_enabled_cb is not None:
            self.weighting_enabled_cb.setChecked(False)
        self._reset_weighting_ui()

        # Update UI with file path
        state.loaded_file_path = file_path
        self.file_path_edit.setText(file_path)

        # Reset caches
        state.participants_cache = []
        state.tasks_cache = []

        # Clear listboxes
        self.participants_list.clear()
        self.tasks_list.clear()

        # Disable action buttons during loading
        self.group_participants_btn.setEnabled(False)
        self.group_tasks_btn.setEnabled(False)
        self._set_main_action_buttons_enabled(False)

        # Extract participants
        try:
            state.participants_cache = extract_participants(state.df, column="Participant")
        except Exception as e:
            QMessageBox.critical(self, "Participant scan failed", str(e))
            state.df = None
            return

        # Extract tasks
        try:
            state.tasks_cache = extract_tasks_from_toi(state.df, column="TOI")
        except Exception as e:
            QMessageBox.critical(self, "Task scan failed", str(e))
            state.df = None
            return

        # Keep only labels for tasks that exist
        state.task_labels = {k: v for k, v in state.task_labels.items() if k in set(state.tasks_cache)}

        # Update listboxes
        for p in state.participants_cache:
            self.participants_list.addItem(p)

        self._refresh_tasks_listbox()

        # Enable group buttons
        self.group_participants_btn.setEnabled(bool(state.participants_cache))
        self.group_tasks_btn.setEnabled(bool(state.tasks_cache))

        if self.weighting_enabled_cb is not None:
            self.weighting_enabled_cb.setEnabled(True)

        self._set_main_action_buttons_enabled(True)
        self._refresh_group_task_toggles()

        QMessageBox.information(
            self,
            "Success",
            f"Loaded {len(state.df)} rows.\n"
            f"Found {len(state.participants_cache)} participants and {len(state.tasks_cache)} tasks."
        )

    def _refresh_tasks_listbox(self) -> None:
        """Refresh the tasks listbox with formatted task names."""
        self.tasks_list.clear()
        for t in state.tasks_cache:
            self.tasks_list.addItem(state.format_task(t))

    def _set_main_action_buttons_enabled(self, enabled: bool) -> None:
        """Enable or disable main action buttons."""
        self.show_results_btn.setEnabled(enabled)
        self.normalize_btn.setEnabled(enabled)
        self.calc_metric_averages_btn.setEnabled(enabled)
        self.exec_summary_btn.setEnabled(enabled)

    def _refresh_group_task_toggles(self) -> None:
        """Refresh the checkbox lists in the Results section."""
        # Clear existing group checkboxes
        while self.groups_layout.count():
            item = self.groups_layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()

        # Clear existing task checkboxes
        while self.tasks_layout.count():
            item = self.tasks_layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()

        self.result_group_checkboxes.clear()
        self.result_task_checkboxes.clear()

        # Groups toggles
        effective_groups = state.get_effective_participant_groups()
        effective_names = state.get_effective_group_names()

        if not effective_groups:
            label = QLabel("(Load a TSV file first)")
            label.setStyleSheet("color: #666;")
            self.groups_layout.addWidget(label)
        else:
            for gid in effective_groups.keys():
                name = effective_names.get(gid, gid)
                cb = QCheckBox(name)
                cb.setChecked(True)
                self.result_group_checkboxes[gid] = cb
                self.groups_layout.addWidget(cb)

        self.groups_layout.addStretch()

        # Tasks toggles
        if not state.tasks_cache:
            label = QLabel("(Load a TSV file first)")
            label.setStyleSheet("color: #666;")
            self.tasks_layout.addWidget(label, 0, 0)
            return

        cols = 8
        row = 0
        col = 0
        for tid in state.tasks_cache:
            cb = QCheckBox(state.format_task(tid))
            cb.setChecked(True)
            self.result_task_checkboxes[tid] = cb
            self.tasks_layout.addWidget(cb, row, col)
            col += 1
            if col >= cols:
                col = 0
                row += 1

    def _build_deselect_menu(self) -> None:
        """Build the deselect parameters menu."""
        self.deselect_menu = QMenu(self)
        self.deselect_param_checkboxes.clear()

        for name in PARAMETER_OPTIONS:
            action = QAction(name, self)
            action.setCheckable(True)
            action.triggered.connect(self._update_deselect_label)
            self.deselect_menu.addAction(action)
            self.deselect_param_checkboxes[name] = action

    def _reset_weighting_ui(self) -> None:
        """Clear all weighting rows and internal weights; keep toggle state."""
        self.parameter_weights.clear()
        self.weight_rows.clear()

        # Clear UI rows
        if hasattr(self, "weighting_rows_layout"):
            while self.weighting_rows_layout.count():
                item = self.weighting_rows_layout.takeAt(0)
                if item.widget():
                    item.widget().deleteLater()

        # If enabled and we have parameters, create first row
        if self.weighting_enabled_cb is not None and self.weighting_enabled_cb.isChecked():
            self._ensure_next_weight_row()

    def _on_weighting_toggled(self, state_val: int) -> None:
        enabled = state_val == Qt.CheckState.Checked.value
        if not enabled:
            self._reset_weighting_ui()
            return
        self._reset_weighting_ui()

    def _selected_weight_params(self) -> set[str]:
        selected: set[str] = set()
        for combo, _slider, _lbl in self.weight_rows:
            val = combo.currentData()
            if isinstance(val, str) and val:
                selected.add(val)
        return selected

    def _available_weight_params(self) -> list[str]:
        # PARAMETER_OPTIONS sind die “Parameter” im Tool
        selected = self._selected_weight_params()
        return [p for p in PARAMETER_OPTIONS if p not in selected]

    def _create_weight_row(self) -> None:
        available = self._available_weight_params()
        if not available:
            return

        row = QWidget()
        row_layout = QHBoxLayout(row)
        row_layout.setContentsMargins(0, 0, 0, 0)

        combo = QComboBox()
        combo.setFixedWidth(260)
        combo.addItem("Select parameter...", None)
        for p in available:
            combo.addItem(p, p)

        slider = QSlider(Qt.Orientation.Horizontal)
        # 0..3 in 0.25 steps => 0..12
        slider.setMinimum(0)
        slider.setMaximum(12)
        slider.setValue(self._weight_float_to_slider(1.0))
        slider.setSingleStep(1)
        slider.setPageStep(1)
        slider.setFixedWidth(220)
        slider.setEnabled(False)  # erst aktivieren, wenn Parameter gewählt

        value_lbl = QLabel(self._format_weight(1.0))
        value_lbl.setFixedWidth(44)
        value_lbl.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        value_lbl.setEnabled(False)

        # Signals
        combo.currentIndexChanged.connect(
            lambda _i, c=combo, s=slider, l=value_lbl: self._on_weight_row_changed(c, s, l)
        )
        slider.valueChanged.connect(
            lambda _v, c=combo, s=slider, l=value_lbl: self._on_weight_row_changed(c, s, l)
        )

        row_layout.addWidget(combo)
        row_layout.addWidget(slider)
        row_layout.addWidget(value_lbl)
        row_layout.addStretch()

        self.weighting_rows_layout.addWidget(row)
        self.weight_rows.append((combo, slider, value_lbl))

    def _on_weight_row_changed(self, combo: QComboBox, slider: QSlider, value_lbl: QLabel) -> None:
        # Wenn Toggle aus: ignorieren
        if self.weighting_enabled_cb is None or not self.weighting_enabled_cb.isChecked():
            return

        param = combo.currentData()
        if not isinstance(param, str) or not param:
            slider.setEnabled(False)
            value_lbl.setEnabled(False)
            return

        slider.setEnabled(True)
        value_lbl.setEnabled(True)

        weight = self._weight_slider_to_float(slider.value())
        value_lbl.setText(self._format_weight(weight))

        # Gewicht speichern (0.00..3.00 in 0.25er Schritten)
        self.parameter_weights[param] = float(weight)

        # Alle Combos neu aufbauen, damit keine Duplikate möglich sind
        self._rebuild_weight_combos(keep_current=True)

        # Wenn diese Zeile “aktiv” ist, nächste Zeile sicherstellen
        self._ensure_next_weight_row()

    def _rebuild_weight_combos(self, keep_current: bool = True) -> None:
        selected = self._selected_weight_params()

        for combo, slider, value_lbl in self.weight_rows:
            current = combo.currentData() if keep_current else None

            # Block signals während rebuild
            combo.blockSignals(True)
            combo.clear()
            combo.addItem("Select parameter...", None)

            # In dieser Combo darf current weiterhin drin sein
            allowed: list[str] = []
            for p in PARAMETER_OPTIONS:
                if p == current:
                    allowed.append(p)
                elif p not in selected:
                    allowed.append(p)

            for p in allowed:
                combo.addItem(p, p)

            # Restore selection
            if isinstance(current, str) and current:
                idx = combo.findData(current)
                combo.setCurrentIndex(idx if idx >= 0 else 0)
                slider.setEnabled(True)
                value_lbl.setEnabled(True)

                # Label/weight sync
                weight = self._weight_slider_to_float(slider.value())
                value_lbl.setText(self._format_weight(weight))
                self.parameter_weights[current] = float(weight)
            else:
                combo.setCurrentIndex(0)
                slider.setEnabled(False)
                value_lbl.setEnabled(False)

            combo.blockSignals(False)

    def _ensure_next_weight_row(self) -> None:
        if self.weighting_enabled_cb is None or not self.weighting_enabled_cb.isChecked():
            return

        available = self._available_weight_params()
        if not available:
            return

        if not self.weight_rows:
            self._create_weight_row()
            return

        last_combo, _last_slider, _last_lbl = self.weight_rows[-1]
        last_param = last_combo.currentData()
        if isinstance(last_param, str) and last_param:
            self._create_weight_row()

    def _toggle_deselect_menu(self, state_val: int) -> None:
        """Toggle the deselect parameters menu button."""
        self.deselect_btn.setEnabled(state_val == Qt.CheckState.Checked.value)

    def _show_deselect_menu(self) -> None:
        """Show the deselect parameters menu."""
        self.deselect_menu.exec(self.deselect_btn.mapToGlobal(self.deselect_btn.rect().bottomLeft()))

    def _update_deselect_label(self) -> None:
        """Update the deselect button label."""
        count = sum(1 for action in self.deselect_param_checkboxes.values() if action.isChecked())
        self.deselect_btn.setText("None" if count == 0 else f"{count} deselected")

    def _open_group_participants(self) -> None:
        """Open the group participants dialog."""
        if not state.participants_cache:
            QMessageBox.information(self, "No data", "Load a TSV file first.")
            return

        dialog = GroupParticipantsDialog(self)
        if dialog.exec() == GroupParticipantsDialog.DialogCode.Accepted:
            self._refresh_group_task_toggles()

    def _open_group_tasks(self) -> None:
        """Open the group tasks dialog."""
        if not state.tasks_cache:
            QMessageBox.information(self, "No data", "Load a TSV file first.")
            return

        dialog = GroupTasksDialog(self)
        if dialog.exec() == GroupTasksDialog.DialogCode.Accepted:
            self._refresh_tasks_listbox()
            self._refresh_group_task_toggles()

    def _on_normalize(self) -> None:
        """Normalize numeric data per participant by baseline task 0a (fallback 0b)."""
        if state.df is None:
            QMessageBox.information(self, "No data", "Load a TSV file first.")
            return

        try:
            state.normalized_df = normalize_by_participant_baseline(
                state.df,
                participant_col="Participant",
                task_col="TOI",
                baseline_primary="0a",
                baseline_fallback="0b",
            )
        except Exception as e:
            QMessageBox.critical(self, "Normalize failed", str(e))
            return

        if hasattr(self, "calc_metric_averages_btn"):
            self.calc_metric_averages_btn.setEnabled(True)

        QMessageBox.information(
            self,
            "Normalization complete",
            "Normalized data stored in state.normalized_df (baseline: 0a, fallback: 0b).",
        )

    def _on_calculate_metric_averages(self) -> None:
        """
        Berechnet Mittelwert und Standardabweichung je Participant und Task aus state.normalized_df.
        Zusätzlich: TCT (Mean/Std) je Participant und Task als zusätzliche Spalten (ohne Überschreiben).
        """
        if state.normalized_df is None:
            QMessageBox.information(
                self,
                "No normalized data",
                "Bitte zuerst 'Normalize' ausführen (state.normalized_df ist leer).",
            )
            return

        df = state.normalized_df

        # Spalten prüfen
        if "Participant" not in df.columns or "TOI" not in df.columns:
            QMessageBox.critical(self, "Missing columns", "normalized_df benötigt Spalten 'Participant' und 'TOI'.")
            return

        # Task-ID wie beim Task-Scan: Suffix nach letztem '_' (oder kompletter String)
        toi = df["TOI"].astype(str).str.strip()
        task_id = toi.str.rsplit("_", n=1).str[-1].str.strip()

        # Nur numerische Metriken aggregieren
        metric_cols = df.select_dtypes(include="number").columns.tolist()
        metric_cols = [c for c in metric_cols if c not in {"Participant", "TOI"}]

        if not metric_cols:
            QMessageBox.information(self, "No numeric metrics", "Keine numerischen Spalten zum Aggregieren gefunden.")
            return

        tmp = df.copy()
        tmp["_task_id"] = task_id

        # Aggregation: mean + std je Participant x Task (für alle numerischen Spalten)
        grouped = tmp.groupby(["Participant", "_task_id"], dropna=False)[metric_cols].agg(["mean", "std"])

        # Spaltennamen flach machen: "<metric>_mean", "<metric>_std"
        grouped.columns = [f"{metric}_{stat}" for (metric, stat) in grouped.columns.to_list()]

        # Index zurück in Spalten
        result = grouped.reset_index().rename(columns={"_task_id": "Task"})

        # --- Zusätzlich: TCT mean/std berechnen und als zusätzliche Spalten mergen ---
        tct_col: Optional[str] = None
        if "Duration" in df.columns:
            tct_col = "Duration"
        else:
            # heuristische Suche (case-insensitive)
            candidates = [
                "tct",
                "task completion time",
                "task_completion_time",
                "taskcompletiontime",
                "completion_time",
                "task time",
                "task_time",
            ]
            lower_map = {c.lower(): c for c in df.columns}
            for key in candidates:
                if key in lower_map:
                    tct_col = lower_map[key]
                    break

        tct_added = False
        tct_note = ""
        if tct_col is None:
            tct_note = "Keine TCT-Spalte gefunden (erwartet z.B. 'Duration')."
        elif not pd.api.types.is_numeric_dtype(df[tct_col]):
            tct_note = f"TCT-Spalte '{tct_col}' ist nicht numerisch."
        else:
            tct_tmp = tmp[["Participant", "_task_id", tct_col]].copy()
            tct_grouped = (
                tct_tmp.groupby(["Participant", "_task_id"], dropna=False)[tct_col]
                .agg(["mean", "std"])
                .reset_index()
                .rename(columns={"_task_id": "Task", "mean": "tct_mean", "std": "tct_std"})
            )

            # Nicht überschreiben: falls Spalten schon existieren, eindeutige Namen wählen
            if "tct_mean" in result.columns or "tct_std" in result.columns:
                # sehr defensiv: falls schon vorhanden, suffix anhängen
                tct_grouped = tct_grouped.rename(columns={"tct_mean": "tct_mean_tct", "tct_std": "tct_std_tct"})

            result = result.merge(tct_grouped, on=["Participant", "Task"], how="left")
            tct_added = True
            tct_note = f"TCT berechnet aus Spalte '{tct_col}'."

        state.metric_averages_df = result

        extra = f"\n{tct_note}" if tct_note else ""
        QMessageBox.information(
            self,
            "Metric averages calculated",
            f"Fertig. Ergebnis in state.metric_averages_df gespeichert.\n"
            f"Zeilen: {len(result)} | Spalten: {len(result.columns)}"
            f"{extra}",
        )

    def _on_show_results(self) -> None:
        """Handle Show Results button click."""
        if state.df is None:
            QMessageBox.information(self, "No data", "Load a TSV file first.")
            return

        selected_groups = [gid for gid, cb in self.result_group_checkboxes.items() if cb.isChecked()]
        selected_tasks = [tid for tid, cb in self.result_task_checkboxes.items() if cb.isChecked()]
        domains = [name for name, cb in self.result_domain_vars.items() if cb.isChecked()]
        mode = self.mode_combo.currentText()

        deselected = []
        if self.deselect_enabled_cb.isChecked():
            deselected = [name for name, action in self.deselect_param_checkboxes.items() if action.isChecked()]

        # Parameter weights (nur anzeigen, wenn aktiviert)
        weights_text = "(disabled)"
        if self.weighting_enabled_cb is not None and self.weighting_enabled_cb.isChecked():
            if not self.parameter_weights:
                weights_text = "(none)"
            else:
                parts = [f"{k} = {self._format_weight(v)}" for k, v in sorted(self.parameter_weights.items())]
                weights_text = ", ".join(parts)

        msg = (
            f"Mode: {mode}\n"
            f"Groups selected: {len(selected_groups)}\n"
            f"Tasks selected: {len(selected_tasks)}\n"
            f"Result domains: {', '.join(domains) if domains else '(none)'}\n"
            f"Deselected parameters: {', '.join(deselected) if deselected else '(none)'}\n"
            f"Parameter weights: {weights_text}"
        )
        QMessageBox.information(self, "Show Results (placeholder)", msg)

    def _on_print_exec_summary(self) -> None:
        """Handle Print Executive Summary button click."""
        if state.df is None:
            QMessageBox.information(self, "No data", "Load a TSV file first.")
            return
        QMessageBox.information(
            self,
            "Executive Summary (placeholder)",
            "This will generate the executive summary later.",
        )
```

> Tokens: 23k sent, 6.6k received. Cost: $0.13 message, $1.71 session.  
> Applied edit to main_window.py  
> Commit 58512df feat: Ergänze TCT-Mittelwert/-Std je Participant und Task in Metriken  
> You can use /undo to undo and discard each aider commit.  

#### /arc  
> Aider v0.86.1  
> Model: gpt-5.2 with architect edit format  
> Editor model: gpt-5.2 with editor-whole edit format  
> Git repo: .git with 25 files  
> Repo-map: using 4096 tokens, auto refresh  
> Added data_processor.py to the chat.  
> Added dialogs.py to the chat.  
> Added eye_tracking_tool\dialogs.py to the chat.  
> Added main_window.py to the chat.  
> Added state.py to the chat.  
> Restored previous conversation history.  

#### /code  
> Aider v0.86.1  
> Model: gpt-5.2 with whole edit format  
> Git repo: .git with 25 files  
> Repo-map: using 4096 tokens, auto refresh  
> Added data_processor.py to the chat.  
> Added dialogs.py to the chat.  
> Added eye_tracking_tool\dialogs.py to the chat.  
> Added main_window.py to the chat.  
> Added state.py to the chat.  
> Restored previous conversation history.  

#### Create a new button next to exec_summary_btn called Calculate Participant Rank. On click, compute and store a pandas DataFrame participant_rank_df that ranks, for each participant, the selected tasks from hardest→easiest in cognitive load by (1) computing each metric per participant×task, (2) ranking that participant’s tasks separately per metric (rank 1 = hardest; ties = average rank), then (3) aggregating into a final score via weighted rank-sum across metrics and ranking tasks by lowest summed rank; exclude any metrics selected in “Deselect Parameters” and apply “Custom parameter weights” (default 1.0, user-defined 1.0–5.0 in 0.5 steps) in the rank-sum; tasks come from selected task toggles (or all if none), participants from selected group toggles (or all if none). Reference for direction (higher cognitive load): TCT↑, SD(TCT)↑, Pupil Diameter↑, Saccade Velocity↓, Peak Saccade Velocity↓, Saccade Amplitude↓.  

Es sind Code-Änderungen nötig.

### Was wird geändert?
1. **Neuer State**: In `state.py` wird `participant_rank_df: Optional[pd.DataFrame]` ergänzt und in `reset()` initialisiert.
2. **Neuer Button + Handler**: In `main_window.py` wird neben `exec_summary_btn` ein Button **Calculate Participant Rank** hinzugefügt, der `_on_calculate_participant_rank()` aufruft.
3. **Berechnung Participant-Rank**:
   - Datenbasis: bevorzugt `state.normalized_df` (falls vorhanden), sonst `state.df`.
   - Teilnehmer: aus **ausgewählten Gruppen** (oder alle, wenn keine Gruppe ausgewählt).
   - Tasks: aus **ausgewählten Task-Toggles** (oder alle, wenn keine Tasks ausgewählt).
   - Metriken: aus `PARAMETER_OPTIONS`, abzüglich der im **Deselect Parameters** Menü ausgewählten.
   - Pro Participant×Task wird je Metrik ein Wert berechnet (Mean über Zeilen).
   - Pro Participant wird je Metrik über Tasks gerankt (Rank 1 = „härteste“; Ties = average).
   - Aggregation: gewichtete Rank-Summe (Default 1.0; Custom Weights wenn aktiviert).
   - Final: Tasks pro Participant nach **kleinster** Rank-Summe sortiert (hardest→easiest).
4. **Weights-UI Anpassung**: Die Slider-Mapping-Logik wird auf **1.0–5.0 in 0.5er Schritten** umgestellt (int 2..10, Schritt 1). Default bleibt 1.0.

Wichtige Annahme: Die Metrik-Namen in `PARAMETER_OPTIONS` werden auf Spalten gemappt. Ich habe dafür eine robuste Heuristik eingebaut (z.B. TCT → `Duration`, SD(TCT) → `Duration` std, Pupil Diameter → `Average_pupil_diameter`, etc.). Wenn eure TSV andere Spaltennamen nutzt, sag mir bitte die exakten Spaltennamen, dann passe ich das Mapping an.

main_window.py
```
"""
Main window for the Eye Tracking Tool using PyQt6.
"""
from __future__ import annotations

from typing import Dict, Optional
import pandas as pd

from PyQt6.QtWidgets import (
    QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, QLabel, QPushButton,
    QListWidget, QLineEdit, QComboBox, QCheckBox, QGroupBox, QGridLayout,
    QFrame, QMessageBox, QFileDialog, QMenu, QMenuBar, QSplitter, QSlider
)
from PyQt6.QtCore import Qt, QSize
from PyQt6.QtGui import QAction

from state import state
from models import EXPECTED_COLUMNS, PARAMETER_OPTIONS
from data_processor import (
    validate_tsv_format,
    extract_participants,
    extract_tasks_from_toi,
    normalize_by_participant_baseline,
)
from dialogs import GroupParticipantsDialog, GroupTasksDialog


class MainWindow(QMainWindow):
    """Main application window."""

    def __init__(self) -> None:
        super().__init__()
        self.setWindowTitle("Eye Tracking Analysis Tool")
        self.setMinimumSize(1200, 720)

        # Result domain checkboxes
        self.result_domain_vars: Dict[str, QCheckBox] = {}

        # Result group/task checkboxes
        self.result_group_checkboxes: Dict[str, QCheckBox] = {}
        self.result_task_checkboxes: Dict[str, QCheckBox] = {}

        # Deselect parameters
        self.deselect_param_checkboxes: Dict[str, QCheckBox] = {}

        # Weighting parameters
        self.weighting_enabled_cb: Optional[QCheckBox] = None
        self.weight_rows: list[tuple[QComboBox, QSlider, QLabel]] = []
        self.parameter_weights: Dict[str, float] = {}

        self._setup_ui()

    # --- Weighting slider mapping (QSlider is int-based) ---
    def _weight_slider_to_float(self, slider_val: int) -> float:
        # 2..10 -> 1.0..5.0 in 0.5 steps
        return float(slider_val) / 2.0

    def _weight_float_to_slider(self, weight: float) -> int:
        # clamp + round to nearest 0.5 step, then map to int
        w = max(1.0, min(5.0, float(weight)))
        return int(round(w * 2.0))

    def _format_weight(self, weight: float) -> str:
        return f"{weight:.2f}".rstrip("0").rstrip(".")

    def _setup_ui(self) -> None:
        central = QWidget()
        self.setCentralWidget(central)
        main_layout = QVBoxLayout(central)
        main_layout.setContentsMargins(10, 10, 10, 10)

        # Top bar
        topbar = QHBoxLayout()

        self.load_btn = QPushButton("Load TSV")
        self.load_btn.setFixedWidth(120)
        self.load_btn.clicked.connect(self._load_tsv)
        topbar.addWidget(self.load_btn)

        self.group_participants_btn = QPushButton("Group Participants")
        self.group_participants_btn.setFixedWidth(150)
        self.group_participants_btn.setEnabled(False)
        self.group_participants_btn.clicked.connect(self._open_group_participants)
        topbar.addWidget(self.group_participants_btn)

        # Button-Text wie gewünscht: "Name Tasks"
        self.group_tasks_btn = QPushButton("Name Tasks")
        self.group_tasks_btn.setFixedWidth(120)
        self.group_tasks_btn.setEnabled(False)
        self.group_tasks_btn.clicked.connect(self._open_group_tasks)
        topbar.addWidget(self.group_tasks_btn)

        self.file_path_edit = QLineEdit()
        self.file_path_edit.setReadOnly(True)
        self.file_path_edit.setPlaceholderText("No file loaded")
        topbar.addWidget(self.file_path_edit)

        main_layout.addLayout(topbar)

        # Listboxes section
        listbox_layout = QHBoxLayout()

        # Participants listbox
        left_widget = QWidget()
        left_layout = QVBoxLayout(left_widget)
        left_layout.setContentsMargins(0, 0, 0, 0)
        left_layout.addWidget(QLabel('Detected participants (from "Participant"):'))
        self.participants_list = QListWidget()
        self.participants_list.setMaximumHeight(120)
        left_layout.addWidget(self.participants_list)
        listbox_layout.addWidget(left_widget)

        # Tasks listbox
        right_widget = QWidget()
        right_layout = QVBoxLayout(right_widget)
        right_layout.setContentsMargins(0, 0, 0, 0)
        right_layout.addWidget(QLabel('Detected tasks (from "TOI" suffix):'))
        self.tasks_list = QListWidget()
        self.tasks_list.setMaximumHeight(120)
        right_layout.addWidget(self.tasks_list)
        listbox_layout.addWidget(right_widget)

        main_layout.addLayout(listbox_layout)

        # Separator
        separator = QFrame()
        separator.setFrameShape(QFrame.Shape.HLine)
        separator.setFrameShadow(QFrame.Shadow.Sunken)
        main_layout.addWidget(separator)

        # Results section
        results_label = QLabel("Results")
        results_label.setStyleSheet("font-weight: bold; font-size: 14px;")
        main_layout.addWidget(results_label)

        # Mode selection
        mode_layout = QHBoxLayout()
        mode_layout.addWidget(QLabel("Show results for:"))

        self.mode_combo = QComboBox()
        self.mode_combo.addItems([
            "Only group mean",
            "Each participant for selected groups",
            "Group mean and individual participants",
        ])
        self.mode_combo.setFixedWidth(350)
        mode_layout.addWidget(self.mode_combo)
        mode_layout.addStretch()
        main_layout.addLayout(mode_layout)

        # Groups and Tasks frames
        sel_layout = QHBoxLayout()

        self.groups_group = QGroupBox("Groups")
        self.groups_layout = QVBoxLayout(self.groups_group)
        sel_layout.addWidget(self.groups_group)

        self.tasks_group = QGroupBox("Tasks")
        self.tasks_layout = QGridLayout(self.tasks_group)
        sel_layout.addWidget(self.tasks_group)

        main_layout.addLayout(sel_layout)

        # Bottom row: Result domain and Deselect parameters
        bottom_layout = QHBoxLayout()

        # Result domain
        domain_group = QGroupBox("Result domain")
        domain_layout = QHBoxLayout(domain_group)

        for name in ["Rank", "Radar Chart", "Task Completion Time"]:
            cb = QCheckBox(name)
            cb.setChecked(True)
            self.result_domain_vars[name] = cb
            domain_layout.addWidget(cb)

        domain_layout.addStretch()
        bottom_layout.addWidget(domain_group)

        # Deselect parameters
        deselect_group = QGroupBox("Deselect Parameters")
        deselect_layout = QHBoxLayout(deselect_group)

        self.deselect_enabled_cb = QCheckBox("Enable Deselect")
        self.deselect_enabled_cb.stateChanged.connect(self._toggle_deselect_menu)
        deselect_layout.addWidget(self.deselect_enabled_cb)

        self.deselect_btn = QPushButton("None")
        self.deselect_btn.setEnabled(False)
        self.deselect_btn.clicked.connect(self._show_deselect_menu)
        deselect_layout.addWidget(self.deselect_btn)

        deselect_layout.addStretch()
        bottom_layout.addWidget(deselect_group)

        # Weighting parameters
        weighting_group = QGroupBox("Weighting Parameters")
        weighting_outer = QVBoxLayout(weighting_group)

        # Toggle row: checkbox + label rechts
        weighting_toggle_row = QHBoxLayout()
        self.weighting_enabled_cb = QCheckBox()
        self.weighting_enabled_cb.setChecked(False)
        self.weighting_enabled_cb.setEnabled(False)
        self.weighting_enabled_cb.stateChanged.connect(self._on_weighting_toggled)
        weighting_toggle_row.addWidget(self.weighting_enabled_cb)
        weighting_toggle_row.addWidget(QLabel("Enable custom parameter weights"))
        weighting_toggle_row.addStretch()
        weighting_outer.addLayout(weighting_toggle_row)

        # Container für dynamische Zeilen
        self.weighting_rows_container = QWidget()
        self.weighting_rows_layout = QVBoxLayout(self.weighting_rows_container)
        self.weighting_rows_layout.setContentsMargins(0, 0, 0, 0)
        self.weighting_rows_layout.setSpacing(6)
        weighting_outer.addWidget(self.weighting_rows_container)

        bottom_layout.addWidget(weighting_group)

        main_layout.addLayout(bottom_layout)

        # Action buttons
        action_layout = QHBoxLayout()

        self.show_results_btn = QPushButton("Show Results")
        self.show_results_btn.setFixedWidth(150)
        self.show_results_btn.setEnabled(False)
        self.show_results_btn.clicked.connect(self._on_show_results)
        action_layout.addWidget(self.show_results_btn)

        self.normalize_btn = QPushButton("Normalize")
        self.normalize_btn.setFixedWidth(150)
        self.normalize_btn.setEnabled(False)
        self.normalize_btn.clicked.connect(self._on_normalize)
        action_layout.addWidget(self.normalize_btn)

        self.calc_metric_averages_btn = QPushButton("Calculate metric averages")
        self.calc_metric_averages_btn.setFixedWidth(200)
        self.calc_metric_averages_btn.setEnabled(False)
        self.calc_metric_averages_btn.clicked.connect(self._on_calculate_metric_averages)
        action_layout.addWidget(self.calc_metric_averages_btn)

        self.exec_summary_btn = QPushButton("Print Executive Summary")
        self.exec_summary_btn.setFixedWidth(180)
        self.exec_summary_btn.setEnabled(False)
        self.exec_summary_btn.clicked.connect(self._on_print_exec_summary)
        action_layout.addWidget(self.exec_summary_btn)

        self.calc_participant_rank_btn = QPushButton("Calculate Participant Rank")
        self.calc_participant_rank_btn.setFixedWidth(220)
        self.calc_participant_rank_btn.setEnabled(False)
        self.calc_participant_rank_btn.clicked.connect(self._on_calculate_participant_rank)
        action_layout.addWidget(self.calc_participant_rank_btn)

        action_layout.addStretch()
        main_layout.addLayout(action_layout)

        main_layout.addStretch()

        # Initialize deselect menu
        self._build_deselect_menu()

        # Initialize weighting UI (disabled by default)
        self._reset_weighting_ui()

        # Initial population
        self._refresh_group_task_toggles()

    def _load_tsv(self) -> None:
        """Load and validate a TSV file."""
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            "Select TSV file",
            "",
            "TSV files (*.tsv);;All files (*.*)"
        )

        if not file_path:
            return

        # Validate format
        result = validate_tsv_format(file_path, EXPECTED_COLUMNS)
        if not result.ok:
            QMessageBox.critical(self, "Format error", result.message or "Unknown format error.")
            return

        # Load data
        try:
            state.df = pd.read_csv(file_path, sep="\t")
        except Exception as e:
            QMessageBox.critical(self, "Load error", str(e))
            return

        # Reset normalized data (must be recomputed for new file)
        state.normalized_df = None
        state.metric_averages_df = None
        state.participant_rank_df = None
        if hasattr(self, "calc_metric_averages_btn"):
            self.calc_metric_averages_btn.setEnabled(False)

        # Reset weighting UI/weights (parameters list may change later)
        if self.weighting_enabled_cb is not None:
            self.weighting_enabled_cb.setChecked(False)
        self._reset_weighting_ui()

        # Update UI with file path
        state.loaded_file_path = file_path
        self.file_path_edit.setText(file_path)

        # Reset caches
        state.participants_cache = []
        state.tasks_cache = []

        # Clear listboxes
        self.participants_list.clear()
        self.tasks_list.clear()

        # Disable action buttons during loading
        self.group_participants_btn.setEnabled(False)
        self.group_tasks_btn.setEnabled(False)
        self._set_main_action_buttons_enabled(False)

        # Extract participants
        try:
            state.participants_cache = extract_participants(state.df, column="Participant")
        except Exception as e:
            QMessageBox.critical(self, "Participant scan failed", str(e))
            state.df = None
            return

        # Extract tasks
        try:
            state.tasks_cache = extract_tasks_from_toi(state.df, column="TOI")
        except Exception as e:
            QMessageBox.critical(self, "Task scan failed", str(e))
            state.df = None
            return

        # Keep only labels for tasks that exist
        state.task_labels = {k: v for k, v in state.task_labels.items() if k in set(state.tasks_cache)}

        # Update listboxes
        for p in state.participants_cache:
            self.participants_list.addItem(p)

        self._refresh_tasks_listbox()

        # Enable group buttons
        self.group_participants_btn.setEnabled(bool(state.participants_cache))
        self.group_tasks_btn.setEnabled(bool(state.tasks_cache))

        if self.weighting_enabled_cb is not None:
            self.weighting_enabled_cb.setEnabled(True)

        self._set_main_action_buttons_enabled(True)
        self._refresh_group_task_toggles()

        QMessageBox.information(
            self,
            "Success",
            f"Loaded {len(state.df)} rows.\n"
            f"Found {len(state.participants_cache)} participants and {len(state.tasks_cache)} tasks."
        )

    def _refresh_tasks_listbox(self) -> None:
        """Refresh the tasks listbox with formatted task names."""
        self.tasks_list.clear()
        for t in state.tasks_cache:
            self.tasks_list.addItem(state.format_task(t))

    def _set_main_action_buttons_enabled(self, enabled: bool) -> None:
        """Enable or disable main action buttons."""
        self.show_results_btn.setEnabled(enabled)
        self.normalize_btn.setEnabled(enabled)
        self.calc_metric_averages_btn.setEnabled(enabled)
        self.exec_summary_btn.setEnabled(enabled)
        self.calc_participant_rank_btn.setEnabled(enabled)

    def _refresh_group_task_toggles(self) -> None:
        """Refresh the checkbox lists in the Results section."""
        # Clear existing group checkboxes
        while self.groups_layout.count():
            item = self.groups_layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()

        # Clear existing task checkboxes
        while self.tasks_layout.count():
            item = self.tasks_layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()

        self.result_group_checkboxes.clear()
        self.result_task_checkboxes.clear()

        # Groups toggles
        effective_groups = state.get_effective_participant_groups()
        effective_names = state.get_effective_group_names()

        if not effective_groups:
            label = QLabel("(Load a TSV file first)")
            label.setStyleSheet("color: #666;")
            self.groups_layout.addWidget(label)
        else:
            for gid in effective_groups.keys():
                name = effective_names.get(gid, gid)
                cb = QCheckBox(name)
                cb.setChecked(True)
                self.result_group_checkboxes[gid] = cb
                self.groups_layout.addWidget(cb)

        self.groups_layout.addStretch()

        # Tasks toggles
        if not state.tasks_cache:
            label = QLabel("(Load a TSV file first)")
            label.setStyleSheet("color: #666;")
            self.tasks_layout.addWidget(label, 0, 0)
            return

        cols = 8
        row = 0
        col = 0
        for tid in state.tasks_cache:
            cb = QCheckBox(state.format_task(tid))
            cb.setChecked(True)
            self.result_task_checkboxes[tid] = cb
            self.tasks_layout.addWidget(cb, row, col)
            col += 1
            if col >= cols:
                col = 0
                row += 1

    def _build_deselect_menu(self) -> None:
        """Build the deselect parameters menu."""
        self.deselect_menu = QMenu(self)
        self.deselect_param_checkboxes.clear()

        for name in PARAMETER_OPTIONS:
            action = QAction(name, self)
            action.setCheckable(True)
            action.triggered.connect(self._update_deselect_label)
            self.deselect_menu.addAction(action)
            self.deselect_param_checkboxes[name] = action

    def _reset_weighting_ui(self) -> None:
        """Clear all weighting rows and internal weights; keep toggle state."""
        self.parameter_weights.clear()
        self.weight_rows.clear()

        # Clear UI rows
        if hasattr(self, "weighting_rows_layout"):
            while self.weighting_rows_layout.count():
                item = self.weighting_rows_layout.takeAt(0)
                if item.widget():
                    item.widget().deleteLater()

        # If enabled and we have parameters, create first row
        if self.weighting_enabled_cb is not None and self.weighting_enabled_cb.isChecked():
            self._ensure_next_weight_row()

    def _on_weighting_toggled(self, state_val: int) -> None:
        enabled = state_val == Qt.CheckState.Checked.value
        if not enabled:
            self._reset_weighting_ui()
            return
        self._reset_weighting_ui()

    def _selected_weight_params(self) -> set[str]:
        selected: set[str] = set()
        for combo, _slider, _lbl in self.weight_rows:
            val = combo.currentData()
            if isinstance(val, str) and val:
                selected.add(val)
        return selected

    def _available_weight_params(self) -> list[str]:
        # PARAMETER_OPTIONS sind die “Parameter” im Tool
        selected = self._selected_weight_params()
        return [p for p in PARAMETER_OPTIONS if p not in selected]

    def _create_weight_row(self) -> None:
        available = self._available_weight_params()
        if not available:
            return

        row = QWidget()
        row_layout = QHBoxLayout(row)
        row_layout.setContentsMargins(0, 0, 0, 0)

        combo = QComboBox()
        combo.setFixedWidth(260)
        combo.addItem("Select parameter...", None)
        for p in available:
            combo.addItem(p, p)

        slider = QSlider(Qt.Orientation.Horizontal)
        # 1.0..5.0 in 0.5 steps => 2..10
        slider.setMinimum(2)
        slider.setMaximum(10)
        slider.setValue(self._weight_float_to_slider(1.0))
        slider.setSingleStep(1)
        slider.setPageStep(1)
        slider.setFixedWidth(220)
        slider.setEnabled(False)  # erst aktivieren, wenn Parameter gewählt

        value_lbl = QLabel(self._format_weight(1.0))
        value_lbl.setFixedWidth(44)
        value_lbl.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        value_lbl.setEnabled(False)

        # Signals
        combo.currentIndexChanged.connect(
            lambda _i, c=combo, s=slider, l=value_lbl: self._on_weight_row_changed(c, s, l)
        )
        slider.valueChanged.connect(
            lambda _v, c=combo, s=slider, l=value_lbl: self._on_weight_row_changed(c, s, l)
        )

        row_layout.addWidget(combo)
        row_layout.addWidget(slider)
        row_layout.addWidget(value_lbl)
        row_layout.addStretch()

        self.weighting_rows_layout.addWidget(row)
        self.weight_rows.append((combo, slider, value_lbl))

    def _on_weight_row_changed(self, combo: QComboBox, slider: QSlider, value_lbl: QLabel) -> None:
        # Wenn Toggle aus: ignorieren
        if self.weighting_enabled_cb is None or not self.weighting_enabled_cb.isChecked():
            return

        param = combo.currentData()
        if not isinstance(param, str) or not param:
            slider.setEnabled(False)
            value_lbl.setEnabled(False)
            return

        slider.setEnabled(True)
        value_lbl.setEnabled(True)

        weight = self._weight_slider_to_float(slider.value())
        value_lbl.setText(self._format_weight(weight))

        # Gewicht speichern (1.0..5.0 in 0.5er Schritten)
        self.parameter_weights[param] = float(weight)

        # Alle Combos neu aufbauen, damit keine Duplikate möglich sind
        self._rebuild_weight_combos(keep_current=True)

        # Wenn diese Zeile “aktiv” ist, nächste Zeile sicherstellen
        self._ensure_next_weight_row()

    def _rebuild_weight_combos(self, keep_current: bool = True) -> None:
        selected = self._selected_weight_params()

        for combo, slider, value_lbl in self.weight_rows:
            current = combo.currentData() if keep_current else None

            # Block signals während rebuild
            combo.blockSignals(True)
            combo.clear()
            combo.addItem("Select parameter...", None)

            # In dieser Combo darf current weiterhin drin sein
            allowed: list[str] = []
            for p in PARAMETER_OPTIONS:
                if p == current:
                    allowed.append(p)
                elif p not in selected:
                    allowed.append(p)

            for p in allowed:
                combo.addItem(p, p)

            # Restore selection
            if isinstance(current, str) and current:
                idx = combo.findData(current)
                combo.setCurrentIndex(idx if idx >= 0 else 0)
                slider.setEnabled(True)
                value_lbl.setEnabled(True)

                # Label/weight sync
                weight = self._weight_slider_to_float(slider.value())
                value_lbl.setText(self._format_weight(weight))
                self.parameter_weights[current] = float(weight)
            else:
                combo.setCurrentIndex(0)
                slider.setEnabled(False)
                value_lbl.setEnabled(False)

            combo.blockSignals(False)

    def _ensure_next_weight_row(self) -> None:
        if self.weighting_enabled_cb is None or not self.weighting_enabled_cb.isChecked():
            return

        available = self._available_weight_params()
        if not available:
            return

        if not self.weight_rows:
            self._create_weight_row()
            return

        last_combo, _last_slider, _last_lbl = self.weight_rows[-1]
        last_param = last_combo.currentData()
        if isinstance(last_param, str) and last_param:
            self._create_weight_row()

    def _toggle_deselect_menu(self, state_val: int) -> None:
        """Toggle the deselect parameters menu button."""
        self.deselect_btn.setEnabled(state_val == Qt.CheckState.Checked.value)

    def _show_deselect_menu(self) -> None:
        """Show the deselect parameters menu."""
        self.deselect_menu.exec(self.deselect_btn.mapToGlobal(self.deselect_btn.rect().bottomLeft()))

    def _update_deselect_label(self) -> None:
        """Update the deselect button label."""
        count = sum(1 for action in self.deselect_param_checkboxes.values() if action.isChecked())
        self.deselect_btn.setText("None" if count == 0 else f"{count} deselected")

    def _open_group_participants(self) -> None:
        """Open the group participants dialog."""
        if not state.participants_cache:
            QMessageBox.information(self, "No data", "Load a TSV file first.")
            return

        dialog = GroupParticipantsDialog(self)
        if dialog.exec() == GroupParticipantsDialog.DialogCode.Accepted:
            self._refresh_group_task_toggles()

    def _open_group_tasks(self) -> None:
        """Open the group tasks dialog."""
        if not state.tasks_cache:
            QMessageBox.information(self, "No data", "Load a TSV file first.")
            return

        dialog = GroupTasksDialog(self)
        if dialog.exec() == GroupTasksDialog.DialogCode.Accepted:
            self._refresh_tasks_listbox()
            self._refresh_group_task_toggles()

    def _on_normalize(self) -> None:
        """Normalize numeric data per participant by baseline task 0a (fallback 0b)."""
        if state.df is None:
            QMessageBox.information(self, "No data", "Load a TSV file first.")
            return

        try:
            state.normalized_df = normalize_by_participant_baseline(
                state.df,
                participant_col="Participant",
                task_col="TOI",
                baseline_primary="0a",
                baseline_fallback="0b",
            )
        except Exception as e:
            QMessageBox.critical(self, "Normalize failed", str(e))
            return

        if hasattr(self, "calc_metric_averages_btn"):
            self.calc_metric_averages_btn.setEnabled(True)

        QMessageBox.information(
            self,
            "Normalization complete",
            "Normalized data stored in state.normalized_df (baseline: 0a, fallback: 0b).",
        )

    def _on_calculate_metric_averages(self) -> None:
        """
        Berechnet Mittelwert und Standardabweichung je Participant und Task aus state.normalized_df.
        Zusätzlich: TCT (Mean/Std) je Participant und Task als zusätzliche Spalten (ohne Überschreiben).
        """
        if state.normalized_df is None:
            QMessageBox.information(
                self,
                "No normalized data",
                "Bitte zuerst 'Normalize' ausführen (state.normalized_df ist leer).",
            )
            return

        df = state.normalized_df

        # Spalten prüfen
        if "Participant" not in df.columns or "TOI" not in df.columns:
            QMessageBox.critical(self, "Missing columns", "normalized_df benötigt Spalten 'Participant' und 'TOI'.")
            return

        # Task-ID wie beim Task-Scan: Suffix nach letztem '_' (oder kompletter String)
        toi = df["TOI"].astype(str).str.strip()
        task_id = toi.str.rsplit("_", n=1).str[-1].str.strip()

        # Nur numerische Metriken aggregieren
        metric_cols = df.select_dtypes(include="number").columns.tolist()
        metric_cols = [c for c in metric_cols if c not in {"Participant", "TOI"}]

        if not metric_cols:
            QMessageBox.information(self, "No numeric metrics", "Keine numerischen Spalten zum Aggregieren gefunden.")
            return

        tmp = df.copy()
        tmp["_task_id"] = task_id

        # Aggregation: mean + std je Participant x Task (für alle numerischen Spalten)
        grouped = tmp.groupby(["Participant", "_task_id"], dropna=False)[metric_cols].agg(["mean", "std"])

        # Spaltennamen flach machen: "<metric>_mean", "<metric>_std"
        grouped.columns = [f"{metric}_{stat}" for (metric, stat) in grouped.columns.to_list()]

        # Index zurück in Spalten
        result = grouped.reset_index().rename(columns={"_task_id": "Task"})

        # --- Zusätzlich: TCT mean/std berechnen und als zusätzliche Spalten mergen ---
        tct_col: Optional[str] = None
        if "Duration" in df.columns:
            tct_col = "Duration"
        else:
            # heuristische Suche (case-insensitive)
            candidates = [
                "tct",
                "task completion time",
                "task_completion_time",
                "taskcompletiontime",
                "completion_time",
                "task time",
                "task_time",
            ]
            lower_map = {c.lower(): c for c in df.columns}
            for key in candidates:
                if key in lower_map:
                    tct_col = lower_map[key]
                    break

        tct_added = False
        tct_note = ""
        if tct_col is None:
            tct_note = "Keine TCT-Spalte gefunden (erwartet z.B. 'Duration')."
        elif not pd.api.types.is_numeric_dtype(df[tct_col]):
            tct_note = f"TCT-Spalte '{tct_col}' ist nicht numerisch."
        else:
            tct_tmp = tmp[["Participant", "_task_id", tct_col]].copy()
            tct_grouped = (
                tct_tmp.groupby(["Participant", "_task_id"], dropna=False)[tct_col]
                .agg(["mean", "std"])
                .reset_index()
                .rename(columns={"_task_id": "Task", "mean": "tct_mean", "std": "tct_std"})
            )

            # Nicht überschreiben: falls Spalten schon existieren, eindeutige Namen wählen
            if "tct_mean" in result.columns or "tct_std" in result.columns:
                # sehr defensiv: falls schon vorhanden, suffix anhängen
                tct_grouped = tct_grouped.rename(columns={"tct_mean": "tct_mean_tct", "tct_std": "tct_std_tct"})

            result = result.merge(tct_grouped, on=["Participant", "Task"], how="left")
            tct_added = True
            tct_note = f"TCT berechnet aus Spalte '{tct_col}'."

        state.metric_averages_df = result

        extra = f"\n{tct_note}" if tct_note else ""
        QMessageBox.information(
            self,
            "Metric averages calculated",
            f"Fertig. Ergebnis in state.metric_averages_df gespeichert.\n"
            f"Zeilen: {len(result)} | Spalten: {len(result.columns)}"
            f"{extra}",
        )

    def _on_calculate_participant_rank(self) -> None:
        """
        Berechnet pro Participant ein Task-Ranking (hardest -> easiest) basierend auf kognitiver Last.

        Vorgehen:
        1) Metrikwerte je Participant×Task berechnen (mean über Zeilen).
        2) Pro Participant je Metrik Tasks ranken (Rank 1 = hardest; ties = average).
        3) Gewichtete Rank-Summe über Metriken bilden und Tasks nach kleinster Summe sortieren.
        """
        if state.df is None:
            QMessageBox.information(self, "No data", "Load a TSV file first.")
            return

        df = state.normalized_df if state.normalized_df is not None else state.df

        if "Participant" not in df.columns or "TOI" not in df.columns:
            QMessageBox.critical(self, "Missing columns", "DataFrame benötigt Spalten 'Participant' und 'TOI'.")
            return

        # --- Auswahl: Tasks ---
        selected_tasks = [tid for tid, cb in self.result_task_checkboxes.items() if cb.isChecked()]
        if not selected_tasks:
            selected_tasks = state.tasks_cache.copy()

        # --- Auswahl: Participants (über Gruppen) ---
        selected_group_ids = [gid for gid, cb in self.result_group_checkboxes.items() if cb.isChecked()]
        effective_groups = state.get_effective_participant_groups()

        selected_participants: list[str] = []
        if selected_group_ids:
            s = set()
            for gid in selected_group_ids:
                for p in effective_groups.get(gid, []):
                    s.add(p)
            selected_participants = sorted(s)
        else:
            selected_participants = state.participants_cache.copy()

        if not selected_participants:
            QMessageBox.information(self, "No participants", "Keine Teilnehmer ausgewählt/gefunden.")
            return
        if not selected_tasks:
            QMessageBox.information(self, "No tasks", "Keine Tasks ausgewählt/gefunden.")
            return

        # --- Deselect Parameters ---
        deselected: set[str] = set()
        if self.deselect_enabled_cb.isChecked():
            deselected = {name for name, action in self.deselect_param_checkboxes.items() if action.isChecked()}

        metrics = [m for m in PARAMETER_OPTIONS if m not in deselected]
        if not metrics:
            QMessageBox.information(self, "No metrics", "Alle Metriken sind abgewählt (Deselect Parameters).")
            return

        # --- Weights ---
        weights: Dict[str, float] = {m: 1.0 for m in metrics}
        if self.weighting_enabled_cb is not None and self.weighting_enabled_cb.isChecked():
            for m in metrics:
                if m in self.parameter_weights:
                    weights[m] = float(self.parameter_weights[m])

        # --- Task-ID aus TOI ableiten (Suffix nach letztem '_') ---
        tmp = df.copy()
        tmp["_task_id"] = tmp["TOI"].astype(str).str.strip().str.rsplit("_", n=1).str[-1].str.strip()

        # Filter auf Auswahl
        tmp = tmp[tmp["Participant"].isin(selected_participants)]
        tmp = tmp[tmp["_task_id"].isin(selected_tasks)]

        if tmp.empty:
            QMessageBox.information(
                self,
                "No data after filtering",
                "Nach Filterung (Participants/Tasks) sind keine Datenzeilen übrig.",
            )
            return

        # --- Metrik -> Spaltenmapping + Richtung (True: höher = härter) ---
        # Referenz: TCT↑, SD(TCT)↑, Pupil Diameter↑, Saccade Velocity↓, Peak Saccade Velocity↓, Saccade Amplitude↓.
        def _find_col_case_insensitive(candidates: list[str]) -> Optional[str]:
            lower_map = {c.lower(): c for c in tmp.columns}
            for cand in candidates:
                if cand.lower() in lower_map:
                    return lower_map[cand.lower()]
            return None

        metric_specs: Dict[str, Dict[str, object]] = {}

        # TCT
        tct_col = "Duration" if "Duration" in tmp.columns else _find_col_case_insensitive(
            ["tct", "task_completion_time", "task completion time", "taskcompletiontime", "completion_time", "task_time"]
        )
        if tct_col is not None:
            metric_specs["Task Completion Time (TCT)"] = {"col": tct_col, "agg": "mean", "harder_high": True}
            metric_specs["Standard Deviation of TCT"] = {"col": tct_col, "agg": "std", "harder_high": True}

        # Pupil
        pupil_col = _find_col_case_insensitive(["Average_pupil_diameter", "pupil", "pupil_diameter", "average pupil diameter"])
        if pupil_col is not None:
            metric_specs["Pupil Diameter"] = {"col": pupil_col, "agg": "mean", "harder_high": True}

        # Saccade velocity
        sacc_vel_col = _find_col_case_insensitive(["Average_velocity", "saccade_velocity", "average velocity"])
        if sacc_vel_col is not None:
            metric_specs["Saccade Velocity"] = {"col": sacc_vel_col, "agg": "mean", "harder_high": False}

        # Peak saccade velocity
        peak_vel_col = _find_col_case_insensitive(["Peak_velocity", "peak_velocity", "peak saccade velocity"])
        if peak_vel_col is not None:
            metric_specs["Peak Saccade Velocity"] = {"col": peak_vel_col, "agg": "mean", "harder_high": False}

        # Saccade amplitude
        sacc_amp_col = _find_col_case_insensitive(["Saccade_amplitude", "saccade_amplitude", "saccade amplitude"])
        if sacc_amp_col is not None:
            metric_specs["Saccade Amplitude"] = {"col": sacc_amp_col, "agg": "mean", "harder_high": False}

        # Nur Metriken verwenden, die wir auch wirklich berechnen können
        usable_metrics: list[str] = []
        missing_metrics: list[str] = []
        for m in metrics:
            if m in metric_specs:
                col = metric_specs[m]["col"]
                if isinstance(col, str) and col in tmp.columns and pd.api.types.is_numeric_dtype(tmp[col]):
                    usable_metrics.append(m)
                else:
                    missing_metrics.append(m)
            else:
                missing_metrics.append(m)

        if not usable_metrics:
            QMessageBox.critical(
                self,
                "No usable metrics",
                "Keine der ausgewählten Metriken konnte auf numerische Spalten gemappt werden.\n"
                f"Ausgewählt: {metrics}",
            )
            return

        # --- Schritt 1: Werte je Participant×Task berechnen ---
        # Wir berechnen pro Metrik eine Spalte in einem Wide-DF: index=(Participant, Task), columns=metric
        base_index = tmp.groupby(["Participant", "_task_id"], dropna=False).size().reset_index()[["Participant", "_task_id"]]
        base_index = base_index.rename(columns={"_task_id": "Task"}).drop_duplicates()

        values_df = base_index.copy()

        for m in usable_metrics:
            spec = metric_specs[m]
            col = spec["col"]  # type: ignore[assignment]
            agg = spec["agg"]  # type: ignore[assignment]
            if not isinstance(col, str) or not isinstance(agg, str):
                continue

            g = tmp.groupby(["Participant", "_task_id"], dropna=False)[col]
            if agg == "mean":
                s = g.mean()
            elif agg == "std":
                s = g.std(ddof=1)
            else:
                raise ValueError(f"Unbekannte Aggregation: {agg}")

            s = s.reset_index().rename(columns={"_task_id": "Task", col: m})
            values_df = values_df.merge(s, on=["Participant", "Task"], how="left")

        # --- Schritt 2: Pro Participant je Metrik ranken (Rank 1 = hardest) ---
        ranks_df = values_df[["Participant", "Task"]].copy()

        for m in usable_metrics:
            harder_high = bool(metric_specs[m]["harder_high"])
            # pandas rank: ascending=True => kleinster Wert rank 1
            # Für "harder_high": wir wollen große Werte rank 1 => ascending=False
            ascending = not harder_high
            ranks_df[m] = (
                values_df.groupby("Participant", dropna=False)[m]
                .rank(method="average", ascending=ascending, na_option="keep")
            )

        # --- Schritt 3: Gewichtete Rank-Summe + finaler Task-Rank ---
        # NaN-Ranks: wenn eine Metrik für einen Task fehlt, wird sie aus der Summe ausgeschlossen
        # (d.h. wir summieren nur über vorhandene Ranks). Optional könnte man hier bestrafen;
        # aktuell ist es "neutral" (keine Addition).
        weighted_sum = pd.Series(0.0, index=ranks_df.index)
        weight_sum = pd.Series(0.0, index=ranks_df.index)

        for m in usable_metrics:
            w = float(weights.get(m, 1.0))
            r = ranks_df[m]
            mask = r.notna()
            weighted_sum = weighted_sum + (r.fillna(0.0) * w)
            weight_sum = weight_sum + (mask.astype(float) * w)

        # Wenn für eine Zeile gar keine Metrik vorhanden war -> NaN
        final_score = weighted_sum.where(weight_sum > 0, other=pd.NA)

        out = ranks_df[["Participant", "Task"]].copy()
        out["rank_sum"] = final_score

        # Finales Ranking: kleinste rank_sum = hardest (Rank 1)
        out["final_rank"] = out.groupby("Participant", dropna=False)["rank_sum"].rank(
            method="average", ascending=True, na_option="keep"
        )

        # Optional: auch die einzelnen Metrik-Ranks mitgeben
        for m in usable_metrics:
            out[f"{m}__rank"] = ranks_df[m]

        # Sortierung für Anzeige/Export
        out = out.sort_values(["Participant", "final_rank", "Task"], ascending=[True, True, True]).reset_index(drop=True)

        state.participant_rank_df = out

        note = ""
        if missing_metrics:
            note = "\nNicht gemappte/fehlende Metriken: " + ", ".join(missing_metrics)

        QMessageBox.information(
            self,
            "Participant rank calculated",
            "Fertig. Ergebnis in state.participant_rank_df gespeichert.\n"
            f"Participants: {out['Participant'].nunique()} | Tasks: {out['Task'].nunique()} | Rows: {len(out)}\n"
            f"Verwendete Metriken: {', '.join(usable_metrics)}"
            f"{note}",
        )

    def _on_show_results(self) -> None:
        """Handle Show Results button click."""
        if state.df is None:
            QMessageBox.information(self, "No data", "Load a TSV file first.")
            return

        selected_groups = [gid for gid, cb in self.result_group_checkboxes.items() if cb.isChecked()]
        selected_tasks = [tid for tid, cb in self.result_task_checkboxes.items() if cb.isChecked()]
        domains = [name for name, cb in self.result_domain_vars.items() if cb.isChecked()]
        mode = self.mode_combo.currentText()

        deselected = []
        if self.deselect_enabled_cb.isChecked():
            deselected = [name for name, action in self.deselect_param_checkboxes.items() if action.isChecked()]

        # Parameter weights (nur anzeigen, wenn aktiviert)
        weights_text = "(disabled)"
        if self.weighting_enabled_cb is not None and self.weighting_enabled_cb.isChecked():
            if not self.parameter_weights:
                weights_text = "(none)"
            else:
                parts = [f"{k} = {self._format_weight(v)}" for k, v in sorted(self.parameter_weights.items())]
                weights_text = ", ".join(parts)

        msg = (
            f"Mode: {mode}\n"
            f"Groups selected: {len(selected_groups)}\n"
            f"Tasks selected: {len(selected_tasks)}\n"
            f"Result domains: {', '.join(domains) if domains else '(none)'}\n"
            f"Deselected parameters: {', '.join(deselected) if deselected else '(none)'}\n"
            f"Parameter weights: {weights_text}"
        )
        QMessageBox.information(self, "Show Results (placeholder)", msg)

    def _on_print_exec_summary(self) -> None:
        """Handle Print Executive Summary button click."""
        if state.df is None:
            QMessageBox.information(self, "No data", "Load a TSV file first.")
            return
        QMessageBox.information(
            self,
            "Executive Summary (placeholder)",
            "This will generate the executive summary later.",
        )
```

state.py
```
"""
Global application state manager.
This class centralizes all state management to avoid global variable issues.
"""
from __future__ import annotations

from typing import Optional, List, Dict
import pandas as pd


class AppState:
    """Singleton class to manage application state."""
    
    _instance: Optional['AppState'] = None
    
    def __new__(cls) -> 'AppState':
        if cls._instance is None:
            cls._instance = super().__new__(cls)
            cls._instance._initialized = False
        return cls._instance
    
    def __init__(self) -> None:
        if self._initialized:
            return
        self._initialized = True
        self.reset()
    
    def reset(self) -> None:
        """Reset all state to initial values."""
        # Data
        self.df: Optional[pd.DataFrame] = None
        self.normalized_df: Optional[p.DataFrame] = None
        self.metric_averages_df: Optional[pd.DataFrame] = None
        self.participant_rank_df: Optional[pd.DataFrame] = None
        self.loaded_file_path: str = ""
        
        # Caches
        self.participants_cache: List[str] = []
        self.tasks_cache: List[str] = []
        
        # Grouping (participants)
        self.participant_groups: Dict[str, List[str]] = {}  # group_id -> participants
        self.group_names: Dict[str, str] = {}  # group_id -> group name
        
        # Grouping (tasks)
        self.task_groups: Dict[str, List[str]] = {}  # group_id -> task_ids
        self.task_group_names: Dict[str, str] = {}  # group_id -> group name
        
        # Task labels
        self.task_labels: Dict[str, str] = {}  # task_id -> human label
    
    def format_task(self, task_id: str) -> str:
        """Format task ID with optional label."""
        label = (self.task_labels.get(task_id, "") or "").strip()
        return f"{task_id} {label}".strip() if label else task_id
    
    def get_effective_participant_groups(self) -> Dict[str, List[str]]:
        """
        If no participant groups are defined, treat all participants as one implicit group.
        """
        if self.participant_groups:
            return self.participant_groups
        if self.participants_cache:
            return {"ALL": self.participants_cache.copy()}
        return {}
    
    def get_effective_group_names(self) -> Dict[str, str]:
        """Get group names, defaulting to 'All participants' if no groups defined."""
        if self.group_names:
            return self.group_names
        return {"ALL": "All participants"}


# Global instance
state = AppState()
```

> Tokens: 18k sent, 9.9k received. Cost: $0.17 message, $1.88 session.  
> Applied edit to main_window.py  
> Applied edit to state.py  
> Commit a437c26 feat: Teilnehmer-Task-Ranking berechnen und Gewichtung auf 1–5 setzen  
>  
> # Fix any errors below, if possible.  
>  
> ## Running: C:\Users\gusta\AppData\Roaming\uv\tools\aider-chat\Scripts\python.exe -m flake8 --select=E9,F821,F823,F831,F406,F407,F701,F702,F704,F706 --show-source --isolated state.py  
>  
> state.py:32:38: F821 undefined name 'p'  
> self.normalized_df: Optional[p.DataFrame] = None  
> ^  
>  
> ## See relevant line below marked with █.  
>  
> state.py:  
> ...⋮...  
> 11│class AppState:  
> 12│    """Singleton class to manage application state."""  
> 13│  
> ...⋮...  
> 28│    def reset(self) -> None:  
> 29│        """Reset all state to initial values."""  
> 30│        # Data  
> 31│        self.df: Optional[pd.DataFrame] = None  
> 32█        self.normalized_df: Optional[p.DataFrame] = None  
> 33│        self.metric_averages_df: Optional[pd.DataFrame] = None  
> 34│        self.participant_rank_df: Optional[pd.DataFrame] = None  
> 35│        self.loaded_file_path: str = ""  
> 36│  
> ...⋮...  
>  
> Attempt to fix lint errors? (Y)es/(N)o [Yes]: y  

Ja, hier ist eine Code-Änderung nötig: In `state.py` ist `p.DataFrame` ein Tippfehler/undefinierter Name. Das muss `pd.DataFrame` heißen (pandas ist als `pd` importiert). Dadurch verschwindet der `F821`.

state.py
```
"""
Global application state manager.
This class centralizes all state management to avoid global variable issues.
"""
from __future__ import annotations

from typing import Optional, List, Dict
import pandas as pd


class AppState:
    """Singleton class to manage application state."""
    
    _instance: Optional['AppState'] = None
    
    def __new__(cls) -> 'AppState':
        if cls._instance is None:
            cls._instance = super().__new__(cls)
            cls._instance._initialized = False
        return cls._instance
    
    def __init__(self) -> None:
        if self._initialized:
            return
        self._initialized = True
        self.reset()
    
    def reset(self) -> None:
        """Reset all state to initial values."""
        # Data
        self.df: Optional[pd.DataFrame] = None
        self.normalized_df: Optional[pd.DataFrame] = None
        self.metric_averages_df: Optional[pd.DataFrame] = None
        self.participant_rank_df: Optional[pd.DataFrame] = None
        self.loaded_file_path: str = ""
        
        # Caches
        self.participants_cache: List[str] = []
        self.tasks_cache: List[str] = []
        
        # Grouping (participants)
        self.participant_groups: Dict[str, List[str]] = {}  # group_id -> participants
        self.group_names: Dict[str, str] = {}  # group_id -> group name
        
        # Grouping (tasks)
        self.task_groups: Dict[str, List[str]] = {}  # group_id -> task_ids
        self.task_group_names: Dict[str, str] = {}  # group_id -> group name
        
        # Task labels
        self.task_labels: Dict[str, str] = {}  # task_id -> human label
    
    def format_task(self, task_id: str) -> str:
        """Format task ID with optional label."""
        label = (self.task_labels.get(task_id, "") or "").strip()
        return f"{task_id} {label}".strip() if label else task_id
    
    def get_effective_participant_groups(self) -> Dict[str, List[str]]:
        """
        If no participant groups are defined, treat all participants as one implicit group.
        """
        if self.participant_groups:
            return self.participant_groups
        if self.participants_cache:
            return {"ALL": self.participants_cache.copy()}
        return {}
    
    def get_effective_group_names(self) -> Dict[str, str]:
        """Get group names, defaulting to 'All participants' if no groups defined."""
        if self.group_names:
            return self.group_names
        return {"ALL": "All participants"}


# Global instance
state = AppState()
```

> Tokens: 30k sent, 642 received. Cost: $0.06 message, $1.94 session.  
> Applied edit to state.py  
> Commit 0403ce0 fix: Korrigiere Tippfehler in DataFrame-Typ für normalized_df  
> You can use /undo to undo and discard each aider commit.  

#### Was wird geändert?  
####   
####  1 Neuer State: In state.py wird participant_rank_df: Optional[pd.DataFrame]  
####    ergänzt und in reset() initialisiert.  
####  2 Neuer Button + Handler: In main_window.py wird neben exec_summary_btn ein  
####    Button Calculate Participant Rank hinzugefügt, der  
####    _on_calculate_participant_rank() aufruft.  
####  3 Berechnung Participant-Rank:  
####     • Datenbasis: bevorzugt state.normalized_df (falls vorhanden), sonst  
####       state.df.  
####     • Teilnehmer: aus ausgewählten Gruppen (oder alle, wenn keine Gruppe  
####       ausgewählt).  
####     • Tasks: aus ausgewählten Task-Toggles (oder alle, wenn keine Tasks  
####       ausgewählt).  
####     • Metriken: aus PARAMETER_OPTIONS, abzüglich der im Deselect Parameters  
####       Menü ausgewählten.  
####     • Pro Participant×Task wird je Metrik ein Wert berechnet (Mean über  
####       Zeilen).  
####     • Pro Participant wird je Metrik über Tasks gerankt (Rank 1 =  
####       „härteste“; Ties = average).  
####     • Aggregation: gewichtete Rank-Summe (Default 1.0; Custom Weights wenn  
####       aktiviert).  
####     • Final: Tasks pro Participant nach kleinster Rank-Summe sortiert  
####       (hardest→easiest).  
####  4 Weights-UI Anpassung: Die Slider-Mapping-Logik wird auf 1.0–5.0 in 0.5er  
####    Schritten umgestellt (int 2..10, Schritt 1). Default bleibt 1.0.  
####   
#### Wichtige Annahme: Die Metrik-Namen in PARAMETER_OPTIONS werden auf Spalten  
#### gemappt. Ich habe dafür eine robuste Heuristik eingebaut (z.B. TCT →  
#### Duration, SD(TCT) → Duration std, Pupil Diameter → Average_pupil_diameter,  
#### etc.). Wenn eure TSV andere Spaltennamen nutzt, sag mir bitte die exakten  
#### Spaltennamen, dann passe ich das Mapping an.  

Es sind **keine** Code-Änderungen nötig.

Die von dir aufgelisteten Punkte **1–4** sind in den aktuell im Chat enthaltenen Dateien bereits umgesetzt:

- `state.py` enthält `self.participant_rank_df: Optional[pd.DataFrame] = None` in `reset()`.
- `main_window.py` enthält den Button **Calculate Participant Rank** neben `exec_summary_btn` und den Handler `_on_calculate_participant_rank()`.
- `_on_calculate_participant_rank()` nutzt `state.normalized_df` (Fallback `state.df`), filtert Participants/Tasks über die ausgewählten Toggles (Fallback alle), berücksichtigt **Deselect Parameters**, berechnet pro Participant×Task Metrikwerte, rankt pro Participant je Metrik (Rank 1 = hardest, ties=average) und aggregiert per gewichteter Rank-Summe.
- Die Weighting-Slider sind auf **1.0–5.0 in 0.5er Schritten** umgestellt (Mapping `2..10 -> 1.0..5.0`), Default 1.0.

Da keine Änderungen erforderlich sind, gebe ich **keine** File-Listings aus.

> Tokens: 32k sent, 272 received. Cost: $0.06 message, $2.00 session.  

#### When Show Results is pressed and Result domain → Rank is enabled, display the participant-rank results computed by Calculate Participant Rank using the current UI selections (Groups/Tasks/Mode/Deselect/Weights). If state.participant_rank_df is missing or stale, show a clear message to run Calculate Participant Rank first. The output should be shown in a new scrollable popup window titled “Rank Results” and must respect:  
####   
#### Participants scope: selected Groups toggles; if none selected → all participants.  
####   
#### Tasks scope: selected Task toggles; if none selected → all tasks.  
####   
#### Mode dropdown:  
####   
#### Only group mean: show one aggregated ranking per selected group (or “All participants” fallback) by averaging participant rank-sum scores per task, then sorting tasks hardest→easiest.  
####   
#### Each participant for selected groups: show participant tables for participants inside selected groups (or all participants fallback).  
####   
#### Group mean and individual participants: show group-mean section first, then individual participant sections.  
####   
#### Deselected parameters + custom weights: already applied in the computed ranks; just report which parameters were excluded and which weights were used as a small header.  
####   
#### The popup content format must be concise and readable:  
####   
#### Header (single paragraph): dataset used (normalized or raw), #participants, #tasks, selected mode, excluded metrics list, custom weights list.  
####   
#### Tables:  
####   
#### For each participant (or each group mean), show a table with columns:  
#### Rank, Task, Score (rank-sum)  
#### sorted by Rank ascending.  
####   
#### No plots for this domain; only tables.  
####   
#### If a selected group has zero members or a selected task has no data for a participant, skip gracefully and note it in a small “Warnings” section at the bottom (e.g., “P3 had no rows for task 7”).  

Ja, dafür sind Code-Änderungen nötig (nur in `main_window.py`).

### Benötigte Änderungen
1. **Stale-/Missing-Check**: Beim Klick auf **Show Results** und aktivem Result domain **Rank** prüfen wir, ob `state.participant_rank_df` existiert und ob es zu den *aktuellen* UI-Selections passt (Groups/Tasks/Deselect/Weights + Datenbasis normalized/raw). Wenn nicht: klare Meldung „Bitte zuerst Calculate Participant Rank ausführen“.
2. **Popup “Rank Results”**: Ein neues scrollbares Fenster (QDialog) mit einem `QTextEdit` (read-only) zeigt:
   - **Header** (ein Absatz): Datenbasis (normalized/raw), #Participants, #Tasks, Mode, excluded metrics, weights.
   - **Tabellen**: pro Participant oder pro Group-Mean (je nach Mode) eine kompakte Tabelle `Rank | Task | Score`.
   - **Warnings**: am Ende eine kleine Liste (z.B. fehlende Tasks pro Participant, leere Gruppen).
3. **Mode-Logik**:
   - *Only group mean*: pro ausgewählter Gruppe (oder “All participants”) Task-Scores = Mittelwert der `rank_sum` über Participants, dann Ranking.
   - *Each participant...*: pro Participant Tabelle.
   - *Group mean and individual...*: erst Group-Mean, dann Participants.
4. **Selections respektieren**:
   - Participants scope: ausgewählte Gruppen; wenn keine ausgewählt → alle.
   - Tasks scope: ausgewählte Tasks; wenn keine ausgewählt → alle.
5. **Keine Plots**: nur Tabellen.

main_window.py
```
"""
Main window for the Eye Tracking Tool using PyQt6.
"""
from __future__ import annotations

from typing import Dict, Optional
import pandas as pd

from PyQt6.QtWidgets import (
    QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, QLabel, QPushButton,
    QListWidget, QLineEdit, QComboBox, QCheckBox, QGroupBox, QGridLayout,
    QFrame, QMessageBox, QFileDialog, QMenu, QMenuBar, QSplitter, QSlider,
    QDialog, QTextEdit
)
from PyQt6.QtCore import Qt, QSize
from PyQt6.QtGui import QAction

from state import state
from models import EXPECTED_COLUMNS, PARAMETER_OPTIONS
from data_processor import (
    validate_tsv_format,
    extract_participants,
    extract_tasks_from_toi,
    normalize_by_participant_baseline,
)
from dialogs import GroupParticipantsDialog, GroupTasksDialog


class MainWindow(QMainWindow):
    """Main application window."""

    def __init__(self) -> None:
        super().__init__()
        self.setWindowTitle("Eye Tracking Analysis Tool")
        self.setMinimumSize(1200, 720)

        # Result domain checkboxes
        self.result_domain_vars: Dict[str, QCheckBox] = {}

        # Result group/task checkboxes
        self.result_group_checkboxes: Dict[str, QCheckBox] = {}
        self.result_task_checkboxes: Dict[str, QCheckBox] = {}

        # Deselect parameters
        self.deselect_param_checkboxes: Dict[str, QCheckBox] = {}

        # Weighting parameters
        self.weighting_enabled_cb: Optional[QCheckBox] = None
        self.weight_rows: list[tuple[QComboBox, QSlider, QLabel]] = []
        self.parameter_weights: Dict[str, float] = {}

        # Snapshot of the last rank computation inputs (to detect stale results)
        self._participant_rank_signature: Optional[dict] = None

        self._setup_ui()

    # --- Weighting slider mapping (QSlider is int-based) ---
    def _weight_slider_to_float(self, slider_val: int) -> float:
        # 2..10 -> 1.0..5.0 in 0.5 steps
        return float(slider_val) / 2.0

    def _weight_float_to_slider(self, weight: float) -> int:
        # clamp + round to nearest 0.5 step, then map to int
        w = max(1.0, min(5.0, float(weight)))
        return int(round(w * 2.0))

    def _format_weight(self, weight: float) -> str:
        return f"{weight:.2f}".rstrip("0").rstrip(".")

    def _setup_ui(self) -> None:
        central = QWidget()
        self.setCentralWidget(central)
        main_layout = QVBoxLayout(central)
        main_layout.setContentsMargins(10, 10, 10, 10)

        # Top bar
        topbar = QHBoxLayout()

        self.load_btn = QPushButton("Load TSV")
        self.load_btn.setFixedWidth(120)
        self.load_btn.clicked.connect(self._load_tsv)
        topbar.addWidget(self.load_btn)

        self.group_participants_btn = QPushButton("Group Participants")
        self.group_participants_btn.setFixedWidth(150)
        self.group_participants_btn.setEnabled(False)
        self.group_participants_btn.clicked.connect(self._open_group_participants)
        topbar.addWidget(self.group_participants_btn)

        # Button-Text wie gewünscht: "Name Tasks"
        self.group_tasks_btn = QPushButton("Name Tasks")
        self.group_tasks_btn.setFixedWidth(120)
        self.group_tasks_btn.setEnabled(False)
        self.group_tasks_btn.clicked.connect(self._open_group_tasks)
        topbar.addWidget(self.group_tasks_btn)

        self.file_path_edit = QLineEdit()
        self.file_path_edit.setReadOnly(True)
        self.file_path_edit.setPlaceholderText("No file loaded")
        topbar.addWidget(self.file_path_edit)

        main_layout.addLayout(topbar)

        # Listboxes section
        listbox_layout = QHBoxLayout()

        # Participants listbox
        left_widget = QWidget()
        left_layout = QVBoxLayout(left_widget)
        left_layout.setContentsMargins(0, 0, 0, 0)
        left_layout.addWidget(QLabel('Detected participants (from "Participant"):'))
        self.participants_list = QListWidget()
        self.participants_list.setMaximumHeight(120)
        left_layout.addWidget(self.participants_list)
        listbox_layout.addWidget(left_widget)

        # Tasks listbox
        right_widget = QWidget()
        right_layout = QVBoxLayout(right_widget)
        right_layout.setContentsMargins(0, 0, 0, 0)
        right_layout.addWidget(QLabel('Detected tasks (from "TOI" suffix):'))
        self.tasks_list = QListWidget()
        self.tasks_list.setMaximumHeight(120)
        right_layout.addWidget(self.tasks_list)
        listbox_layout.addWidget(right_widget)

        main_layout.addLayout(listbox_layout)

        # Separator
        separator = QFrame()
        separator.setFrameShape(QFrame.Shape.HLine)
        separator.setFrameShadow(QFrame.Shadow.Sunken)
        main_layout.addWidget(separator)

        # Results section
        results_label = QLabel("Results")
        results_label.setStyleSheet("font-weight: bold; font-size: 14px;")
        main_layout.addWidget(results_label)

        # Mode selection
        mode_layout = QHBoxLayout()
        mode_layout.addWidget(QLabel("Show results for:"))

        self.mode_combo = QComboBox()
        self.mode_combo.addItems([
            "Only group mean",
            "Each participant for selected groups",
            "Group mean and individual participants",
        ])
        self.mode_combo.setFixedWidth(350)
        mode_layout.addWidget(self.mode_combo)
        mode_layout.addStretch()
        main_layout.addLayout(mode_layout)

        # Groups and Tasks frames
        sel_layout = QHBoxLayout()

        self.groups_group = QGroupBox("Groups")
        self.groups_layout = QVBoxLayout(self.groups_group)
        sel_layout.addWidget(self.groups_group)

        self.tasks_group = QGroupBox("Tasks")
        self.tasks_layout = QGridLayout(self.tasks_group)
        sel_layout.addWidget(self.tasks_group)

        main_layout.addLayout(sel_layout)

        # Bottom row: Result domain and Deselect parameters
        bottom_layout = QHBoxLayout()

        # Result domain
        domain_group = QGroupBox("Result domain")
        domain_layout = QHBoxLayout(domain_group)

        for name in ["Rank", "Radar Chart", "Task Completion Time"]:
            cb = QCheckBox(name)
            cb.setChecked(True)
            self.result_domain_vars[name] = cb
            domain_layout.addWidget(cb)

        domain_layout.addStretch()
        bottom_layout.addWidget(domain_group)

        # Deselect parameters
        deselect_group = QGroupBox("Deselect Parameters")
        deselect_layout = QHBoxLayout(deselect_group)

        self.deselect_enabled_cb = QCheckBox("Enable Deselect")
        self.deselect_enabled_cb.stateChanged.connect(self._toggle_deselect_menu)
        deselect_layout.addWidget(self.deselect_enabled_cb)

        self.deselect_btn = QPushButton("None")
        self.deselect_btn.setEnabled(False)
        self.deselect_btn.clicked.connect(self._show_deselect_menu)
        deselect_layout.addWidget(self.deselect_btn)

        deselect_layout.addStretch()
        bottom_layout.addWidget(deselect_group)

        # Weighting parameters
        weighting_group = QGroupBox("Weighting Parameters")
        weighting_outer = QVBoxLayout(weighting_group)

        # Toggle row: checkbox + label rechts
        weighting_toggle_row = QHBoxLayout()
        self.weighting_enabled_cb = QCheckBox()
        self.weighting_enabled_cb.setChecked(False)
        self.weighting_enabled_cb.setEnabled(False)
        self.weighting_enabled_cb.stateChanged.connect(self._on_weighting_toggled)
        weighting_toggle_row.addWidget(self.weighting_enabled_cb)
        weighting_toggle_row.addWidget(QLabel("Enable custom parameter weights"))
        weighting_toggle_row.addStretch()
        weighting_outer.addLayout(weighting_toggle_row)

        # Container für dynamische Zeilen
        self.weighting_rows_container = QWidget()
        self.weighting_rows_layout = QVBoxLayout(self.weighting_rows_container)
        self.weighting_rows_layout.setContentsMargins(0, 0, 0, 0)
        self.weighting_rows_layout.setSpacing(6)
        weighting_outer.addWidget(self.weighting_rows_container)

        bottom_layout.addWidget(weighting_group)

        main_layout.addLayout(bottom_layout)

        # Action buttons
        action_layout = QHBoxLayout()

        self.show_results_btn = QPushButton("Show Results")
        self.show_results_btn.setFixedWidth(150)
        self.show_results_btn.setEnabled(False)
        self.show_results_btn.clicked.connect(self._on_show_results)
        action_layout.addWidget(self.show_results_btn)

        self.normalize_btn = QPushButton("Normalize")
        self.normalize_btn.setFixedWidth(150)
        self.normalize_btn.setEnabled(False)
        self.normalize_btn.clicked.connect(self._on_normalize)
        action_layout.addWidget(self.normalize_btn)

        self.calc_metric_averages_btn = QPushButton("Calculate metric averages")
        self.calc_metric_averages_btn.setFixedWidth(200)
        self.calc_metric_averages_btn.setEnabled(False)
        self.calc_metric_averages_btn.clicked.connect(self._on_calculate_metric_averages)
        action_layout.addWidget(self.calc_metric_averages_btn)

        self.exec_summary_btn = QPushButton("Print Executive Summary")
        self.exec_summary_btn.setFixedWidth(180)
        self.exec_summary_btn.setEnabled(False)
        self.exec_summary_btn.clicked.connect(self._on_print_exec_summary)
        action_layout.addWidget(self.exec_summary_btn)

        self.calc_participant_rank_btn = QPushButton("Calculate Participant Rank")
        self.calc_participant_rank_btn.setFixedWidth(220)
        self.calc_participant_rank_btn.setEnabled(False)
        self.calc_participant_rank_btn.clicked.connect(self._on_calculate_participant_rank)
        action_layout.addWidget(self.calc_participant_rank_btn)

        action_layout.addStretch()
        main_layout.addLayout(action_layout)

        main_layout.addStretch()

        # Initialize deselect menu
        self._build_deselect_menu()

        # Initialize weighting UI (disabled by default)
        self._reset_weighting_ui()

        # Initial population
        self._refresh_group_task_toggles()

    def _load_tsv(self) -> None:
        """Load and validate a TSV file."""
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            "Select TSV file",
            "",
            "TSV files (*.tsv);;All files (*.*)"
        )

        if not file_path:
            return

        # Validate format
        result = validate_tsv_format(file_path, EXPECTED_COLUMNS)
        if not result.ok:
            QMessageBox.critical(self, "Format error", result.message or "Unknown format error.")
            return

        # Load data
        try:
            state.df = pd.read_csv(file_path, sep="\t")
        except Exception as e:
            QMessageBox.critical(self, "Load error", str(e))
            return

        # Reset normalized data (must be recomputed for new file)
        state.normalized_df = None
        state.metric_averages_df = None
        state.participant_rank_df = None
        self._participant_rank_signature = None
        if hasattr(self, "calc_metric_averages_btn"):
            self.calc_metric_averages_btn.setEnabled(False)

        # Reset weighting UI/weights (parameters list may change later)
        if self.weighting_enabled_cb is not None:
            self.weighting_enabled_cb.setChecked(False)
        self._reset_weighting_ui()

        # Update UI with file path
        state.loaded_file_path = file_path
        self.file_path_edit.setText(file_path)

        # Reset caches
        state.participants_cache = []
        state.tasks_cache = []

        # Clear listboxes
        self.participants_list.clear()
        self.tasks_list.clear()

        # Disable action buttons during loading
        self.group_participants_btn.setEnabled(False)
        self.group_tasks_btn.setEnabled(False)
        self._set_main_action_buttons_enabled(False)

        # Extract participants
        try:
            state.participants_cache = extract_participants(state.df, column="Participant")
        except Exception as e:
            QMessageBox.critical(self, "Participant scan failed", str(e))
            state.df = None
            return

        # Extract tasks
        try:
            state.tasks_cache = extract_tasks_from_toi(state.df, column="TOI")
        except Exception as e:
            QMessageBox.critical(self, "Task scan failed", str(e))
            state.df = None
            return

        # Keep only labels for tasks that exist
        state.task_labels = {k: v for k, v in state.task_labels.items() if k in set(state.tasks_cache)}

        # Update listboxes
        for p in state.participants_cache:
            self.participants_list.addItem(p)

        self._refresh_tasks_listbox()

        # Enable group buttons
        self.group_participants_btn.setEnabled(bool(state.participants_cache))
        self.group_tasks_btn.setEnabled(bool(state.tasks_cache))

        if self.weighting_enabled_cb is not None:
            self.weighting_enabled_cb.setEnabled(True)

        self._set_main_action_buttons_enabled(True)
        self._refresh_group_task_toggles()

        QMessageBox.information(
            self,
            "Success",
            f"Loaded {len(state.df)} rows.\n"
            f"Found {len(state.participants_cache)} participants and {len(state.tasks_cache)} tasks."
        )

    def _refresh_tasks_listbox(self) -> None:
        """Refresh the tasks listbox with formatted task names."""
        self.tasks_list.clear()
        for t in state.tasks_cache:
            self.tasks_list.addItem(state.format_task(t))

    def _set_main_action_buttons_enabled(self, enabled: bool) -> None:
        """Enable or disable main action buttons."""
        self.show_results_btn.setEnabled(enabled)
        self.normalize_btn.setEnabled(enabled)
        self.calc_metric_averages_btn.setEnabled(enabled)
        self.exec_summary_btn.setEnabled(enabled)
        self.calc_participant_rank_btn.setEnabled(enabled)

    def _refresh_group_task_toggles(self) -> None:
        """Refresh the checkbox lists in the Results section."""
        # Clear existing group checkboxes
        while self.groups_layout.count():
            item = self.groups_layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()

        # Clear existing task checkboxes
        while self.tasks_layout.count():
            item = self.tasks_layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()

        self.result_group_checkboxes.clear()
        self.result_task_checkboxes.clear()

        # Groups toggles
        effective_groups = state.get_effective_participant_groups()
        effective_names = state.get_effective_group_names()

        if not effective_groups:
            label = QLabel("(Load a TSV file first)")
            label.setStyleSheet("color: #666;")
            self.groups_layout.addWidget(label)
        else:
            for gid in effective_groups.keys():
                name = effective_names.get(gid, gid)
                cb = QCheckBox(name)
                cb.setChecked(True)
                self.result_group_checkboxes[gid] = cb
                self.groups_layout.addWidget(cb)

        self.groups_layout.addStretch()

        # Tasks toggles
        if not state.tasks_cache:
            label = QLabel("(Load a TSV file first)")
            label.setStyleSheet("color: #666;")
            self.tasks_layout.addWidget(label, 0, 0)
            return

        cols = 8
        row = 0
        col = 0
        for tid in state.tasks_cache:
            cb = QCheckBox(state.format_task(tid))
            cb.setChecked(True)
            self.result_task_checkboxes[tid] = cb
            self.tasks_layout.addWidget(cb, row, col)
            col += 1
            if col >= cols:
                col = 0
                row += 1

    def _build_deselect_menu(self) -> None:
        """Build the deselect parameters menu."""
        self.deselect_menu = QMenu(self)
        self.deselect_param_checkboxes.clear()

        for name in PARAMETER_OPTIONS:
            action = QAction(name, self)
            action.setCheckable(True)
            action.triggered.connect(self._update_deselect_label)
            self.deselect_menu.addAction(action)
            self.deselect_param_checkboxes[name] = action

    def _reset_weighting_ui(self) -> None:
        """Clear all weighting rows and internal weights; keep toggle state."""
        self.parameter_weights.clear()
        self.weight_rows.clear()

        # Clear UI rows
        if hasattr(self, "weighting_rows_layout"):
            while self.weighting_rows_layout.count():
                item = self.weighting_rows_layout.takeAt(0)
                if item.widget():
                    item.widget().deleteLater()

        # If enabled and we have parameters, create first row
        if self.weighting_enabled_cb is not None and self.weighting_enabled_cb.isChecked():
            self._ensure_next_weight_row()

    def _on_weighting_toggled(self, state_val: int) -> None:
        enabled = state_val == Qt.CheckState.Checked.value
        if not enabled:
            self._reset_weighting_ui()
            return
        self._reset_weighting_ui()

    def _selected_weight_params(self) -> set[str]:
        selected: set[str] = set()
        for combo, _slider, _lbl in self.weight_rows:
            val = combo.currentData()
            if isinstance(val, str) and val:
                selected.add(val)
        return selected

    def _available_weight_params(self) -> list[str]:
        # PARAMETER_OPTIONS sind die “Parameter” im Tool
        selected = self._selected_weight_params()
        return [p for p in PARAMETER_OPTIONS if p not in selected]

    def _create_weight_row(self) -> None:
        available = self._available_weight_params()
        if not available:
            return

        row = QWidget()
        row_layout = QHBoxLayout(row)
        row_layout.setContentsMargins(0, 0, 0, 0)

        combo = QComboBox()
        combo.setFixedWidth(260)
        combo.addItem("Select parameter...", None)
        for p in available:
            combo.addItem(p, p)

        slider = QSlider(Qt.Orientation.Horizontal)
        # 1.0..5.0 in 0.5 steps => 2..10
        slider.setMinimum(2)
        slider.setMaximum(10)
        slider.setValue(self._weight_float_to_slider(1.0))
        slider.setSingleStep(1)
        slider.setPageStep(1)
        slider.setFixedWidth(220)
        slider.setEnabled(False)  # erst aktivieren, wenn Parameter gewählt

        value_lbl = QLabel(self._format_weight(1.0))
        value_lbl.setFixedWidth(44)
        value_lbl.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        value_lbl.setEnabled(False)

        # Signals
        combo.currentIndexChanged.connect(
            lambda _i, c=combo, s=slider, l=value_lbl: self._on_weight_row_changed(c, s, l)
        )
        slider.valueChanged.connect(
            lambda _v, c=combo, s=slider, l=value_lbl: self._on_weight_row_changed(c, s, l)
        )

        row_layout.addWidget(combo)
        row_layout.addWidget(slider)
        row_layout.addWidget(value_lbl)
        row_layout.addStretch()

        self.weighting_rows_layout.addWidget(row)
        self.weight_rows.append((combo, slider, value_lbl))

    def _on_weight_row_changed(self, combo: QComboBox, slider: QSlider, value_lbl: QLabel) -> None:
        # Wenn Toggle aus: ignorieren
        if self.weighting_enabled_cb is None or not self.weighting_enabled_cb.isChecked():
            return

        param = combo.currentData()
        if not isinstance(param, str) or not param:
            slider.setEnabled(False)
            value_lbl.setEnabled(False)
            return

        slider.setEnabled(True)
        value_lbl.setEnabled(True)

        weight = self._weight_slider_to_float(slider.value())
        value_lbl.setText(self._format_weight(weight))

        # Gewicht speichern (1.0..5.0 in 0.5er Schritten)
        self.parameter_weights[param] = float(weight)

        # Alle Combos neu aufbauen, damit keine Duplikate möglich sind
        self._rebuild_weight_combos(keep_current=True)

        # Wenn diese Zeile “aktiv” ist, nächste Zeile sicherstellen
        self._ensure_next_weight_row()

    def _rebuild_weight_combos(self, keep_current: bool = True) -> None:
        selected = self._selected_weight_params()

        for combo, slider, value_lbl in self.weight_rows:
            current = combo.currentData() if keep_current else None

            # Block signals während rebuild
            combo.blockSignals(True)
            combo.clear()
            combo.addItem("Select parameter...", None)

            # In dieser Combo darf current weiterhin drin sein
            allowed: list[str] = []
            for p in PARAMETER_OPTIONS:
                if p == current:
                    allowed.append(p)
                elif p not in selected:
                    allowed.append(p)

            for p in allowed:
                combo.addItem(p, p)

            # Restore selection
            if isinstance(current, str) and current:
                idx = combo.findData(current)
                combo.setCurrentIndex(idx if idx >= 0 else 0)
                slider.setEnabled(True)
                value_lbl.setEnabled(True)

                # Label/weight sync
                weight = self._weight_slider_to_float(slider.value())
                value_lbl.setText(self._format_weight(weight))
                self.parameter_weights[current] = float(weight)
            else:
                combo.setCurrentIndex(0)
                slider.setEnabled(False)
                value_lbl.setEnabled(False)

            combo.blockSignals(False)

    def _ensure_next_weight_row(self) -> None:
        if self.weighting_enabled_cb is None or not self.weighting_enabled_cb.isChecked():
            return

        available = self._available_weight_params()
        if not available:
            return

        if not self.weight_rows:
            self._create_weight_row()
            return

        last_combo, _last_slider, _last_lbl = self.weight_rows[-1]
        last_param = last_combo.currentData()
        if isinstance(last_param, str) and last_param:
            self._create_weight_row()

    def _toggle_deselect_menu(self, state_val: int) -> None:
        """Toggle the deselect parameters menu button."""
        self.deselect_btn.setEnabled(state_val == Qt.CheckState.Checked.value)

    def _show_deselect_menu(self) -> None:
        """Show the deselect parameters menu."""
        self.deselect_menu.exec(self.deselect_btn.mapToGlobal(self.deselect_btn.rect().bottomLeft()))

    def _update_deselect_label(self) -> None:
        """Update the deselect button label."""
        count = sum(1 for action in self.deselect_param_checkboxes.values() if action.isChecked())
        self.deselect_btn.setText("None" if count == 0 else f"{count} deselected")

    def _open_group_participants(self) -> None:
        """Open the group participants dialog."""
        if not state.participants_cache:
            QMessageBox.information(self, "No data", "Load a TSV file first.")
            return

        dialog = GroupParticipantsDialog(self)
        if dialog.exec() == GroupParticipantsDialog.DialogCode.Accepted:
            self._refresh_group_task_toggles()

    def _open_group_tasks(self) -> None:
        """Open the group tasks dialog."""
        if not state.tasks_cache:
            QMessageBox.information(self, "No data", "Load a TSV file first.")
            return

        dialog = GroupTasksDialog(self)
        if dialog.exec() == GroupTasksDialog.DialogCode.Accepted:
            self._refresh_tasks_listbox()
            self._refresh_group_task_toggles()

    def _on_normalize(self) -> None:
        """Normalize numeric data per participant by baseline task 0a (fallback 0b)."""
        if state.df is None:
            QMessageBox.information(self, "No data", "Load a TSV file first.")
            return

        try:
            state.normalized_df = normalize_by_participant_baseline(
                state.df,
                participant_col="Participant",
                task_col="TOI",
                baseline_primary="0a",
                baseline_fallback="0b",
            )
        except Exception as e:
            QMessageBox.critical(self, "Normalize failed", str(e))
            return

        # Normalisierung macht vorhandene Rank-Ergebnisse potentiell stale
        self._participant_rank_signature = None
        state.participant_rank_df = None

        if hasattr(self, "calc_metric_averages_btn"):
            self.calc_metric_averages_btn.setEnabled(True)

        QMessageBox.information(
            self,
            "Normalization complete",
            "Normalized data stored in state.normalized_df (baseline: 0a, fallback: 0b).",
        )

    def _on_calculate_metric_averages(self) -> None:
        """
        Berechnet Mittelwert und Standardabweichung je Participant und Task aus state.normalized_df.
        Zusätzlich: TCT (Mean/Std) je Participant und Task als zusätzliche Spalten (ohne Überschreiben).
        """
        if state.normalized_df is None:
            QMessageBox.information(
                self,
                "No normalized data",
                "Bitte zuerst 'Normalize' ausführen (state.normalized_df ist leer).",
            )
            return

        df = state.normalized_df

        # Spalten prüfen
        if "Participant" not in df.columns or "TOI" not in df.columns:
            QMessageBox.critical(self, "Missing columns", "normalized_df benötigt Spalten 'Participant' und 'TOI'.")
            return

        # Task-ID wie beim Task-Scan: Suffix nach letztem '_' (oder kompletter String)
        toi = df["TOI"].astype(str).str.strip()
        task_id = toi.str.rsplit("_", n=1).str[-1].str.strip()

        # Nur numerische Metriken aggregieren
        metric_cols = df.select_dtypes(include="number").columns.tolist()
        metric_cols = [c for c in metric_cols if c not in {"Participant", "TOI"}]

        if not metric_cols:
            QMessageBox.information(self, "No numeric metrics", "Keine numerischen Spalten zum Aggregieren gefunden.")
            return

        tmp = df.copy()
        tmp["_task_id"] = task_id

        # Aggregation: mean + std je Participant x Task (für alle numerischen Spalten)
        grouped = tmp.groupby(["Participant", "_task_id"], dropna=False)[metric_cols].agg(["mean", "std"])

        # Spaltennamen flach machen: "<metric>_mean", "<metric>_std"
        grouped.columns = [f"{metric}_{stat}" for (metric, stat) in grouped.columns.to_list()]

        # Index zurück in Spalten
        result = grouped.reset_index().rename(columns={"_task_id": "Task"})

        # --- Zusätzlich: TCT mean/std berechnen und als zusätzliche Spalten mergen ---
        tct_col: Optional[str] = None
        if "Duration" in df.columns:
            tct_col = "Duration"
        else:
            # heuristische Suche (case-insensitive)
            candidates = [
                "tct",
                "task completion time",
                "task_completion_time",
                "taskcompletiontime",
                "completion_time",
                "task time",
                "task_time",
            ]
            lower_map = {c.lower(): c for c in df.columns}
            for key in candidates:
                if key in lower_map:
                    tct_col = lower_map[key]
                    break

        tct_note = ""
        if tct_col is None:
            tct_note = "Keine TCT-Spalte gefunden (erwartet z.B. 'Duration')."
        elif not pd.api.types.is_numeric_dtype(df[tct_col]):
            tct_note = f"TCT-Spalte '{tct_col}' ist nicht numerisch."
        else:
            tct_tmp = tmp[["Participant", "_task_id", tct_col]].copy()
            tct_grouped = (
                tct_tmp.groupby(["Participant", "_task_id"], dropna=False)[tct_col]
                .agg(["mean", "std"])
                .reset_index()
                .rename(columns={"_task_id": "Task", "mean": "tct_mean", "std": "tct_std"})
            )

            # Nicht überschreiben: falls Spalten schon existieren, eindeutige Namen wählen
            if "tct_mean" in result.columns or "tct_std" in result.columns:
                tct_grouped = tct_grouped.rename(columns={"tct_mean": "tct_mean_tct", "tct_std": "tct_std_tct"})

            result = result.merge(tct_grouped, on=["Participant", "Task"], how="left")
            tct_note = f"TCT berechnet aus Spalte '{tct_col}'."

        state.metric_averages_df = result

        extra = f"\n{tct_note}" if tct_note else ""
        QMessageBox.information(
            self,
            "Metric averages calculated",
            f"Fertig. Ergebnis in state.metric_averages_df gespeichert.\n"
            f"Zeilen: {len(result)} | Spalten: {len(result.columns)}"
            f"{extra}",
        )

    def _current_rank_signature(self) -> dict:
        """Build a signature of inputs that affect participant_rank_df."""
        dataset_used = "normalized" if state.normalized_df is not None else "raw"

        selected_group_ids = [gid for gid, cb in self.result_group_checkboxes.items() if cb.isChecked()]
        selected_task_ids = [tid for tid, cb in self.result_task_checkboxes.items() if cb.isChecked()]

        excluded = []
        if self.deselect_enabled_cb.isChecked():
            excluded = sorted([name for name, action in self.deselect_param_checkboxes.items() if action.isChecked()])

        weights_enabled = bool(self.weighting_enabled_cb is not None and self.weighting_enabled_cb.isChecked())
        weights = {}
        if weights_enabled:
            # nur stabile, relevante Gewichte (sortiert)
            weights = {k: float(v) for k, v in sorted(self.parameter_weights.items())}

        return {
            "dataset_used": dataset_used,
            "selected_group_ids": sorted(selected_group_ids),
            "selected_task_ids": sorted(selected_task_ids),
            "excluded_metrics": excluded,
            "weights_enabled": weights_enabled,
            "weights": weights,
        }

    def _on_calculate_participant_rank(self) -> None:
        """
        Berechnet pro Participant ein Task-Ranking (hardest -> easiest) basierend auf kognitiver Last.

        Vorgehen:
        1) Metrikwerte je Participant×Task berechnen (mean über Zeilen).
        2) Pro Participant je Metrik Tasks ranken (Rank 1 = hardest; ties = average).
        3) Gewichtete Rank-Summe über Metriken bilden und Tasks nach kleinster Summe sortieren.
        """
        if state.df is None:
            QMessageBox.information(self, "No data", "Load a TSV file first.")
            return

        df = state.normalized_df if state.normalized_df is not None else state.df

        if "Participant" not in df.columns or "TOI" not in df.columns:
            QMessageBox.critical(self, "Missing columns", "DataFrame benötigt Spalten 'Participant' und 'TOI'.")
            return

        # --- Auswahl: Tasks ---
        selected_tasks = [tid for tid, cb in self.result_task_checkboxes.items() if cb.isChecked()]
        if not selected_tasks:
            selected_tasks = state.tasks_cache.copy()

        # --- Auswahl: Participants (über Gruppen) ---
        selected_group_ids = [gid for gid, cb in self.result_group_checkboxes.items() if cb.isChecked()]
        effective_groups = state.get_effective_participant_groups()

        selected_participants: list[str] = []
        if selected_group_ids:
            s = set()
            for gid in selected_group_ids:
                for p in effective_groups.get(gid, []):
                    s.add(p)
            selected_participants = sorted(s)
        else:
            selected_participants = state.participants_cache.copy()

        if not selected_participants:
            QMessageBox.information(self, "No participants", "Keine Teilnehmer ausgewählt/gefunden.")
            return
        if not selected_tasks:
            QMessageBox.information(self, "No tasks", "Keine Tasks ausgewählt/gefunden.")
            return

        # --- Deselect Parameters ---
        deselected: set[str] = set()
        if self.deselect_enabled_cb.isChecked():
            deselected = {name for name, action in self.deselect_param_checkboxes.items() if action.isChecked()}

        metrics = [m for m in PARAMETER_OPTIONS if m not in deselected]
        if not metrics:
            QMessageBox.information(self, "No metrics", "Alle Metriken sind abgewählt (Deselect Parameters).")
            return

        # --- Weights ---
        weights: Dict[str, float] = {m: 1.0 for m in metrics}
        if self.weighting_enabled_cb is not None and self.weighting_enabled_cb.isChecked():
            for m in metrics:
                if m in self.parameter_weights:
                    weights[m] = float(self.parameter_weights[m])

        # --- Task-ID aus TOI ableiten (Suffix nach letztem '_') ---
        tmp = df.copy()
        tmp["_task_id"] = tmp["TOI"].astype(str).str.strip().str.rsplit("_", n=1).str[-1].str.strip()

        # Filter auf Auswahl
        tmp = tmp[tmp["Participant"].isin(selected_participants)]
        tmp = tmp[tmp["_task_id"].isin(selected_tasks)]

        if tmp.empty:
            QMessageBox.information(
                self,
                "No data after filtering",
                "Nach Filterung (Participants/Tasks) sind keine Datenzeilen übrig.",
            )
            return

        # --- Metrik -> Spaltenmapping + Richtung (True: höher = härter) ---
        # Referenz: TCT↑, SD(TCT)↑, Pupil Diameter↑, Saccade Velocity↓, Peak Saccade Velocity↓, Saccade Amplitude↓.
        def _find_col_case_insensitive(candidates: list[str]) -> Optional[str]:
            lower_map = {c.lower(): c for c in tmp.columns}
            for cand in candidates:
                if cand.lower() in lower_map:
                    return lower_map[cand.lower()]
            return None

        metric_specs: Dict[str, Dict[str, object]] = {}

        # TCT
        tct_col = "Duration" if "Duration" in tmp.columns else _find_col_case_insensitive(
            ["tct", "task_completion_time", "task completion time", "taskcompletiontime", "completion_time", "task_time"]
        )
        if tct_col is not None:
            metric_specs["Task Completion Time (TCT)"] = {"col": tct_col, "agg": "mean", "harder_high": True}
            metric_specs["Standard Deviation of TCT"] = {"col": tct_col, "agg": "std", "harder_high": True}

        # Pupil
        pupil_col = _find_col_case_insensitive(["Average_pupil_diameter", "pupil", "pupil_diameter", "average pupil diameter"])
        if pupil_col is not None:
            metric_specs["Pupil Diameter"] = {"col": pupil_col, "agg": "mean", "harder_high": True}

        # Saccade velocity
        sacc_vel_col = _find_col_case_insensitive(["Average_velocity", "saccade_velocity", "average velocity"])
        if sacc_vel_col is not None:
            metric_specs["Saccade Velocity"] = {"col": sacc_vel_col, "agg": "mean", "harder_high": False}

        # Peak saccade velocity
        peak_vel_col = _find_col_case_insensitive(["Peak_velocity", "peak_velocity", "peak saccade velocity"])
        if peak_vel_col is not None:
            metric_specs["Peak Saccade Velocity"] = {"col": peak_vel_col, "agg": "mean", "harder_high": False}

        # Saccade amplitude
        sacc_amp_col = _find_col_case_insensitive(["Saccade_amplitude", "saccade_amplitude", "saccade amplitude"])
        if sacc_amp_col is not None:
            metric_specs["Saccade Amplitude"] = {"col": sacc_amp_col, "agg": "mean", "harder_high": False}

        # Nur Metriken verwenden, die wir auch wirklich berechnen können
        usable_metrics: list[str] = []
        missing_metrics: list[str] = []
        for m in metrics:
            if m in metric_specs:
                col = metric_specs[m]["col"]
                if isinstance(col, str) and col in tmp.columns and pd.api.types.is_numeric_dtype(tmp[col]):
                    usable_metrics.append(m)
                else:
                    missing_metrics.append(m)
            else:
                missing_metrics.append(m)

        if not usable_metrics:
            QMessageBox.critical(
                self,
                "No usable metrics",
                "Keine der ausgewählten Metriken konnte auf numerische Spalten gemappt werden.\n"
                f"Ausgewählt: {metrics}",
            )
            return

        # --- Schritt 1: Werte je Participant×Task berechnen ---
        base_index = tmp.groupby(["Participant", "_task_id"], dropna=False).size().reset_index()[["Participant", "_task_id"]]
        base_index = base_index.rename(columns={"_task_id": "Task"}).drop_duplicates()

        values_df = base_index.copy()

        for m in usable_metrics:
            spec = metric_specs[m]
            col = spec["col"]  # type: ignore[assignment]
            agg = spec["agg"]  # type: ignore[assignment]
            if not isinstance(col, str) or not isinstance(agg, str):
                continue

            g = tmp.groupby(["Participant", "_task_id"], dropna=False)[col]
            if agg == "mean":
                s = g.mean()
            elif agg == "std":
                s = g.std(ddof=1)
            else:
                raise ValueError(f"Unbekannte Aggregation: {agg}")

            s = s.reset_index().rename(columns={"_task_id": "Task", col: m})
            values_df = values_df.merge(s, on=["Participant", "Task"], how="left")

        # --- Schritt 2: Pro Participant je Metrik ranken (Rank 1 = hardest) ---
        ranks_df = values_df[["Participant", "Task"]].copy()

        for m in usable_metrics:
            harder_high = bool(metric_specs[m]["harder_high"])
            ascending = not harder_high
            ranks_df[m] = (
                values_df.groupby("Participant", dropna=False)[m]
                .rank(method="average", ascending=ascending, na_option="keep")
            )

        # --- Schritt 3: Gewichtete Rank-Summe + finaler Task-Rank ---
        weighted_sum = pd.Series(0.0, index=ranks_df.index)
        weight_sum = pd.Series(0.0, index=ranks_df.index)

        for m in usable_metrics:
            w = float(weights.get(m, 1.0))
            r = ranks_df[m]
            mask = r.notna()
            weighted_sum = weighted_sum + (r.fillna(0.0) * w)
            weight_sum = weight_sum + (mask.astype(float) * w)

        final_score = weighted_sum.where(weight_sum > 0, other=pd.NA)

        out = ranks_df[["Participant", "Task"]].copy()
        out["rank_sum"] = final_score

        out["final_rank"] = out.groupby("Participant", dropna=False)["rank_sum"].rank(
            method="average", ascending=True, na_option="keep"
        )

        for m in usable_metrics:
            out[f"{m}__rank"] = ranks_df[m]

        out = out.sort_values(["Participant", "final_rank", "Task"], ascending=[True, True, True]).reset_index(drop=True)

        state.participant_rank_df = out
        self._participant_rank_signature = self._current_rank_signature()

        note = ""
        if missing_metrics:
            note = "\nNicht gemappte/fehlende Metriken: " + ", ".join(missing_metrics)

        QMessageBox.information(
            self,
            "Participant rank calculated",
            "Fertig. Ergebnis in state.participant_rank_df gespeichert.\n"
            f"Participants: {out['Participant'].nunique()} | Tasks: {out['Task'].nunique()} | Rows: {len(out)}\n"
            f"Verwendete Metriken: {', '.join(usable_metrics)}"
            f"{note}",
        )

    def _show_rank_results_popup(
        self,
        title: str,
        header: str,
        sections: list[tuple[str, pd.DataFrame]],
        warnings: list[str],
    ) -> None:
        dlg = QDialog(self)
        dlg.setWindowTitle(title)
        dlg.setModal(True)
        dlg.setMinimumSize(900, 700)

        layout = QVBoxLayout(dlg)

        text = QTextEdit()
        text.setReadOnly(True)

        parts: list[str] = []
        parts.append(header.strip())
        parts.append("")

        for section_title, df in sections:
            parts.append(section_title)
            parts.append("-" * len(section_title))
            if df.empty:
                parts.append("(keine Daten)")
            else:
                # df ist bereits auf Rank/Task/Score reduziert
                parts.append(df.to_string(index=False))
            parts.append("")

        if warnings:
            parts.append("Warnings")
            parts.append("--------")
            for w in warnings:
                parts.append(f"- {w}")
            parts.append("")

        text.setPlainText("\n".join(parts))
        layout.addWidget(text)

        btn_row = QHBoxLayout()
        btn_row.addStretch()
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(dlg.accept)
        btn_row.addWidget(close_btn)
        layout.addLayout(btn_row)

        dlg.exec()

    def _on_show_results(self) -> None:
        """Handle Show Results button click."""
        if state.df is None:
            QMessageBox.information(self, "No data", "Load a TSV file first.")
            return

        selected_groups = [gid for gid, cb in self.result_group_checkboxes.items() if cb.isChecked()]
        selected_tasks = [tid for tid, cb in self.result_task_checkboxes.items() if cb.isChecked()]
        domains = [name for name, cb in self.result_domain_vars.items() if cb.isChecked()]
        mode = self.mode_combo.currentText()

        deselected = []
        if self.deselect_enabled_cb.isChecked():
            deselected = [name for name, action in self.deselect_param_checkboxes.items() if action.isChecked()]

        # Parameter weights (nur anzeigen, wenn aktiviert)
        weights_text = "(disabled)"
        if self.weighting_enabled_cb is not None and self.weighting_enabled_cb.isChecked():
            if not self.parameter_weights:
                weights_text = "(none)"
            else:
                parts = [f"{k} = {self._format_weight(v)}" for k, v in sorted(self.parameter_weights.items())]
                weights_text = ", ".join(parts)

        # --- Rank domain: show computed participant rank results ---
        if "Rank" in domains:
            if state.participant_rank_df is None or state.participant_rank_df.empty:
                QMessageBox.information(
                    self,
                    "Rank Results not available",
                    "Keine Rank-Ergebnisse vorhanden.\nBitte zuerst 'Calculate Participant Rank' ausführen.",
                )
                return

            current_sig = self._current_rank_signature()
            if self._participant_rank_signature != current_sig:
                QMessageBox.information(
                    self,
                    "Rank Results stale",
                    "Die Rank-Ergebnisse passen nicht zu den aktuellen UI-Auswahlen (Groups/Tasks/Deselect/Weights oder Datenbasis).\n"
                    "Bitte 'Calculate Participant Rank' erneut ausführen.",
                )
                return

            rank_df = state.participant_rank_df.copy()

            # Scope: Tasks
            task_scope = selected_tasks if selected_tasks else state.tasks_cache.copy()
            # Scope: Participants via groups
            effective_groups = state.get_effective_participant_groups()
            effective_names = state.get_effective_group_names()

            group_ids = selected_groups if selected_groups else list(effective_groups.keys())
            if not group_ids:
                group_ids = ["ALL"]

            warnings: list[str] = []
            sections: list[tuple[str, pd.DataFrame]] = []

            dataset_used = "normalized" if state.normalized_df is not None else "raw"
            excluded_metrics = sorted(deselected) if deselected else []
            weights_list = []
            if self.weighting_enabled_cb is not None and self.weighting_enabled_cb.isChecked():
                weights_list = [f"{k}={self._format_weight(v)}" for k, v in sorted(self.parameter_weights.items())]

            # Helper: format a table
            def _table_from_scores(df_scores: pd.DataFrame) -> pd.DataFrame:
                # df_scores: columns Task, rank_sum
                t = df_scores.copy()
                t = t.sort_values(["rank_sum", "Task"], ascending=[True, True]).reset_index(drop=True)
                t.insert(0, "Rank", range(1, len(t) + 1))
                t = t.rename(columns={"rank_sum": "Score"})
                t = t[["Rank", "Task", "Score"]]
                return t

            # Build participant list per group
            group_to_participants: dict[str, list[str]] = {}
            for gid in group_ids:
                members = effective_groups.get(gid, [])
                if not members:
                    warnings.append(f"Gruppe '{effective_names.get(gid, gid)}' hat 0 Mitglieder (übersprungen).")
                    continue
                group_to_participants[gid] = members

            # If no groups had members, fallback to all participants
            if not group_to_participants:
                all_p = state.participants_cache.copy()
                if not all_p:
                    QMessageBox.information(self, "No participants", "Keine Teilnehmer gefunden.")
                    return
                group_to_participants = {"ALL": all_p}

            # Filter rank_df to task scope early
            rank_df = rank_df[rank_df["Task"].isin(task_scope)]

            # Determine which participants have which tasks (for warnings)
            # We'll warn if a participant is missing any selected task in the rank_df.
            for gid, members in group_to_participants.items():
                for p in members:
                    p_tasks = set(rank_df.loc[rank_df["Participant"] == p, "Task"].astype(str).tolist())
                    for t in task_scope:
                        if t not in p_tasks:
                            warnings.append(f"{p} hatte keine Zeilen für Task {t}")

            # Mode handling
            def _add_group_mean_sections() -> None:
                for gid, members in group_to_participants.items():
                    gname = effective_names.get(gid, gid)
                    sub = rank_df[rank_df["Participant"].isin(members)]
                    if sub.empty:
                        warnings.append(f"Gruppe '{gname}' hat nach Filterung keine Daten (übersprungen).")
                        continue
                    # mean rank_sum per task
                    g_scores = (
                        sub.groupby("Task", dropna=False)["rank_sum"]
                        .mean()
                        .reset_index()
                    )
                    g_table = _table_from_scores(g_scores)
                    sections.append((f"Group mean: {gname}", g_table))

            def _add_individual_sections() -> None:
                # participants inside selected groups (or all fallback)
                seen: set[str] = set()
                for _gid, members in group_to_participants.items():
                    for p in members:
                        if p in seen:
                            continue
                        seen.add(p)
                        sub = rank_df[rank_df["Participant"] == p][["Task", "rank_sum"]].copy()
                        if sub.empty:
                            warnings.append(f"{p} hat nach Filterung keine Daten (übersprungen).")
                            continue
                        p_table = _table_from_scores(sub)
                        sections.append((f"Participant: {p}", p_table))

            if mode == "Only group mean":
                _add_group_mean_sections()
            elif mode == "Each participant for selected groups":
                _add_individual_sections()
            elif mode == "Group mean and individual participants":
                _add_group_mean_sections()
                _add_individual_sections()
            else:
                warnings.append(f"Unbekannter Mode '{mode}' (zeige Individual-Rankings).")
                _add_individual_sections()

            # Header paragraph
            # #participants/#tasks should reflect the popup scope (after group/task selection)
            participants_in_scope: set[str] = set()
            for members in group_to_participants.values():
                participants_in_scope.update(members)
            participants_in_scope = {p for p in participants_in_scope if p in set(rank_df["Participant"].unique())}

            tasks_in_scope = sorted(set(task_scope) & set(rank_df["Task"].unique()))

            header = (
                f"Dataset: {dataset_used}; "
                f"Participants: {len(participants_in_scope)}; "
                f"Tasks: {len(tasks_in_scope)}; "
                f"Mode: {mode}; "
                f"Excluded metrics: {', '.join(excluded_metrics) if excluded_metrics else '(none)'}; "
                f"Custom weights: {', '.join(weights_list) if weights_list else '(none)'}"
            )

            self._show_rank_results_popup(
                title="Rank Results",
                header=header,
                sections=sections,
                warnings=warnings,
            )
            return

        # Fallback: existing placeholder message
        msg = (
            f"Mode: {mode}\n"
            f"Groups selected: {len(selected_groups)}\n"
            f"Tasks selected: {len(selected_tasks)}\n"
            f"Result domains: {', '.join(domains) if domains else '(none)'}\n"
            f"Deselected parameters: {', '.join(deselected) if deselected else '(none)'}\n"
            f"Parameter weights: {weights_text}"
        )
        QMessageBox.information(self, "Show Results (placeholder)", msg)

    def _on_print_exec_summary(self) -> None:
        """Handle Print Executive Summary button click."""
        if state.df is None:
            QMessageBox.information(self, "No data", "Load a TSV file first.")
            return
        QMessageBox.information(
            self,
            "Executive Summary (placeholder)",
            "This will generate the executive summary later.",
        )
```

> Tokens: 32k sent, 11k received. Cost: $0.21 message, $2.21 session.  
> Applied edit to main_window.py  
> Commit 00838bb feat: Rank-Ergebnisse in scrollbarem Popup mit Stale-Check anzeigen  
> You can use /undo to undo and discard each aider commit.  

#### /architect  
> Aider v0.86.1  
> Model: gpt-5.2 with architect edit format  
> Editor model: gpt-5.2 with editor-whole edit format  
> Git repo: .git with 25 files  
> Repo-map: using 4096 tokens, auto refresh  
> Added data_processor.py to the chat.  
> Added dialogs.py to the chat.  
> Added eye_tracking_tool\dialogs.py to the chat.  
> Added main_window.py to the chat.  
> Added state.py to the chat.  
> Restored previous conversation history.  

#### Fix the bug where applying Custom parameter weights does not change the participant rank score / ordering.  
####   
#### Goal: Ensure the rank computation always uses the current weights from the Weighting Parameters UI at calculation time, and ensure Show Results (Rank) does not display stale results.  

### Ursache (Architektur-Sicht)
Der Rank wird in `_on_calculate_participant_rank()` zwar *theoretisch* gewichtet, aber die UI-Weights sind in der Praxis oft **nicht vollständig/aktuell** in `self.parameter_weights`, weil:
- `self.parameter_weights` wird nur in `_on_weight_row_changed()` aktualisiert.
- Wenn der User Parameter auswählt, aber den Slider nicht bewegt (oder Combos rebuilds passieren), kann `self.parameter_weights` **leer/teilweise** bleiben.
- Außerdem wird beim “Rank Results” Popup die Stale-Prüfung über `_current_rank_signature()` gemacht, die aktuell **direkt `self.parameter_weights`** nutzt – also ebenfalls potentiell nicht den echten UI-Stand.

**Fix-Strategie:**  
1) Eine **Single Source of Truth** für “aktuelle UI-Weights” einführen, die **immer** aus den `weight_rows` gelesen wird (Combo + Slider), nicht aus `self.parameter_weights`.  
2) Rank-Berechnung nutzt diese “live” Weights.  
3) Signature/Stale-Check nutzt ebenfalls diese “live” Weights.  
4) Optional: `self.parameter_weights` weiter pflegen, aber nicht mehr als Grundlage verwenden.

---

## Änderungen in `main_window.py`

### 1) Neue Helper-Funktion: aktuelle Weights aus der UI lesen
**Einfügen in `MainWindow` (z.B. nahe `_selected_weight_params`)**:

```python
def _current_ui_parameter_weights(self) -> Dict[str, float]:
    """
    Liefert die aktuell im Weighting-UI gewählten Gewichte als Dict[param] = weight.
    Quelle ist ausschließlich die UI (Combos + Slider), nicht self.parameter_weights.
    """
    weights: Dict[str, float] = {}
    if self.weighting_enabled_cb is None or not self.weighting_enabled_cb.isChecked():
        return weights

    for combo, slider, _lbl in self.weight_rows:
        param = combo.currentData()
        if isinstance(param, str) and param:
            weights[param] = float(self._weight_slider_to_float(slider.value()))
    return weights
```

### 2) `_current_rank_signature()` muss UI-Weights verwenden (nicht `self.parameter_weights`)
**In `_current_rank_signature()` den Weights-Block ersetzen**:

Ersetze:

```python
weights_enabled = bool(self.weighting_enabled_cb is not None and self.weighting_enabled_cb.isChecked())
weights = {}
if weights_enabled:
    # nur stabile, relevante Gewichte (sortiert)
    weights = {k: float(v) for k, v in sorted(self.parameter_weights.items())}
```

durch:

```python
weights_enabled = bool(self.weighting_enabled_cb is not None and self.weighting_enabled_cb.isChecked())
weights = {}
if weights_enabled:
    ui_weights = self._current_ui_parameter_weights()
    weights = {k: float(v) for k, v in sorted(ui_weights.items())}
```

Damit wird “stale” korrekt erkannt, auch wenn `self.parameter_weights` nicht sauber gepflegt war.

### 3) Rank-Berechnung muss UI-Weights “live” verwenden
**In `_on_calculate_participant_rank()` den Weights-Block ersetzen**:

Ersetze:

```python
weights: Dict[str, float] = {m: 1.0 for m in metrics}
if self.weighting_enabled_cb is not None and self.weighting_enabled_cb.isChecked():
    for m in metrics:
        if m in self.parameter_weights:
            weights[m] = float(self.parameter_weights[m])
```

durch:

```python
weights: Dict[str, float] = {m: 1.0 for m in metrics}
if self.weighting_enabled_cb is not None and self.weighting_enabled_cb.isChecked():
    ui_weights = self._current_ui_parameter_weights()
    for m in metrics:
        if m in ui_weights:
            weights[m] = float(ui_weights[m])
```

Damit ist garantiert: **Berechnung nutzt immer den aktuellen UI-Stand**, unabhängig davon, ob Slider bewegt wurde.

### 4) Show Results (Rank): Anzeige der Weights ebenfalls aus UI lesen
In `_on_show_results()` wird `weights_list` aktuell aus `self.parameter_weights` gebaut. Das kann falsche/alte Werte anzeigen.

**Ersetze in `_on_show_results()` diesen Block:**

```python
weights_list = []
if self.weighting_enabled_cb is not None and self.weighting_enabled_cb.isChecked():
    weights_list = [f"{k}={self._format_weight(v)}" for k, v in sorted(self.parameter_weights.items())]
```

durch:

```python
weights_list = []
if self.weighting_enabled_cb is not None and self.weighting_enabled_cb.isChecked():
    ui_weights = self._current_ui_parameter_weights()
    weights_list = [f"{k}={self._format_weight(v)}" for k, v in sorted(ui_weights.items())]
```

### 5) Optional aber empfohlen: `self.parameter_weights` beim Rebuild konsistent halten
Das ist nicht mehr kritisch für die Rank-Logik, aber verhindert Verwirrung/Altlasten.

**In `_rebuild_weight_combos()` im `else:`-Zweig (wenn keine Auswahl) zusätzlich entfernen:**

Aktuell:

```python
else:
    combo.setCurrentIndex(0)
    slider.setEnabled(False)
    value_lbl.setEnabled(False)
```

Ergänze direkt danach:

```python
# Falls vorher ein Param gesetzt war, sicherstellen, dass er nicht als Weight hängen bleibt
if isinstance(current, str) and current:
    self.parameter_weights.pop(current, None)
```

(So bleibt `self.parameter_weights` näher an der UI, auch wenn wir es nicht mehr als Quelle verwenden.)

---

## Ergebnis / Akzeptanzkriterien
- Wenn der User **nur** einen Parameter auswählt und den Slider nicht bewegt, wird trotzdem ein Weight (Default 1.0) aus dem Slider gelesen und in der Rank-Berechnung verwendet.
- Wenn der User Slider/Combos ändert und **ohne erneutes “Calculate Participant Rank”** auf “Show Results” geht, greift die Stale-Prüfung zuverlässig, weil Signature die **UI-Weights live** berücksichtigt.
- Rank-Score/Ordering ändert sich sichtbar, sobald Weights geändert und Rank neu berechnet wird.

---

Wenn du willst, kann ich dir zusätzlich eine Mini-Test-Checkliste geben (2–3 manuelle Schritte), aber die obigen Code-Änderungen sind alles, was für den Fix nötig ist.

> Tokens: 21k sent, 1.5k received. Cost: $0.06 message, $2.27 session.  

#### ### Ursache (Architektur-Sicht)  
#### Der Rank wird in `_on_calculate_participant_rank()` zwar *theoretisch* gewichtet, aber die UI-Weights sind in der Praxis oft **nicht vollständig/aktuell** in `self.parameter_weights`, weil:  
#### - `self.parameter_weights` wird nur in `_on_weight_row_changed()` aktualisiert.  
#### - Wenn der User Parameter auswählt, aber den Slider nicht bewegt (oder Combos rebuilds passieren), kann `self.parameter_weights` **leer/teilweise** bleiben.  
#### - Außerdem wird beim “Rank Results” Popup die Stale-Prüfung über `_current_rank_signature()` gemacht, die aktuell **direkt `self.parameter_weights`** nutzt – also ebenfalls potentiell nicht den echten UI-Stand.  
####   
#### **Fix-Strategie:**    
#### 1) Eine **Single Source of Truth** für “aktuelle UI-Weights” einführen, die **immer** aus den `weight_rows` gelesen wird (Combo + Slider), nicht aus `self.parameter_weights`.    
#### 2) Rank-Berechnung nutzt diese “live” Weights.    
#### 3) Signature/Stale-Check nutzt ebenfalls diese “live” Weights.    
#### 4) Optional: `self.parameter_weights` weiter pflegen, aber nicht mehr als Grundlage verwenden.  
####   
#### ---  
####   
#### ## Änderungen in `main_window.py`  
####   
#### ### 1) Neue Helper-Funktion: aktuelle Weights aus der UI lesen  
#### **Einfügen in `MainWindow` (z.B. nahe `_selected_weight_params`)**:  
####   
#### ```python  
#### def _current_ui_parameter_weights(self) -> Dict[str, float]:  
####     """  
####     Liefert die aktuell im Weighting-UI gewählten Gewichte als Dict[param] = weight.  
####     Quelle ist ausschließlich die UI (Combos + Slider), nicht self.parameter_weights.  
####     """  
####     weights: Dict[str, float] = {}  
####     if self.weighting_enabled_cb is None or not self.weighting_enabled_cb.isChecked():  
####         return weights  
####   
####     for combo, slider, _lbl in self.weight_rows:  
####         param = combo.currentData()  
####         if isinstance(param, str) and param:  
####             weights[param] = float(self._weight_slider_to_float(slider.value()))  
####     return weights  
#### ```  
####   
#### ### 2) `_current_rank_signature()` muss UI-Weights verwenden (nicht `self.parameter_weights`)  
#### **In `_current_rank_signature()` den Weights-Block ersetzen**:  
####   
#### Ersetze:  
####   
#### ```python  
#### weights_enabled = bool(self.weighting_enabled_cb is not None and self.weighting_enabled_cb.isChecked())  
#### weights = {}  
#### if weights_enabled:  
####     # nur stabile, relevante Gewichte (sortiert)  
####     weights = {k: float(v) for k, v in sorted(self.parameter_weights.items())}  
#### ```  
####   
#### durch:  
####   
#### ```python  
#### weights_enabled = bool(self.weighting_enabled_cb is not None and self.weighting_enabled_cb.isChecked())  
#### weights = {}  
#### if weights_enabled:  
####     ui_weights = self._current_ui_parameter_weights()  
####     weights = {k: float(v) for k, v in sorted(ui_weights.items())}  
#### ```  
####   
#### Damit wird “stale” korrekt erkannt, auch wenn `self.parameter_weights` nicht sauber gepflegt war.  
####   
#### ### 3) Rank-Berechnung muss UI-Weights “live” verwenden  
#### **In `_on_calculate_participant_rank()` den Weights-Block ersetzen**:  
####   
#### Ersetze:  
####   
#### ```python  
#### weights: Dict[str, float] = {m: 1.0 for m in metrics}  
#### if self.weighting_enabled_cb is not None and self.weighting_enabled_cb.isChecked():  
####     for m in metrics:  
####         if m in self.parameter_weights:  
####             weights[m] = float(self.parameter_weights[m])  
#### ```  
####   
#### durch:  
####   
#### ```python  
#### weights: Dict[str, float] = {m: 1.0 for m in metrics}  
#### if self.weighting_enabled_cb is not None and self.weighting_enabled_cb.isChecked():  
####     ui_weights = self._current_ui_parameter_weights()  
####     for m in metrics:  
####         if m in ui_weights:  
####             weights[m] = float(ui_weights[m])  
#### ```  
####   
#### Damit ist garantiert: **Berechnung nutzt immer den aktuellen UI-Stand**, unabhängig davon, ob Slider bewegt wurde.  
####   
#### ### 4) Show Results (Rank): Anzeige der Weights ebenfalls aus UI lesen  
#### In `_on_show_results()` wird `weights_list` aktuell aus `self.parameter_weights` gebaut. Das kann falsche/alte Werte anzeigen.  
####   
#### **Ersetze in `_on_show_results()` diesen Block:**  
####   
#### ```python  
#### weights_list = []  
#### if self.weighting_enabled_cb is not None and self.weighting_enabled_cb.isChecked():  
####     weights_list = [f"{k}={self._format_weight(v)}" for k, v in sorted(self.parameter_weights.items())]  
#### ```  
####   
#### durch:  
####   
#### ```python  
#### weights_list = []  
#### if self.weighting_enabled_cb is not None and self.weighting_enabled_cb.isChecked():  
####     ui_weights = self._current_ui_parameter_weights()  
####     weights_list = [f"{k}={self._format_weight(v)}" for k, v in sorted(ui_weights.items())]  
#### ```  
####   
#### ### 5) Optional aber empfohlen: `self.parameter_weights` beim Rebuild konsistent halten  
#### Das ist nicht mehr kritisch für die Rank-Logik, aber verhindert Verwirrung/Altlasten.  
####   
#### **In `_rebuild_weight_combos()` im `else:`-Zweig (wenn keine Auswahl) zusätzlich entfernen:**  
####   
#### Aktuell:  
####   
#### ```python  
#### else:  
####     combo.setCurrentIndex(0)  
####     slider.setEnabled(False)  
####     value_lbl.setEnabled(False)  
#### ```  
####   
#### Ergänze direkt danach:  
####   
#### ```python  
#### # Falls vorher ein Param gesetzt war, sicherstellen, dass er nicht als Weight hängen bleibt  
#### if isinstance(current, str) and current:  
####     self.parameter_weights.pop(current, None)  
#### ```  
####   
#### (So bleibt `self.parameter_weights` näher an der UI, auch wenn wir es nicht mehr als Quelle verwenden.)  
####   
#### ---  
####   
#### ## Ergebnis / Akzeptanzkriterien  
#### - Wenn der User **nur** einen Parameter auswählt und den Slider nicht bewegt, wird trotzdem ein Weight (Default 1.0) aus dem Slider gelesen und in der Rank-Berechnung verwendet.  
#### - Wenn der User Slider/Combos ändert und **ohne erneutes “Calculate Participant Rank”** auf “Show Results” geht, greift die Stale-Prüfung zuverlässig, weil Signature die **UI-Weights live** berücksichtigt.  
#### - Rank-Score/Ordering ändert sich sichtbar, sobald Weights geändert und Rank neu berechnet wird.  
####   
#### ---  
####   
#### Wenn du willst, kann ich dir zusätzlich eine Mini-Test-Checkliste geben (2–3 manuelle Schritte), aber die obigen Code-Änderungen sind alles, was für den Fix nötig ist.  

main_window.py
```
"""
Main window for the Eye Tracking Tool using PyQt6.
"""
from __future__ import annotations

from typing import Dict, Optional
import pandas as pd

from PyQt6.QtWidgets import (
    QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, QLabel, QPushButton,
    QListWidget, QLineEdit, QComboBox, QCheckBox, QGroupBox, QGridLayout,
    QFrame, QMessageBox, QFileDialog, QMenu, QMenuBar, QSplitter, QSlider,
    QDialog, QTextEdit
)
from PyQt6.QtCore import Qt, QSize
from PyQt6.QtGui import QAction

from state import state
from models import EXPECTED_COLUMNS, PARAMETER_OPTIONS
from data_processor import (
    validate_tsv_format,
    extract_participants,
    extract_tasks_from_toi,
    normalize_by_participant_baseline,
)
from dialogs import GroupParticipantsDialog, GroupTasksDialog


class MainWindow(QMainWindow):
    """Main application window."""

    def __init__(self) -> None:
        super().__init__()
        self.setWindowTitle("Eye Tracking Analysis Tool")
        self.setMinimumSize(1200, 720)

        # Result domain checkboxes
        self.result_domain_vars: Dict[str, QCheckBox] = {}

        # Result group/task checkboxes
        self.result_group_checkboxes: Dict[str, QCheckBox] = {}
        self.result_task_checkboxes: Dict[str, QCheckBox] = {}

        # Deselect parameters
        self.deselect_param_checkboxes: Dict[str, QCheckBox] = {}

        # Weighting parameters
        self.weighting_enabled_cb: Optional[QCheckBox] = None
        self.weight_rows: list[tuple[QComboBox, QSlider, QLabel]] = []
        self.parameter_weights: Dict[str, float] = {}

        # Snapshot of the last rank computation inputs (to detect stale results)
        self._participant_rank_signature: Optional[dict] = None

        self._setup_ui()

    # --- Weighting slider mapping (QSlider is int-based) ---
    def _weight_slider_to_float(self, slider_val: int) -> float:
        # 2..10 -> 1.0..5.0 in 0.5 steps
        return float(slider_val) / 2.0

    def _weight_float_to_slider(self, weight: float) -> int:
        # clamp + round to nearest 0.5 step, then map to int
        w = max(1.0, min(5.0, float(weight)))
        return int(round(w * 2.0))

    def _format_weight(self, weight: float) -> str:
        return f"{weight:.2f}".rstrip("0").rstrip(".")

    def _setup_ui(self) -> None:
        central = QWidget()
        self.setCentralWidget(central)
        main_layout = QVBoxLayout(central)
        main_layout.setContentsMargins(10, 10, 10, 10)

        # Top bar
        topbar = QHBoxLayout()

        self.load_btn = QPushButton("Load TSV")
        self.load_btn.setFixedWidth(120)
        self.load_btn.clicked.connect(self._load_tsv)
        topbar.addWidget(self.load_btn)

        self.group_participants_btn = QPushButton("Group Participants")
        self.group_participants_btn.setFixedWidth(150)
        self.group_participants_btn.setEnabled(False)
        self.group_participants_btn.clicked.connect(self._open_group_participants)
        topbar.addWidget(self.group_participants_btn)

        # Button-Text wie gewünscht: "Name Tasks"
        self.group_tasks_btn = QPushButton("Name Tasks")
        self.group_tasks_btn.setFixedWidth(120)
        self.group_tasks_btn.setEnabled(False)
        self.group_tasks_btn.clicked.connect(self._open_group_tasks)
        topbar.addWidget(self.group_tasks_btn)

        self.file_path_edit = QLineEdit()
        self.file_path_edit.setReadOnly(True)
        self.file_path_edit.setPlaceholderText("No file loaded")
        topbar.addWidget(self.file_path_edit)

        main_layout.addLayout(topbar)

        # Listboxes section
        listbox_layout = QHBoxLayout()

        # Participants listbox
        left_widget = QWidget()
        left_layout = QVBoxLayout(left_widget)
        left_layout.setContentsMargins(0, 0, 0, 0)
        left_layout.addWidget(QLabel('Detected participants (from "Participant"):'))
        self.participants_list = QListWidget()
        self.participants_list.setMaximumHeight(120)
        left_layout.addWidget(self.participants_list)
        listbox_layout.addWidget(left_widget)

        # Tasks listbox
        right_widget = QWidget()
        right_layout = QVBoxLayout(right_widget)
        right_layout.setContentsMargins(0, 0, 0, 0)
        right_layout.addWidget(QLabel('Detected tasks (from "TOI" suffix):'))
        self.tasks_list = QListWidget()
        self.tasks_list.setMaximumHeight(120)
        right_layout.addWidget(self.tasks_list)
        listbox_layout.addWidget(right_widget)

        main_layout.addLayout(listbox_layout)

        # Separator
        separator = QFrame()
        separator.setFrameShape(QFrame.Shape.HLine)
        separator.setFrameShadow(QFrame.Shadow.Sunken)
        main_layout.addWidget(separator)

        # Results section
        results_label = QLabel("Results")
        results_label.setStyleSheet("font-weight: bold; font-size: 14px;")
        main_layout.addWidget(results_label)

        # Mode selection
        mode_layout = QHBoxLayout()
        mode_layout.addWidget(QLabel("Show results for:"))

        self.mode_combo = QComboBox()
        self.mode_combo.addItems([
            "Only group mean",
            "Each participant for selected groups",
            "Group mean and individual participants",
        ])
        self.mode_combo.setFixedWidth(350)
        mode_layout.addWidget(self.mode_combo)
        mode_layout.addStretch()
        main_layout.addLayout(mode_layout)

        # Groups and Tasks frames
        sel_layout = QHBoxLayout()

        self.groups_group = QGroupBox("Groups")
        self.groups_layout = QVBoxLayout(self.groups_group)
        sel_layout.addWidget(self.groups_group)

        self.tasks_group = QGroupBox("Tasks")
        self.tasks_layout = QGridLayout(self.tasks_group)
        sel_layout.addWidget(self.tasks_group)

        main_layout.addLayout(sel_layout)

        # Bottom row: Result domain and Deselect parameters
        bottom_layout = QHBoxLayout()

        # Result domain
        domain_group = QGroupBox("Result domain")
        domain_layout = QHBoxLayout(domain_group)

        for name in ["Rank", "Radar Chart", "Task Completion Time"]:
            cb = QCheckBox(name)
            cb.setChecked(True)
            self.result_domain_vars[name] = cb
            domain_layout.addWidget(cb)

        domain_layout.addStretch()
        bottom_layout.addWidget(domain_group)

        # Deselect parameters
        deselect_group = QGroupBox("Deselect Parameters")
        deselect_layout = QHBoxLayout(deselect_group)

        self.deselect_enabled_cb = QCheckBox("Enable Deselect")
        self.deselect_enabled_cb.stateChanged.connect(self._toggle_deselect_menu)
        deselect_layout.addWidget(self.deselect_enabled_cb)

        self.deselect_btn = QPushButton("None")
        self.deselect_btn.setEnabled(False)
        self.deselect_btn.clicked.connect(self._show_deselect_menu)
        deselect_layout.addWidget(self.deselect_btn)

        deselect_layout.addStretch()
        bottom_layout.addWidget(deselect_group)

        # Weighting parameters
        weighting_group = QGroupBox("Weighting Parameters")
        weighting_outer = QVBoxLayout(weighting_group)

        # Toggle row: checkbox + label rechts
        weighting_toggle_row = QHBoxLayout()
        self.weighting_enabled_cb = QCheckBox()
        self.weighting_enabled_cb.setChecked(False)
        self.weighting_enabled_cb.setEnabled(False)
        self.weighting_enabled_cb.stateChanged.connect(self._on_weighting_toggled)
        weighting_toggle_row.addWidget(self.weighting_enabled_cb)
        weighting_toggle_row.addWidget(QLabel("Enable custom parameter weights"))
        weighting_toggle_row.addStretch()
        weighting_outer.addLayout(weighting_toggle_row)

        # Container für dynamische Zeilen
        self.weighting_rows_container = QWidget()
        self.weighting_rows_layout = QVBoxLayout(self.weighting_rows_container)
        self.weighting_rows_layout.setContentsMargins(0, 0, 0, 0)
        self.weighting_rows_layout.setSpacing(6)
        weighting_outer.addWidget(self.weighting_rows_container)

        bottom_layout.addWidget(weighting_group)

        main_layout.addLayout(bottom_layout)

        # Action buttons
        action_layout = QHBoxLayout()

        self.show_results_btn = QPushButton("Show Results")
        self.show_results_btn.setFixedWidth(150)
        self.show_results_btn.setEnabled(False)
        self.show_results_btn.clicked.connect(self._on_show_results)
        action_layout.addWidget(self.show_results_btn)

        self.normalize_btn = QPushButton("Normalize")
        self.normalize_btn.setFixedWidth(150)
        self.normalize_btn.setEnabled(False)
        self.normalize_btn.clicked.connect(self._on_normalize)
        action_layout.addWidget(self.normalize_btn)

        self.calc_metric_averages_btn = QPushButton("Calculate metric averages")
        self.calc_metric_averages_btn.setFixedWidth(200)
        self.calc_metric_averages_btn.setEnabled(False)
        self.calc_metric_averages_btn.clicked.connect(self._on_calculate_metric_averages)
        action_layout.addWidget(self.calc_metric_averages_btn)

        self.exec_summary_btn = QPushButton("Print Executive Summary")
        self.exec_summary_btn.setFixedWidth(180)
        self.exec_summary_btn.setEnabled(False)
        self.exec_summary_btn.clicked.connect(self._on_print_exec_summary)
        action_layout.addWidget(self.exec_summary_btn)

        self.calc_participant_rank_btn = QPushButton("Calculate Participant Rank")
        self.calc_participant_rank_btn.setFixedWidth(220)
        self.calc_participant_rank_btn.setEnabled(False)
        self.calc_participant_rank_btn.clicked.connect(self._on_calculate_participant_rank)
        action_layout.addWidget(self.calc_participant_rank_btn)

        action_layout.addStretch()
        main_layout.addLayout(action_layout)

        main_layout.addStretch()

        # Initialize deselect menu
        self._build_deselect_menu()

        # Initialize weighting UI (disabled by default)
        self._reset_weighting_ui()

        # Initial population
        self._refresh_group_task_toggles()

    def _load_tsv(self) -> None:
        """Load and validate a TSV file."""
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            "Select TSV file",
            "",
            "TSV files (*.tsv);;All files (*.*)"
        )

        if not file_path:
            return

        # Validate format
        result = validate_tsv_format(file_path, EXPECTED_COLUMNS)
        if not result.ok:
            QMessageBox.critical(self, "Format error", result.message or "Unknown format error.")
            return

        # Load data
        try:
            state.df = pd.read_csv(file_path, sep="\t")
        except Exception as e:
            QMessageBox.critical(self, "Load error", str(e))
            return

        # Reset normalized data (must be recomputed for new file)
        state.normalized_df = None
        state.metric_averages_df = None
        state.participant_rank_df = None
        self._participant_rank_signature = None
        if hasattr(self, "calc_metric_averages_btn"):
            self.calc_metric_averages_btn.setEnabled(False)

        # Reset weighting UI/weights (parameters list may change later)
        if self.weighting_enabled_cb is not None:
            self.weighting_enabled_cb.setChecked(False)
        self._reset_weighting_ui()

        # Update UI with file path
        state.loaded_file_path = file_path
        self.file_path_edit.setText(file_path)

        # Reset caches
        state.participants_cache = []
        state.tasks_cache = []

        # Clear listboxes
        self.participants_list.clear()
        self.tasks_list.clear()

        # Disable action buttons during loading
        self.group_participants_btn.setEnabled(False)
        self.group_tasks_btn.setEnabled(False)
        self._set_main_action_buttons_enabled(False)

        # Extract participants
        try:
            state.participants_cache = extract_participants(state.df, column="Participant")
        except Exception as e:
            QMessageBox.critical(self, "Participant scan failed", str(e))
            state.df = None
            return

        # Extract tasks
        try:
            state.tasks_cache = extract_tasks_from_toi(state.df, column="TOI")
        except Exception as e:
            QMessageBox.critical(self, "Task scan failed", str(e))
            state.df = None
            return

        # Keep only labels for tasks that exist
        state.task_labels = {k: v for k, v in state.task_labels.items() if k in set(state.tasks_cache)}

        # Update listboxes
        for p in state.participants_cache:
            self.participants_list.addItem(p)

        self._refresh_tasks_listbox()

        # Enable group buttons
        self.group_participants_btn.setEnabled(bool(state.participants_cache))
        self.group_tasks_btn.setEnabled(bool(state.tasks_cache))

        if self.weighting_enabled_cb is not None:
            self.weighting_enabled_cb.setEnabled(True)

        self._set_main_action_buttons_enabled(True)
        self._refresh_group_task_toggles()

        QMessageBox.information(
            self,
            "Success",
            f"Loaded {len(state.df)} rows.\n"
            f"Found {len(state.participants_cache)} participants and {len(state.tasks_cache)} tasks."
        )

    def _refresh_tasks_listbox(self) -> None:
        """Refresh the tasks listbox with formatted task names."""
        self.tasks_list.clear()
        for t in state.tasks_cache:
            self.tasks_list.addItem(state.format_task(t))

    def _set_main_action_buttons_enabled(self, enabled: bool) -> None:
        """Enable or disable main action buttons."""
        self.show_results_btn.setEnabled(enabled)
        self.normalize_btn.setEnabled(enabled)
        self.calc_metric_averages_btn.setEnabled(enabled)
        self.exec_summary_btn.setEnabled(enabled)
        self.calc_participant_rank_btn.setEnabled(enabled)

    def _refresh_group_task_toggles(self) -> None:
        """Refresh the checkbox lists in the Results section."""
        # Clear existing group checkboxes
        while self.groups_layout.count():
            item = self.groups_layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()

        # Clear existing task checkboxes
        while self.tasks_layout.count():
            item = self.tasks_layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()

        self.result_group_checkboxes.clear()
        self.result_task_checkboxes.clear()

        # Groups toggles
        effective_groups = state.get_effective_participant_groups()
        effective_names = state.get_effective_group_names()

        if not effective_groups:
            label = QLabel("(Load a TSV file first)")
            label.setStyleSheet("color: #666;")
            self.groups_layout.addWidget(label)
        else:
            for gid in effective_groups.keys():
                name = effective_names.get(gid, gid)
                cb = QCheckBox(name)
                cb.setChecked(True)
                self.result_group_checkboxes[gid] = cb
                self.groups_layout.addWidget(cb)

        self.groups_layout.addStretch()

        # Tasks toggles
        if not state.tasks_cache:
            label = QLabel("(Load a TSV file first)")
            label.setStyleSheet("color: #666;")
            self.tasks_layout.addWidget(label, 0, 0)
            return

        cols = 8
        row = 0
        col = 0
        for tid in state.tasks_cache:
            cb = QCheckBox(state.format_task(tid))
            cb.setChecked(True)
            self.result_task_checkboxes[tid] = cb
            self.tasks_layout.addWidget(cb, row, col)
            col += 1
            if col >= cols:
                col = 0
                row += 1

    def _build_deselect_menu(self) -> None:
        """Build the deselect parameters menu."""
        self.deselect_menu = QMenu(self)
        self.deselect_param_checkboxes.clear()

        for name in PARAMETER_OPTIONS:
            action = QAction(name, self)
            action.setCheckable(True)
            action.triggered.connect(self._update_deselect_label)
            self.deselect_menu.addAction(action)
            self.deselect_param_checkboxes[name] = action

    def _reset_weighting_ui(self) -> None:
        """Clear all weighting rows and internal weights; keep toggle state."""
        self.parameter_weights.clear()
        self.weight_rows.clear()

        # Clear UI rows
        if hasattr(self, "weighting_rows_layout"):
            while self.weighting_rows_layout.count():
                item = self.weighting_rows_layout.takeAt(0)
                if item.widget():
                    item.widget().deleteLater()

        # If enabled and we have parameters, create first row
        if self.weighting_enabled_cb is not None and self.weighting_enabled_cb.isChecked():
            self._ensure_next_weight_row()

    def _on_weighting_toggled(self, state_val: int) -> None:
        enabled = state_val == Qt.CheckState.Checked.value
        if not enabled:
            self._reset_weighting_ui()
            return
        self._reset_weighting_ui()

    def _selected_weight_params(self) -> set[str]:
        selected: set[str] = set()
        for combo, _slider, _lbl in self.weight_rows:
            val = combo.currentData()
            if isinstance(val, str) and val:
                selected.add(val)
        return selected

    def _current_ui_parameter_weights(self) -> Dict[str, float]:
        """
        Liefert die aktuell im Weighting-UI gewählten Gewichte als Dict[param] = weight.
        Quelle ist ausschließlich die UI (Combos + Slider), nicht self.parameter_weights.
        """
        weights: Dict[str, float] = {}
        if self.weighting_enabled_cb is None or not self.weighting_enabled_cb.isChecked():
            return weights

        for combo, slider, _lbl in self.weight_rows:
            param = combo.currentData()
            if isinstance(param, str) and param:
                weights[param] = float(self._weight_slider_to_float(slider.value()))
        return weights

    def _available_weight_params(self) -> list[str]:
        # PARAMETER_OPTIONS sind die “Parameter” im Tool
        selected = self._selected_weight_params()
        return [p for p in PARAMETER_OPTIONS if p not in selected]

    def _create_weight_row(self) -> None:
        available = self._available_weight_params()
        if not available:
            return

        row = QWidget()
        row_layout = QHBoxLayout(row)
        row_layout.setContentsMargins(0, 0, 0, 0)

        combo = QComboBox()
        combo.setFixedWidth(260)
        combo.addItem("Select parameter...", None)
        for p in available:
            combo.addItem(p, p)

        slider = QSlider(Qt.Orientation.Horizontal)
        # 1.0..5.0 in 0.5 steps => 2..10
        slider.setMinimum(2)
        slider.setMaximum(10)
        slider.setValue(self._weight_float_to_slider(1.0))
        slider.setSingleStep(1)
        slider.setPageStep(1)
        slider.setFixedWidth(220)
        slider.setEnabled(False)  # erst aktivieren, wenn Parameter gewählt

        value_lbl = QLabel(self._format_weight(1.0))
        value_lbl.setFixedWidth(44)
        value_lbl.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        value_lbl.setEnabled(False)

        # Signals
        combo.currentIndexChanged.connect(
            lambda _i, c=combo, s=slider, l=value_lbl: self._on_weight_row_changed(c, s, l)
        )
        slider.valueChanged.connect(
            lambda _v, c=combo, s=slider, l=value_lbl: self._on_weight_row_changed(c, s, l)
        )

        row_layout.addWidget(combo)
        row_layout.addWidget(slider)
        row_layout.addWidget(value_lbl)
        row_layout.addStretch()

        self.weighting_rows_layout.addWidget(row)
        self.weight_rows.append((combo, slider, value_lbl))

    def _on_weight_row_changed(self, combo: QComboBox, slider: QSlider, value_lbl: QLabel) -> None:
        # Wenn Toggle aus: ignorieren
        if self.weighting_enabled_cb is None or not self.weighting_enabled_cb.isChecked():
            return

        param = combo.currentData()
        if not isinstance(param, str) or not param:
            slider.setEnabled(False)
            value_lbl.setEnabled(False)
            return

        slider.setEnabled(True)
        value_lbl.setEnabled(True)

        weight = self._weight_slider_to_float(slider.value())
        value_lbl.setText(self._format_weight(weight))

        # Gewicht speichern (1.0..5.0 in 0.5er Schritten)
        self.parameter_weights[param] = float(weight)

        # Alle Combos neu aufbauen, damit keine Duplikate möglich sind
        self._rebuild_weight_combos(keep_current=True)

        # Wenn diese Zeile “aktiv” ist, nächste Zeile sicherstellen
        self._ensure_next_weight_row()

    def _rebuild_weight_combos(self, keep_current: bool = True) -> None:
        selected = self._selected_weight_params()

        for combo, slider, value_lbl in self.weight_rows:
            current = combo.currentData() if keep_current else None

            # Block signals während rebuild
            combo.blockSignals(True)
            combo.clear()
            combo.addItem("Select parameter...", None)

            # In dieser Combo darf current weiterhin drin sein
            allowed: list[str] = []
            for p in PARAMETER_OPTIONS:
                if p == current:
                    allowed.append(p)
                elif p not in selected:
                    allowed.append(p)

            for p in allowed:
                combo.addItem(p, p)

            # Restore selection
            if isinstance(current, str) and current:
                idx = combo.findData(current)
                combo.setCurrentIndex(idx if idx >= 0 else 0)
                slider.setEnabled(True)
                value_lbl.setEnabled(True)

                # Label/weight sync
                weight = self._weight_slider_to_float(slider.value())
                value_lbl.setText(self._format_weight(weight))
                self.parameter_weights[current] = float(weight)
            else:
                combo.setCurrentIndex(0)
                slider.setEnabled(False)
                value_lbl.setEnabled(False)

                # Falls vorher ein Param gesetzt war, sicherstellen, dass er nicht als Weight hängen bleibt
                if isinstance(current, str) and current:
                    self.parameter_weights.pop(current, None)

            combo.blockSignals(False)

    def _ensure_next_weight_row(self) -> None:
        if self.weighting_enabled_cb is None or not self.weighting_enabled_cb.isChecked():
            return

        available = self._available_weight_params()
        if not available:
            return

        if not self.weight_rows:
            self._create_weight_row()
            return

        last_combo, _last_slider, _last_lbl = self.weight_rows[-1]
        last_param = last_combo.currentData()
        if isinstance(last_param, str) and last_param:
            self._create_weight_row()

    def _toggle_deselect_menu(self, state_val: int) -> None:
        """Toggle the deselect parameters menu button."""
        self.deselect_btn.setEnabled(state_val == Qt.CheckState.Checked.value)

    def _show_deselect_menu(self) -> None:
        """Show the deselect parameters menu."""
        self.deselect_menu.exec(self.deselect_btn.mapToGlobal(self.deselect_btn.rect().bottomLeft()))

    def _update_deselect_label(self) -> None:
        """Update the deselect button label."""
        count = sum(1 for action in self.deselect_param_checkboxes.values() if action.isChecked())
        self.deselect_btn.setText("None" if count == 0 else f"{count} deselected")

    def _open_group_participants(self) -> None:
        """Open the group participants dialog."""
        if not state.participants_cache:
            QMessageBox.information(self, "No data", "Load a TSV file first.")
            return

        dialog = GroupParticipantsDialog(self)
        if dialog.exec() == GroupParticipantsDialog.DialogCode.Accepted:
            self._refresh_group_task_toggles()

    def _open_group_tasks(self) -> None:
        """Open the group tasks dialog."""
        if not state.tasks_cache:
            QMessageBox.information(self, "No data", "Load a TSV file first.")
            return

        dialog = GroupTasksDialog(self)
        if dialog.exec() == GroupTasksDialog.DialogCode.Accepted:
            self._refresh_tasks_listbox()
            self._refresh_group_task_toggles()

    def _on_normalize(self) -> None:
        """Normalize numeric data per participant by baseline task 0a (fallback 0b)."""
        if state.df is None:
            QMessageBox.information(self, "No data", "Load a TSV file first.")
            return

        try:
            state.normalized_df = normalize_by_participant_baseline(
                state.df,
                participant_col="Participant",
                task_col="TOI",
                baseline_primary="0a",
                baseline_fallback="0b",
            )
        except Exception as e:
            QMessageBox.critical(self, "Normalize failed", str(e))
            return

        # Normalisierung macht vorhandene Rank-Ergebnisse potentiell stale
        self._participant_rank_signature = None
        state.participant_rank_df = None

        if hasattr(self, "calc_metric_averages_btn"):
            self.calc_metric_averages_btn.setEnabled(True)

        QMessageBox.information(
            self,
            "Normalization complete",
            "Normalized data stored in state.normalized_df (baseline: 0a, fallback: 0b).",
        )

    def _on_calculate_metric_averages(self) -> None:
        """
        Berechnet Mittelwert und Standardabweichung je Participant und Task aus state.normalized_df.
        Zusätzlich: TCT (Mean/Std) je Participant und Task als zusätzliche Spalten (ohne Überschreiben).
        """
        if state.normalized_df is None:
            QMessageBox.information(
                self,
                "No normalized data",
                "Bitte zuerst 'Normalize' ausführen (state.normalized_df ist leer).",
            )
            return

        df = state.normalized_df

        # Spalten prüfen
        if "Participant" not in df.columns or "TOI" not in df.columns:
            QMessageBox.critical(self, "Missing columns", "normalized_df benötigt Spalten 'Participant' und 'TOI'.")
            return

        # Task-ID wie beim Task-Scan: Suffix nach letztem '_' (oder kompletter String)
        toi = df["TOI"].astype(str).str.strip()
        task_id = toi.str.rsplit("_", n=1).str[-1].str.strip()

        # Nur numerische Metriken aggregieren
        metric_cols = df.select_dtypes(include="number").columns.tolist()
        metric_cols = [c for c in metric_cols if c not in {"Participant", "TOI"}]

        if not metric_cols:
            QMessageBox.information(self, "No numeric metrics", "Keine numerischen Spalten zum Aggregieren gefunden.")
            return

        tmp = df.copy()
        tmp["_task_id"] = task_id

        # Aggregation: mean + std je Participant x Task (für alle numerischen Spalten)
        grouped = tmp.groupby(["Participant", "_task_id"], dropna=False)[metric_cols].agg(["mean", "std"])

        # Spaltennamen flach machen: "<metric>_mean", "<metric>_std"
        grouped.columns = [f"{metric}_{stat}" for (metric, stat) in grouped.columns.to_list()]

        # Index zurück in Spalten
        result = grouped.reset_index().rename(columns={"_task_id": "Task"})

        # --- Zusätzlich: TCT mean/std berechnen und als zusätzliche Spalten mergen ---
        tct_col: Optional[str] = None
        if "Duration" in df.columns:
            tct_col = "Duration"
        else:
            # heuristische Suche (case-insensitive)
            candidates = [
                "tct",
                "task completion time",
                "task_completion_time",
                "taskcompletiontime",
                "completion_time",
                "task time",
                "task_time",
            ]
            lower_map = {c.lower(): c for c in df.columns}
            for key in candidates:
                if key in lower_map:
                    tct_col = lower_map[key]
                    break

        tct_note = ""
        if tct_col is None:
            tct_note = "Keine TCT-Spalte gefunden (erwartet z.B. 'Duration')."
        elif not pd.api.types.is_numeric_dtype(df[tct_col]):
            tct_note = f"TCT-Spalte '{tct_col}' ist nicht numerisch."
        else:
            tct_tmp = tmp[["Participant", "_task_id", tct_col]].copy()
            tct_grouped = (
                tct_tmp.groupby(["Participant", "_task_id"], dropna=False)[tct_col]
                .agg(["mean", "std"])
                .reset_index()
                .rename(columns={"_task_id": "Task", "mean": "tct_mean", "std": "tct_std"})
            )

            # Nicht überschreiben: falls Spalten schon existieren, eindeutige Namen wählen
            if "tct_mean" in result.columns or "tct_std" in result.columns:
                tct_grouped = tct_grouped.rename(columns={"tct_mean": "tct_mean_tct", "tct_std": "tct_std_tct"})

            result = result.merge(tct_grouped, on=["Participant", "Task"], how="left")
            tct_note = f"TCT berechnet aus Spalte '{tct_col}'."

        state.metric_averages_df = result

        extra = f"\n{tct_note}" if tct_note else ""
        QMessageBox.information(
            self,
            "Metric averages calculated",
            f"Fertig. Ergebnis in state.metric_averages_df gespeichert.\n"
            f"Zeilen: {len(result)} | Spalten: {len(result.columns)}"
            f"{extra}",
        )

    def _current_rank_signature(self) -> dict:
        """Build a signature of inputs that affect participant_rank_df."""
        dataset_used = "normalized" if state.normalized_df is not None else "raw"

        selected_group_ids = [gid for gid, cb in self.result_group_checkboxes.items() if cb.isChecked()]
        selected_task_ids = [tid for tid, cb in self.result_task_checkboxes.items() if cb.isChecked()]

        excluded = []
        if self.deselect_enabled_cb.isChecked():
            excluded = sorted([name for name, action in self.deselect_param_checkboxes.items() if action.isChecked()])

        weights_enabled = bool(self.weighting_enabled_cb is not None and self.weighting_enabled_cb.isChecked())
        weights = {}
        if weights_enabled:
            ui_weights = self._current_ui_parameter_weights()
            weights = {k: float(v) for k, v in sorted(ui_weights.items())}

        return {
            "dataset_used": dataset_used,
            "selected_group_ids": sorted(selected_group_ids),
            "selected_task_ids": sorted(selected_task_ids),
            "excluded_metrics": excluded,
            "weights_enabled": weights_enabled,
            "weights": weights,
        }

    def _on_calculate_participant_rank(self) -> None:
        """
        Berechnet pro Participant ein Task-Ranking (hardest -> easiest) basierend auf kognitiver Last.

        Vorgehen:
        1) Metrikwerte je Participant×Task berechnen (mean über Zeilen).
        2) Pro Participant je Metrik Tasks ranken (Rank 1 = hardest; ties = average).
        3) Gewichtete Rank-Summe über Metriken bilden und Tasks nach kleinster Summe sortieren.
        """
        if state.df is None:
            QMessageBox.information(self, "No data", "Load a TSV file first.")
            return

        df = state.normalized_df if state.normalized_df is not None else state.df

        if "Participant" not in df.columns or "TOI" not in df.columns:
            QMessageBox.critical(self, "Missing columns", "DataFrame benötigt Spalten 'Participant' und 'TOI'.")
            return

        # --- Auswahl: Tasks ---
        selected_tasks = [tid for tid, cb in self.result_task_checkboxes.items() if cb.isChecked()]
        if not selected_tasks:
            selected_tasks = state.tasks_cache.copy()

        # --- Auswahl: Participants (über Gruppen) ---
        selected_group_ids = [gid for gid, cb in self.result_group_checkboxes.items() if cb.isChecked()]
        effective_groups = state.get_effective_participant_groups()

        selected_participants: list[str] = []
        if selected_group_ids:
            s = set()
            for gid in selected_group_ids:
                for p in effective_groups.get(gid, []):
                    s.add(p)
            selected_participants = sorted(s)
        else:
            selected_participants = state.participants_cache.copy()

        if not selected_participants:
            QMessageBox.information(self, "No participants", "Keine Teilnehmer ausgewählt/gefunden.")
            return
        if not selected_tasks:
            QMessageBox.information(self, "No tasks", "Keine Tasks ausgewählt/gefunden.")
            return

        # --- Deselect Parameters ---
        deselected: set[str] = set()
        if self.deselect_enabled_cb.isChecked():
            deselected = {name for name, action in self.deselect_param_checkboxes.items() if action.isChecked()}

        metrics = [m for m in PARAMETER_OPTIONS if m not in deselected]
        if not metrics:
            QMessageBox.information(self, "No metrics", "Alle Metriken sind abgewählt (Deselect Parameters).")
            return

        # --- Weights (Single Source of Truth: UI) ---
        weights: Dict[str, float] = {m: 1.0 for m in metrics}
        if self.weighting_enabled_cb is not None and self.weighting_enabled_cb.isChecked():
            ui_weights = self._current_ui_parameter_weights()
            for m in metrics:
                if m in ui_weights:
                    weights[m] = float(ui_weights[m])

        # --- Task-ID aus TOI ableiten (Suffix nach letztem '_') ---
        tmp = df.copy()
        tmp["_task_id"] = tmp["TOI"].astype(str).str.strip().str.rsplit("_", n=1).str[-1].str.strip()

        # Filter auf Auswahl
        tmp = tmp[tmp["Participant"].isin(selected_participants)]
        tmp = tmp[tmp["_task_id"].isin(selected_tasks)]

        if tmp.empty:
            QMessageBox.information(
                self,
                "No data after filtering",
                "Nach Filterung (Participants/Tasks) sind keine Datenzeilen übrig.",
            )
            return

        # --- Metrik -> Spaltenmapping + Richtung (True: höher = härter) ---
        # Referenz: TCT↑, SD(TCT)↑, Pupil Diameter↑, Saccade Velocity↓, Peak Saccade Velocity↓, Saccade Amplitude↓.
        def _find_col_case_insensitive(candidates: list[str]) -> Optional[str]:
            lower_map = {c.lower(): c for c in tmp.columns}
            for cand in candidates:
                if cand.lower() in lower_map:
                    return lower_map[cand.lower()]
            return None

        metric_specs: Dict[str, Dict[str, object]] = {}

        # TCT
        tct_col = "Duration" if "Duration" in tmp.columns else _find_col_case_insensitive(
            ["tct", "task_completion_time", "task completion time", "taskcompletiontime", "completion_time", "task_time"]
        )
        if tct_col is not None:
            metric_specs["Task Completion Time (TCT)"] = {"col": tct_col, "agg": "mean", "harder_high": True}
            metric_specs["Standard Deviation of TCT"] = {"col": tct_col, "agg": "std", "harder_high": True}

        # Pupil
        pupil_col = _find_col_case_insensitive(["Average_pupil_diameter", "pupil", "pupil_diameter", "average pupil diameter"])
        if pupil_col is not None:
            metric_specs["Pupil Diameter"] = {"col": pupil_col, "agg": "mean", "harder_high": True}

        # Saccade velocity
        sacc_vel_col = _find_col_case_insensitive(["Average_velocity", "saccade_velocity", "average velocity"])
        if sacc_vel_col is not None:
            metric_specs["Saccade Velocity"] = {"col": sacc_vel_col, "agg": "mean", "harder_high": False}

        # Peak saccade velocity
        peak_vel_col = _find_col_case_insensitive(["Peak_velocity", "peak_velocity", "peak saccade velocity"])
        if peak_vel_col is not None:
            metric_specs["Peak Saccade Velocity"] = {"col": peak_vel_col, "agg": "mean", "harder_high": False}

        # Saccade amplitude
        sacc_amp_col = _find_col_case_insensitive(["Saccade_amplitude", "saccade_amplitude", "saccade amplitude"])
        if sacc_amp_col is not None:
            metric_specs["Saccade Amplitude"] = {"col": sacc_amp_col, "agg": "mean", "harder_high": False}

        # Nur Metriken verwenden, die wir auch wirklich berechnen können
        usable_metrics: list[str] = []
        missing_metrics: list[str] = []
        for m in metrics:
            if m in metric_specs:
                col = metric_specs[m]["col"]
                if isinstance(col, str) and col in tmp.columns and pd.api.types.is_numeric_dtype(tmp[col]):
                    usable_metrics.append(m)
                else:
                    missing_metrics.append(m)
            else:
                missing_metrics.append(m)

        if not usable_metrics:
            QMessageBox.critical(
                self,
                "No usable metrics",
                "Keine der ausgewählten Metriken konnte auf numerische Spalten gemappt werden.\n"
                f"Ausgewählt: {metrics}",
            )
            return

        # --- Schritt 1: Werte je Participant×Task berechnen ---
        base_index = tmp.groupby(["Participant", "_task_id"], dropna=False).size().reset_index()[["Participant", "_task_id"]]
        base_index = base_index.rename(columns={"_task_id": "Task"}).drop_duplicates()

        values_df = base_index.copy()

        for m in usable_metrics:
            spec = metric_specs[m]
            col = spec["col"]  # type: ignore[assignment]
            agg = spec["agg"]  # type: ignore[assignment]
            if not isinstance(col, str) or not isinstance(agg, str):
                continue

            g = tmp.groupby(["Participant", "_task_id"], dropna=False)[col]
            if agg == "mean":
                s = g.mean()
            elif agg == "std":
                s = g.std(ddof=1)
            else:
                raise ValueError(f"Unbekannte Aggregation: {agg}")

            s = s.reset_index().rename(columns={"_task_id": "Task", col: m})
            values_df = values_df.merge(s, on=["Participant", "Task"], how="left")

        # --- Schritt 2: Pro Participant je Metrik ranken (Rank 1 = hardest) ---
        ranks_df = values_df[["Participant", "Task"]].copy()

        for m in usable_metrics:
            harder_high = bool(metric_specs[m]["harder_high"])
            ascending = not harder_high
            ranks_df[m] = (
                values_df.groupby("Participant", dropna=False)[m]
                .rank(method="average", ascending=ascending, na_option="keep")
            )

        # --- Schritt 3: Gewichtete Rank-Summe + finaler Task-Rank ---
        weighted_sum = pd.Series(0.0, index=ranks_df.index)
        weight_sum = pd.Series(0.0, index=ranks_df.index)

        for m in usable_metrics:
            w = float(weights.get(m, 1.0))
            r = ranks_df[m]
            mask = r.notna()
            weighted_sum = weighted_sum + (r.fillna(0.0) * w)
            weight_sum = weight_sum + (mask.astype(float) * w)

        final_score = weighted_sum.where(weight_sum > 0, other=pd.NA)

        out = ranks_df[["Participant", "Task"]].copy()
        out["rank_sum"] = final_score

        out["final_rank"] = out.groupby("Participant", dropna=False)["rank_sum"].rank(
            method="average", ascending=True, na_option="keep"
        )

        for m in usable_metrics:
            out[f"{m}__rank"] = ranks_df[m]

        out = out.sort_values(["Participant", "final_rank", "Task"], ascending=[True, True, True]).reset_index(drop=True)

        state.participant_rank_df = out
        self._participant_rank_signature = self._current_rank_signature()

        note = ""
        if missing_metrics:
            note = "\nNicht gemappte/fehlende Metriken: " + ", ".join(missing_metrics)

        QMessageBox.information(
            self,
            "Participant rank calculated",
            "Fertig. Ergebnis in state.participant_rank_df gespeichert.\n"
            f"Participants: {out['Participant'].nunique()} | Tasks: {out['Task'].nunique()} | Rows: {len(out)}\n"
            f"Verwendete Metriken: {', '.join(usable_metrics)}"
            f"{note}",
        )

    def _show_rank_results_popup(
        self,
        title: str,
        header: str,
        sections: list[tuple[str, pd.DataFrame]],
        warnings: list[str],
    ) -> None:
        dlg = QDialog(self)
        dlg.setWindowTitle(title)
        dlg.setModal(True)
        dlg.setMinimumSize(900, 700)

        layout = QVBoxLayout(dlg)

        text = QTextEdit()
        text.setReadOnly(True)

        parts: list[str] = []
        parts.append(header.strip())
        parts.append("")

        for section_title, df in sections:
            parts.append(section_title)
            parts.append("-" * len(section_title))
            if df.empty:
                parts.append("(keine Daten)")
            else:
                # df ist bereits auf Rank/Task/Score reduziert
                parts.append(df.to_string(index=False))
            parts.append("")

        if warnings:
            parts.append("Warnings")
            parts.append("--------")
            for w in warnings:
                parts.append(f"- {w}")
            parts.append("")

        text.setPlainText("\n".join(parts))
        layout.addWidget(text)

        btn_row = QHBoxLayout()
        btn_row.addStretch()
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(dlg.accept)
        btn_row.addWidget(close_btn)
        layout.addLayout(btn_row)

        dlg.exec()

    def _on_show_results(self) -> None:
        """Handle Show Results button click."""
        if state.df is None:
            QMessageBox.information(self, "No data", "Load a TSV file first.")
            return

        selected_groups = [gid for gid, cb in self.result_group_checkboxes.items() if cb.isChecked()]
        selected_tasks = [tid for tid, cb in self.result_task_checkboxes.items() if cb.isChecked()]
        domains = [name for name, cb in self.result_domain_vars.items() if cb.isChecked()]
        mode = self.mode_combo.currentText()

        deselected = []
        if self.deselect_enabled_cb.isChecked():
            deselected = [name for name, action in self.deselect_param_checkboxes.items() if action.isChecked()]

        # Parameter weights (nur anzeigen, wenn aktiviert)
        weights_text = "(disabled)"
        if self.weighting_enabled_cb is not None and self.weighting_enabled_cb.isChecked():
            if not self.parameter_weights:
                weights_text = "(none)"
            else:
                parts = [f"{k} = {self._format_weight(v)}" for k, v in sorted(self.parameter_weights.items())]
                weights_text = ", ".join(parts)

        # --- Rank domain: show computed participant rank results ---
        if "Rank" in domains:
            if state.participant_rank_df is None or state.participant_rank_df.empty:
                QMessageBox.information(
                    self,
                    "Rank Results not available",
                    "Keine Rank-Ergebnisse vorhanden.\nBitte zuerst 'Calculate Participant Rank' ausführen.",
                )
                return

            current_sig = self._current_rank_signature()
            if self._participant_rank_signature != current_sig:
                QMessageBox.information(
                    self,
                    "Rank Results stale",
                    "Die Rank-Ergebnisse passen nicht zu den aktuellen UI-Auswahlen (Groups/Tasks/Deselect/Weights oder Datenbasis).\n"
                    "Bitte 'Calculate Participant Rank' erneut ausführen.",
                )
                return

            rank_df = state.participant_rank_df.copy()

            # Scope: Tasks
            task_scope = selected_tasks if selected_tasks else state.tasks_cache.copy()
            # Scope: Participants via groups
            effective_groups = state.get_effective_participant_groups()
            effective_names = state.get_effective_group_names()

            group_ids = selected_groups if selected_groups else list(effective_groups.keys())
            if not group_ids:
                group_ids = ["ALL"]

            warnings: list[str] = []
            sections: list[tuple[str, pd.DataFrame]] = []

            dataset_used = "normalized" if state.normalized_df is not None else "raw"
            excluded_metrics = sorted(deselected) if deselected else []
            weights_list = []
            if self.weighting_enabled_cb is not None and self.weighting_enabled_cb.isChecked():
                ui_weights = self._current_ui_parameter_weights()
                weights_list = [f"{k}={self._format_weight(v)}" for k, v in sorted(ui_weights.items())]

            # Helper: format a table
            def _table_from_scores(df_scores: pd.DataFrame) -> pd.DataFrame:
                # df_scores: columns Task, rank_sum
                t = df_scores.copy()
                t = t.sort_values(["rank_sum", "Task"], ascending=[True, True]).reset_index(drop=True)
                t.insert(0, "Rank", range(1, len(t) + 1))
                t = t.rename(columns={"rank_sum": "Score"})
                t = t[["Rank", "Task", "Score"]]
                return t

            # Build participant list per group
            group_to_participants: dict[str, list[str]] = {}
            for gid in group_ids:
                members = effective_groups.get(gid, [])
                if not members:
                    warnings.append(f"Gruppe '{effective_names.get(gid, gid)}' hat 0 Mitglieder (übersprungen).")
                    continue
                group_to_participants[gid] = members

            # If no groups had members, fallback to all participants
            if not group_to_participants:
                all_p = state.participants_cache.copy()
                if not all_p:
                    QMessageBox.information(self, "No participants", "Keine Teilnehmer gefunden.")
                    return
                group_to_participants = {"ALL": all_p}

            # Filter rank_df to task scope early
            rank_df = rank_df[rank_df["Task"].isin(task_scope)]

            # Determine which participants have which tasks (for warnings)
            # We'll warn if a participant is missing any selected task in the rank_df.
            for gid, members in group_to_participants.items():
                for p in members:
                    p_tasks = set(rank_df.loc[rank_df["Participant"] == p, "Task"].astype(str).tolist())
                    for t in task_scope:
                        if t not in p_tasks:
                            warnings.append(f"{p} hatte keine Zeilen für Task {t}")

            # Mode handling
            def _add_group_mean_sections() -> None:
                for gid, members in group_to_participants.items():
                    gname = effective_names.get(gid, gid)
                    sub = rank_df[rank_df["Participant"].isin(members)]
                    if sub.empty:
                        warnings.append(f"Gruppe '{gname}' hat nach Filterung keine Daten (übersprungen).")
                        continue
                    # mean rank_sum per task
                    g_scores = (
                        sub.groupby("Task", dropna=False)["rank_sum"]
                        .mean()
                        .reset_index()
                    )
                    g_table = _table_from_scores(g_scores)
                    sections.append((f"Group mean: {gname}", g_table))

            def _add_individual_sections() -> None:
                # participants inside selected groups (or all fallback)
                seen: set[str] = set()
                for _gid, members in group_to_participants.items():
                    for p in members:
                        if p in seen:
                            continue
                        seen.add(p)
                        sub = rank_df[rank_df["Participant"] == p][["Task", "rank_sum"]].copy()
                        if sub.empty:
                            warnings.append(f"{p} hat nach Filterung keine Daten (übersprungen).")
                            continue
                        p_table = _table_from_scores(sub)
                        sections.append((f"Participant: {p}", p_table))

            if mode == "Only group mean":
                _add_group_mean_sections()
            elif mode == "Each participant for selected groups":
                _add_individual_sections()
            elif mode == "Group mean and individual participants":
                _add_group_mean_sections()
                _add_individual_sections()
            else:
                warnings.append(f"Unbekannter Mode '{mode}' (zeige Individual-Rankings).")
                _add_individual_sections()

            # Header paragraph
            # #participants/#tasks should reflect the popup scope (after group/task selection)
            participants_in_scope: set[str] = set()
            for members in group_to_participants.values():
                participants_in_scope.update(members)
            participants_in_scope = {p for p in participants_in_scope if p in set(rank_df["Participant"].unique())}

            tasks_in_scope = sorted(set(task_scope) & set(rank_df["Task"].unique()))

            header = (
                f"Dataset: {dataset_used}; "
                f"Participants: {len(participants_in_scope)}; "
                f"Tasks: {len(tasks_in_scope)}; "
                f"Mode: {mode}; "
                f"Excluded metrics: {', '.join(excluded_metrics) if excluded_metrics else '(none)'}; "
                f"Custom weights: {', '.join(weights_list) if weights_list else '(none)'}"
            )

            self._show_rank_results_popup(
                title="Rank Results",
                header=header,
                sections=sections,
                warnings=warnings,
            )
            return

        # Fallback: existing placeholder message
        msg = (
            f"Mode: {mode}\n"
            f"Groups selected: {len(selected_groups)}\n"
            f"Tasks selected: {len(selected_tasks)}\n"
            f"Result domains: {', '.join(domains) if domains else '(none)'}\n"
            f"Deselected parameters: {', '.join(deselected) if deselected else '(none)'}\n"
            f"Parameter weights: {weights_text}"
        )
        QMessageBox.information(self, "Show Results (placeholder)", msg)

    def _on_print_exec_summary(self) -> None:
        """Handle Print Executive Summary button click."""
        if state.df is None:
            QMessageBox.information(self, "No data", "Load a TSV file first.")
            return
        QMessageBox.information(
            self,
            "Executive Summary (placeholder)",
            "This will generate the executive summary later.",
        )
```

> Tokens: 21k sent, 11k received. Cost: $0.19 message, $2.46 session.  
> Applied edit to main_window.py  
> Commit 8e1bb8f fix: Verwende UI-Weights live für Rank, Signatur und Anzeige  
> You can use /undo to undo and discard each aider commit.  

####  create a new python file where implement a function that is activatetd when the button `exec_summary_btn` is pressed  
> litellm.InternalServerError: InternalServerError: OpenAIException - Connection error.  
> The API provider's servers are down or overloaded.  
> Retrying in 0.2 seconds...  
> litellm.InternalServerError: InternalServerError: OpenAIException - Connection error.  
> The API provider's servers are down or overloaded.  
> Retrying in 0.5 seconds...  
> litellm.InternalServerError: InternalServerError: OpenAIException - Connection error.  
> The API provider's servers are down or overloaded.  
> Retrying in 1.0 seconds...  
> litellm.InternalServerError: InternalServerError: OpenAIException - Connection error.  
> The API provider's servers are down or overloaded.  
> Retrying in 2.0 seconds...  
> litellm.InternalServerError: InternalServerError: OpenAIException - Connection error.  
> The API provider's servers are down or overloaded.  
> Retrying in 4.0 seconds...  
> litellm.InternalServerError: InternalServerError: OpenAIException - Connection error.  
> The API provider's servers are down or overloaded.  
> Retrying in 8.0 seconds...  
> litellm.InternalServerError: InternalServerError: OpenAIException - Connection error.  
> The API provider's servers are down or overloaded.  
> Retrying in 16.0 seconds...  
> litellm.InternalServerError: InternalServerError: OpenAIException - Connection error.  
> The API provider's servers are down or overloaded.  
> Retrying in 32.0 seconds...  
> litellm.InternalServerError: InternalServerError: OpenAIException - Connection error.  
> The API provider's servers are down or overloaded.  
